<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 5</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 5</h1>\[
\newcommand{\CC}{\mathbb{C}}
\newcommand{\HH}{\mathbb{H}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\jj}{\mathrm{j}}
\newcommand{\kk}{\mathrm{k}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\RF}{\mathrm{RF}}
\newcommand{\sys}{\mathrm{sys}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % deprecated, use braket instead.
\newcommand{\braket}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\rank}[1]{\mathrm{rank}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\orac}{\mathrm{Orac}}
\newcommand{\?}{} % sometimes I need just a separator other than whitespace
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0b1ab42">Setup</a>
<ul>
<li><a href="#org7ed5be0">Setup Python Libaries</a></li>
<li><a href="#org2e7f8d9">Code from earlier Chapters</a></li>
<li><a href="#org28486b5">Quantum Fourier Transform</a></li>
<li><a href="#org183f0ff">Addition in Fourier Space</a></li>
<li><a href="#org3f35fb0">Multiplication in Fourier Space</a></li>
<li><a href="#org826641a">Order Finding</a></li>
<li><a href="#orge3b0684">Factoring</a></li>
</ul>
</li>
<li><a href="#orgb567b40">Exercises</a>
<ul>
<li><a href="#org9717b51">Exercise 5.1</a></li>
<li><a href="#org90476e8">Exercise 5.2</a></li>
<li><a href="#org22f76d9">Exercise 5.3 (Classical fast Fourier transform)</a></li>
<li><a href="#orgfb4a13d">Exercise 5.4</a></li>
<li><a href="#org03191e5">Exercise 5.5</a></li>
<li><a href="#org05e0a35">Exercise 5.6 (Approximate quantum Fourier transform)</a></li>
<li><a href="#org31d77f5">Exercise 5.7</a></li>
<li><a href="#org34b634d">Exercise 5.8</a></li>
<li><a href="#orgf8ed32c">Exercise 5.9</a></li>
<li><a href="#org51204b5">Exercise 5.10</a></li>
<li><a href="#org73c51ed">Exercise 5.11</a></li>
<li><a href="#orgbaf418a">Exercise 5.12</a></li>
<li><a href="#orgc1748a8">Exercise 5.13</a></li>
<li><a href="#org6ede131">Exercise 5.14</a></li>
<li><a href="#org403812a">Exercise 5.15</a></li>
<li><a href="#org79fef9e">Exercise 5.16</a></li>
<li><a href="#orgeb947eb">Exercise 5.17</a></li>
<li><a href="#org172fa0c">Exercise 5.18 (Factoring 91)</a></li>
<li><a href="#orgb838818">Exercise 5.19</a></li>
<li><a href="#orgf540a17">Exercise 5.20</a></li>
<li><a href="#exercise-5-21">Exercise 5.21</a></li>
<li><a href="#exercise-5-22">Exercise 5.22</a></li>
<li><a href="#exercise-5-23">Exercise 5.23</a></li>
<li><a href="#exercise-5-24">Exercise 5.24</a></li>
<li><a href="#orgf5e50e8">Exercise 5.25</a></li>
<li><a href="#exercise-5-26">Exercise 5.26</a></li>
<li><a href="#org84c6624"><span class="todo WIP">WIP</span> Exercise 5.27</a></li>
<li><a href="#exercise-5-28">Exercise 5.28</a></li>
<li><a href="#orgf53b794">Exercise 5.29</a></li>
</ul>
</li>
<li><a href="#orgf29f0e5">References</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0b1ab42" class="outline-2">
<h2 id="org0b1ab42">Setup</h2>
<div class="outline-text-2" id="text-org0b1ab42">
</div>
<div id="outline-container-org7ed5be0" class="outline-3">
<h3 id="org7ed5be0">Setup Python Libaries</h3>
<div class="outline-text-3" id="text-org7ed5be0">
<p>
Tangled:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org84e0964"><span class="org-keyword">import</span> math
<span class="org-keyword">import</span> random
<span class="org-keyword">from</span> fractions <span class="org-keyword">import</span> Fraction
<span class="org-keyword">from</span> numbers <span class="org-keyword">import</span> Integral
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> Optional, Union

<span class="org-keyword">import</span> sympy <span class="org-keyword">as</span> sp
<span class="org-keyword">from</span> qiskit <span class="org-keyword">import</span> (AncillaRegister, ClassicalRegister, QuantumCircuit, QuantumRegister,
                    transpile)
<span class="org-keyword">from</span> qiskit.circuit <span class="org-keyword">import</span> ControlledGate, Gate
<span class="org-keyword">from</span> qiskit.circuit.library <span class="org-keyword">import</span> SwapGate
<span class="org-keyword">from</span> qiskit_aer <span class="org-keyword">import</span> AerSimulator
<span class="org-keyword">from</span> sympy <span class="org-keyword">import</span> I, exp, pi
</pre>
</div>

<p>
Not tangled:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> fractions <span class="org-keyword">import</span> Fraction
<span class="org-keyword">from</span> qiskit.circuit <span class="org-keyword">import</span> QuantumCircuit, Gate
</pre>
</div>

<p>
NOTE: In this chapter I implement Shor's Algorithm using Qiskit. It works but it is not
pretty. Do not expect it to factor anything larger than 15 or 21 (via simulation). I did
not do any optimizations to reduce the number of qubits or gates required. My goal was to
closely follow the presentation in the book and stay conceptually simple. For a simulation
<i>probably</i> the number of qubits is the critical measure.
</p>

<p>
Also note that I tried to put the sub-circuits into didicated <code>Gate</code> and <code>ControlledGate</code>
classes. Mainly to have nice drawings. For example the <code>ControlledGate</code> makes sure that
you clearly see which qubits are the controls. Unfortunately this seem to come with a
major performance bottleneck for big circuits (I did not investigate this deeper but it
seems that a lot of stuff is copied around and work is repeated). Therefore sometimes had
to do strange workarounds making the code less readable - sorry for that. This is my first
time <i>really</i> using Qiskit so do not expect too much from the code.
</p>
</div>
</div>

<div id="outline-container-org2e7f8d9" class="outline-3">
<h3 id="org2e7f8d9">Code from earlier Chapters</h3>
<div class="outline-text-3" id="text-org2e7f8d9">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> chapter_4 <span class="org-keyword">import</span> Rz, theta
<span class="org-keyword">from</span> continued_fractions <span class="org-keyword">import</span> get_convergent
</pre>
</div>
</div>
</div>

<div id="outline-container-org28486b5" class="outline-3">
<h3 id="org28486b5">Quantum Fourier Transform</h3>
<div class="outline-text-3" id="text-org28486b5">
<p>
These are the operators \(R_k\) appearing in the implementation of the Fourier Transform:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org809bc79"><span class="org-variable-name">k</span> <span class="org-operator">=</span> sp.symbols(<span class="org-string">'k'</span>, integer<span class="org-operator">=</span><span class="org-constant">True</span>)
<span class="org-variable-name">Rk</span> <span class="org-operator">=</span> sp.simplify(exp(2<span class="org-operator">*</span>pi<span class="org-operator">*</span>I<span class="org-operator">*</span>2<span class="org-operator">**</span>(<span class="org-operator">-</span>k<span class="org-operator">-</span>1)) <span class="org-operator">*</span> Rz.subs(theta, 2<span class="org-operator">*</span>pi<span class="org-operator">*</span>2<span class="org-operator">**</span>(<span class="org-operator">-</span>k)))
</pre>
</div>

<p>
Next we define a function to generate a circuit implementing the quantum Fourier
transform. This is very easy since the part containing the rotations has a nice recursive
structure.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">make_qft</span>(size: Integral) <span class="org-operator">-&gt;</span> Gate:
    <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(size)

    <span class="org-keyword">def</span> <span class="org-function-name">append_rotations</span>(qc: QuantumCircuit, size: Integral):
        <span class="org-keyword">if</span> size <span class="org-operator">==</span> 0:
            <span class="org-keyword">return</span>

        qc.h(size <span class="org-operator">-</span> 1)
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(size <span class="org-operator">-</span> 1, 0, <span class="org-operator">-</span>1):  <span class="org-comment-delimiter"># </span><span class="org-comment">reversed order makes a nicer plot</span>
            qc.cp(math.pi <span class="org-operator">*</span> 2<span class="org-operator">**</span>(<span class="org-operator">-</span>i), size <span class="org-operator">-</span> 1, size <span class="org-operator">-</span> i <span class="org-operator">-</span> 1)

        append_rotations(qc, size <span class="org-operator">-</span> 1)

    <span class="org-keyword">def</span> <span class="org-function-name">append_swaps</span>(qc, size):
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(size <span class="org-operator">//</span> 2):
            qc.swap(i, size <span class="org-operator">-</span> i <span class="org-operator">-</span> 1)

    append_rotations(qc, size)
    append_swaps(qc, size)

    <span class="org-keyword">return</span> qc.to_gate(label<span class="org-operator">=</span><span class="org-string">"QFT"</span>)


<span class="org-keyword">def</span> <span class="org-function-name">make_qft_dg</span>(size: Integral) <span class="org-operator">-&gt;</span> Gate:
    <span class="org-variable-name">qft</span> <span class="org-operator">=</span> make_qft(size)
    <span class="org-keyword">return</span> qft.definition.inverse().to_gate(label<span class="org-operator">=</span><span class="org-string">"QFT^&#8224;"</span>)
</pre>
</div>

<p>
Note that qiskit orders the wires in a different order then the book.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">qft</span> <span class="org-operator">=</span> make_qft(4)
qft.definition.draw()
</pre>
</div>

<pre class="example">
                                                                          ┌───┐
q_0: ──────■───────────────────────────────■──────────────────────■───────┤ H ├─X─
           │                               │                ┌───┐ │P(π/2) └───┘ │
q_1: ──────┼────────■──────────────────────┼────────■───────┤ H ├─■─────────X───┼─
           │        │                ┌───┐ │P(π/4)  │P(π/2) └───┘           │   │
q_2: ──────┼────────┼────────■───────┤ H ├─■────────■───────────────────────X───┼─
     ┌───┐ │P(π/8)  │P(π/4)  │P(π/2) └───┘                                      │
q_3: ┤ H ├─■────────■────────■──────────────────────────────────────────────────X─
     └───┘
</pre>
</div>
</div>

<div id="outline-container-org183f0ff" class="outline-3">
<h3 id="org183f0ff">Addition in Fourier Space</h3>
<div class="outline-text-3" id="text-org183f0ff">
<p>
Recall that phase estimation for the order finding problem requires to exponentiate an
operator \(U_a:\ket{j}\mapsto\ket{aj\mod N}\). This operator has the nice property
</p>

<p>
\[
  U_a^n = U_{a^n \mod N} .
\]
</p>

<p>
Therefore having a way to implement \(U_a\) for any \(a\) already gives us the required
powers. <i>This is important</i> since implementing the powers of \(U_a\) by just repeating the
circuit for \(U_a\) would result in an <i>exponantially</i> deep circuit for phase estimation.
</p>

<p>
To implement \(U_a\) we need to be able to perform basic arithmetic. We will implement the
following operations:
</p>

<ul class="org-ul">
<li>Addition</li>
<li>Modular Addition</li>
<li>Modular Multiplication</li>
</ul>

<p>
More precisely we only implement the unary versions of these operations. For example
instead of \((a,b)\mapsto a+b\) we implement \(b\mapsto a+b\) for a fixed integer \(a\). We call
this an <i>incrementer</i>.
</p>

<p>
Our implementation closely follows (Thomas G. Draper, 2000) and (Stephane Beauregard, 2003). For
simplicity we omit some optimizations at the cost of a slower algorithm. We implement all
operations in Fourier space. This saves qubits, at the cost of a deeper circuit.
</p>

<p>
Let us start with the incrementation operator in Fourier space. Let us denote
\(\ket{\phi(j)}=\FT\ket{j}\). This circuit implements \(\ket{\phi(j)}\mapsto\ket{\phi(a+j)}\)
for a fixed integer \(a\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">make_control_prefix</span>(num_ctrls: <span class="org-builtin">int</span>):
    <span class="org-keyword">return</span> <span class="org-string">""</span> <span class="org-keyword">if</span> num_ctrls <span class="org-operator">==</span> 0 <span class="org-keyword">else</span> <span class="org-string">"c"</span><span class="org-operator">*</span>num_ctrls <span class="org-operator">+</span> <span class="org-string">"_"</span>


<span class="org-keyword">class</span> <span class="org-type">FourierIncrementGate</span>(Gate):
    <span class="org-doc">"""Implements |&#981;(j)&gt; -&gt; |&#981;(a+j)&gt; where a is the increment."""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, num_qubits: <span class="org-builtin">int</span>, increment: <span class="org-builtin">int</span>,
                 label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>):
        <span class="org-doc">"""Create a new Fourier incrementer gate."""</span>
        <span class="org-builtin">super</span>().__init__(f<span class="org-string">"&#981;inc(</span>{increment}<span class="org-string">)"</span>, num_qubits, [], label<span class="org-operator">=</span>label)
        <span class="org-keyword">assert</span> 2<span class="org-operator">**</span>num_qubits <span class="org-operator">&gt;</span> increment, \
            f<span class="org-string">"Increment </span>{increment}<span class="org-string"> is too large for </span>{num_qubits}<span class="org-string"> bits."</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">_increment</span> <span class="org-operator">=</span> increment

    <span class="org-keyword">def</span> <span class="org-function-name">_define</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(<span class="org-keyword">self</span>._num_qubits)

        <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-keyword">self</span>._num_qubits):
            qc.p(2<span class="org-operator">*</span>math.pi<span class="org-operator">*</span><span class="org-keyword">self</span>._increment<span class="org-operator">*</span>2<span class="org-operator">**</span>(<span class="org-operator">-</span><span class="org-keyword">self</span>._num_qubits<span class="org-operator">+</span>k), k)

        <span class="org-keyword">self</span>.<span class="org-variable-name">definition</span> <span class="org-operator">=</span> qc
</pre>
</div>

<p>
The reasoning to see that the circuit does what we want is essentially the same as the
reasoning behind the representation of \(\FT\ket{j}\) as a product state.
</p>

<p>
The actual incrementation operator can be obtained by conjugating this circuit by the
Fourier transform:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">IncrementGate</span>(Gate):
    <span class="org-doc">"""Implements |j&gt; -&gt; |a+j&gt; where a is the increment."""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, num_qubits: <span class="org-builtin">int</span>, increment: <span class="org-builtin">int</span>,
                 label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>):
        <span class="org-doc">"""Create a new incrementer gate."""</span>
        <span class="org-builtin">super</span>().__init__(f<span class="org-string">"inc(</span>{increment}<span class="org-string">)"</span>, num_qubits, [], label<span class="org-operator">=</span>label)
        <span class="org-keyword">assert</span> 2<span class="org-operator">**</span>num_qubits <span class="org-operator">&gt;</span> increment, \
            f<span class="org-string">"Increment </span>{increment}<span class="org-string"> is too large for </span>{num_qubits}<span class="org-string"> bits."</span>
        <span class="org-keyword">self</span>.<span class="org-variable-name">_increment</span> <span class="org-operator">=</span> increment

    <span class="org-keyword">def</span> <span class="org-function-name">_define</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(<span class="org-keyword">self</span>._num_qubits)
        <span class="org-variable-name">finc</span> <span class="org-operator">=</span> FourierIncrementGate(<span class="org-keyword">self</span>._num_qubits, <span class="org-keyword">self</span>._increment)
        <span class="org-variable-name">qft</span> <span class="org-operator">=</span> make_qft(<span class="org-keyword">self</span>._num_qubits)
        <span class="org-variable-name">qft_dg</span> <span class="org-operator">=</span> make_qft_dg(<span class="org-keyword">self</span>._num_qubits)

        qc.append(qft, <span class="org-builtin">range</span>(<span class="org-keyword">self</span>._num_qubits))
        qc.append(finc, <span class="org-builtin">range</span>(<span class="org-keyword">self</span>._num_qubits))
        qc.append(qft_dg, <span class="org-builtin">range</span>(<span class="org-keyword">self</span>._num_qubits))

        <span class="org-keyword">self</span>.<span class="org-variable-name">definition</span> <span class="org-operator">=</span> qc
</pre>
</div>

<p>
We actually do not need <code>make_incrementer</code> for our phase estimation (since we want to do
as many operations as possible in the Fourier space due to the cost of the Fourier
transform). But it is still nice to have it, for example for testing purposes.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">inc</span> <span class="org-operator">=</span> IncrementGate(4, 3)
inc.definition.decompose(<span class="org-string">'&#981;inc(3)'</span>).draw()
</pre>
</div>

<pre class="example">
     ┌──────┐┌─────────┐┌────────┐
q_0: ┤0     ├┤ P(3π/8) ├┤0       ├
     │      │├─────────┤│        │
q_1: ┤1     ├┤ P(3π/4) ├┤1       ├
     │  QFT │├─────────┤│  QFT^† │
q_2: ┤2     ├┤ P(3π/2) ├┤2       ├
     │      │└┬───────┬┘│        │
q_3: ┤3     ├─┤ P(3π) ├─┤3       ├
     └──────┘ └───────┘ └────────┘
</pre>


<p>
Next we implement modular incrementation. Unfortunately the circuit is a bit
complicated. But the idea is simple: Let \(a\) be the increment, \(N\) the modulus, and let
\(b\) be the input to the circuit. We want to calculate \(a+b\mod N\). The size of the circuit
is chosen in a way that \(a\) and \(b\) can be represented with leading bit still being zero
(this implies in particular that \(a+b\) can be represented). The circuit <i>essentially</i> does
the following (arithmetic carried out in Fourier space):
</p>

<ul class="org-ul">
<li>Let \(s_1 = b + a - N\) allowing <i>underflow</i> in case \(N>a+b\).</li>
<li>Detect underflow by inspecting the most significant bit.</li>
<li>If no underflow occurs \(s_1\) is already the result.</li>
<li>Otherwise if underflow occurs we must add back \(N\) and then \(s_2=s_1+N=a+b\) is the
result.</li>
</ul>

<p>
Note that the <code>CNOT</code> is responsible to write a <code>1</code> into the ancillary qubit iff underflow
occurs. The reason why the circuit looks more complicated is that we have to <i>uncompute</i>
everything written to the ancilla.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">modulus_size</span>(modulus: <span class="org-builtin">int</span>):
    <span class="org-keyword">return</span> (modulus <span class="org-operator">-</span> 1).bit_length()


<span class="org-keyword">def</span> <span class="org-function-name">make_modular_fourier_incrementer</span>(increment: <span class="org-builtin">int</span>, modulus: <span class="org-builtin">int</span>, num_ctrls: <span class="org-builtin">int</span><span class="org-operator">=</span>0) <span class="org-operator">-&gt;</span> Gate:
    <span class="org-doc">"""Implements |&#981;(j)&gt; -&gt; |&#981;(a+j mod N)&gt; where a is the increment and N the modulus.</span>

<span class="org-doc">    Args:</span>
<span class="org-doc">        increment: The fixed increment hardcoded into the circuit.</span>
<span class="org-doc">        modulus: The modulus hardcoded into the circuit.</span>
<span class="org-doc">        num_ctrls: This many control qubits are added before all other qubits.</span>

<span class="org-doc">    Note: The last wire is an ancillary qubit which needs to be initialized to |0&gt;.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">size</span> <span class="org-operator">=</span> modulus_size(modulus) <span class="org-operator">+</span> 1

    <span class="org-variable-name">qreg_ctrl</span> <span class="org-operator">=</span> QuantumRegister(num_ctrls, <span class="org-string">"c"</span>)
    <span class="org-variable-name">qreg</span> <span class="org-operator">=</span> QuantumRegister(size, <span class="org-string">"q"</span>)
    <span class="org-variable-name">qreg_anc</span> <span class="org-operator">=</span> QuantumRegister(1, <span class="org-string">"a"</span>)

    <span class="org-variable-name">qreg2</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>(qreg_ctrl) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg)

    <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(qreg_ctrl, qreg, qreg_anc)

    <span class="org-variable-name">inc_a</span> <span class="org-operator">=</span> FourierIncrementGate(size, increment)
    <span class="org-variable-name">cc_inc_a</span> <span class="org-operator">=</span> inc_a <span class="org-keyword">if</span> num_ctrls <span class="org-operator">==</span> 0 <span class="org-keyword">else</span> inc_a.control(num_ctrls)
    <span class="org-variable-name">inc_N</span> <span class="org-operator">=</span> FourierIncrementGate(size, modulus)
    <span class="org-variable-name">c_inc_N</span> <span class="org-operator">=</span> FourierIncrementGate(size, modulus).control(1)
    <span class="org-variable-name">cc_inc_a_dg</span> <span class="org-operator">=</span> cc_inc_a.inverse()
    <span class="org-variable-name">inc_N_dg</span> <span class="org-operator">=</span> inc_N.inverse()
    <span class="org-variable-name">qft</span> <span class="org-operator">=</span> make_qft(size)
    <span class="org-variable-name">qft_dg</span> <span class="org-operator">=</span> make_qft_dg(size)

    qc.append(cc_inc_a, qreg2)
    qc.append(inc_N_dg, qreg)

    qc.append(qft_dg, qreg)
    qc.cx(qreg[<span class="org-operator">-</span>1], qreg_anc[0])
    qc.append(qft, qreg)

    qc.append(c_inc_N, <span class="org-builtin">list</span>(qreg_anc) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg))
    qc.append(cc_inc_a_dg, qreg2)

    qc.append(qft_dg, qreg)
    qc.cx(qreg[<span class="org-operator">-</span>1], qreg_anc[0], ctrl_state<span class="org-operator">=</span>0)
    qc.append(qft, qreg)

    qc.append(cc_inc_a, qreg2)

    <span class="org-variable-name">prefix</span> <span class="org-operator">=</span> make_control_prefix(num_ctrls)
    <span class="org-keyword">return</span> qc.to_gate(label<span class="org-operator">=</span>f<span class="org-string">"</span>{prefix}<span class="org-string">&#981;inc(</span>{increment}<span class="org-string">)mod(</span>{modulus}<span class="org-string">)"</span>)


<span class="org-keyword">class</span> <span class="org-type">ModularFourierIncrementGate</span>(Gate):
    <span class="org-doc">"""Implements |&#981;(j)&gt; -&gt; |&#981;(a+j mod N)&gt;."""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, increment: <span class="org-builtin">int</span>, modulus: <span class="org-builtin">int</span>,
                 label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>):
        <span class="org-doc">"""Create a new modular Fourier incrementer gate.</span>

<span class="org-doc">        Args:</span>
<span class="org-doc">            increment: The increment 'a' hardcoded into the circuit.</span>
<span class="org-doc">            modulus: The modulus 'N' hardcoded into the circuit.</span>

<span class="org-doc">        Note: The last wire is an ancillary qubit which needs to be initialized to |0&gt;.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">num_qubits</span> <span class="org-operator">=</span> modulus_size(modulus) <span class="org-operator">+</span> 2
        <span class="org-builtin">super</span>().__init__(f<span class="org-string">"&#981;inc(</span>{increment}<span class="org-string">)mod(</span>{modulus}<span class="org-string">)"</span>, num_qubits, [], label<span class="org-operator">=</span>label)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_increment</span> <span class="org-operator">=</span> increment
        <span class="org-keyword">self</span>.<span class="org-variable-name">_modulus</span> <span class="org-operator">=</span> modulus

    <span class="org-keyword">def</span> <span class="org-function-name">_define</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_modular_fourier_incrementer(<span class="org-keyword">self</span>._increment, <span class="org-keyword">self</span>._modulus).definition
        <span class="org-keyword">self</span>.<span class="org-variable-name">definition</span> <span class="org-operator">=</span> qc

    <span class="org-keyword">def</span> <span class="org-function-name">control</span>(
            <span class="org-keyword">self</span>,
            num_ctrl_qubits: <span class="org-builtin">int</span> <span class="org-operator">=</span> 1,
            label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>,
            ctrl_state: Optional[Union[<span class="org-builtin">str</span>, <span class="org-builtin">int</span>]] <span class="org-operator">=</span> <span class="org-constant">None</span>,
    ):
        <span class="org-variable-name">gate</span> <span class="org-operator">=</span> MCModularFourierIncrementGate(
            <span class="org-keyword">self</span>._increment, <span class="org-keyword">self</span>._modulus, num_ctrl_qubits)
        gate.<span class="org-variable-name">base_label</span> <span class="org-operator">=</span> <span class="org-keyword">self</span>.label
        <span class="org-keyword">return</span> gate


<span class="org-keyword">class</span> <span class="org-type">MCModularFourierIncrementGate</span>(ControlledGate):
    <span class="org-doc">"""Implements controlled version of |&#981;(j)&gt; -&gt; |&#981;(a+j mod N)&gt;."""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(
            <span class="org-keyword">self</span>,
            increment: <span class="org-builtin">int</span>,
            modulus: <span class="org-builtin">int</span>,
            num_ctrl_qubits: <span class="org-builtin">int</span>,
            ctrl_state: Optional[Union[<span class="org-builtin">str</span>, <span class="org-builtin">int</span>]] <span class="org-operator">=</span> <span class="org-constant">None</span>,
            label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>):
        <span class="org-doc">"""Create a new modular Fourier incrementer gate.</span>

<span class="org-doc">        Args:</span>
<span class="org-doc">            increment: The increment 'a' hardcoded into the circuit.</span>
<span class="org-doc">            modulus: The modulus 'N' hardcoded into the circuit.</span>
<span class="org-doc">            num_ctrl_qubits: The number of controls added to the front.</span>

<span class="org-doc">        Note: The last wire is an ancillary qubit which needs to be initialized to |0&gt;.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">assert</span> ctrl_state <span class="org-keyword">is</span> <span class="org-constant">None</span>, <span class="org-string">"sorry ctrl_state not implemented"</span>
        <span class="org-builtin">super</span>().__init__(
            <span class="org-string">"mcfinc"</span>,
            num_ctrl_qubits <span class="org-operator">+</span> modulus_size(modulus) <span class="org-operator">+</span> 2,
            [],
            num_ctrl_qubits<span class="org-operator">=</span>num_ctrl_qubits,
            base_gate<span class="org-operator">=</span>ModularFourierIncrementGate(increment, modulus, label<span class="org-operator">=</span>label),
            label<span class="org-operator">=</span>label,
        )
        <span class="org-keyword">self</span>.<span class="org-variable-name">_increment</span> <span class="org-operator">=</span> increment
        <span class="org-keyword">self</span>.<span class="org-variable-name">_modulus</span> <span class="org-operator">=</span> modulus

    <span class="org-keyword">def</span> <span class="org-function-name">_define</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_modular_fourier_incrementer(
            <span class="org-keyword">self</span>._increment, <span class="org-keyword">self</span>._modulus, <span class="org-keyword">self</span>.num_ctrl_qubits).definition
        <span class="org-keyword">self</span>.<span class="org-variable-name">definition</span> <span class="org-operator">=</span> qc
</pre>
</div>

<p>
You may wonder why this function (and <code>make_fourier_incrementer</code>) takes an argument
<code>num_ctrls</code>. We could easily add controls by using the builtin <code>Gate.control</code> method. At
first I did it this way but it turned out that building the phase estimation circuit took
extremely long. Profiling with <a href="https://docs.python.org/3/library/profile.html">cProfile</a> revealed that around 95% of the time was spent
generating the controls. Hence I implemented it manually saving a lot of time. The main
reason why this worked is that - at the time of writing this - the <code>Gate.control</code> method
recursively adds controls to each gate contained in the circuit. But this is not necessary
for this circuit, instead it suffices to put the control at just the incrementer for \(a\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgeb3214d"><span class="org-variable-name">finc_mod</span> <span class="org-operator">=</span> make_modular_fourier_incrementer(3, 7)
finc_mod.definition.draw(fold<span class="org-operator">=</span>80)
</pre>
</div>

<pre class="example" id="org21643f0">
     ┌──────────┐┌─────────────┐┌────────┐     ┌──────┐┌──────────┐»
q_0: ┤0         ├┤0            ├┤0       ├─────┤0     ├┤0         ├»
     │          ││             ││        │     │      ││          │»
q_1: ┤1         ├┤1            ├┤1       ├─────┤1     ├┤1         ├»
     │  Φinc(3) ││  ϕinc(7)_dg ││  QFT^† │     │  QFT ││  Φinc(7) │»
q_2: ┤2         ├┤2            ├┤2       ├─────┤2     ├┤2         ├»
     │          ││             ││        │     │      ││          │»
q_3: ┤3         ├┤3            ├┤3       ├──■──┤3     ├┤3         ├»
     └──────────┘└─────────────┘└────────┘┌─┴─┐└──────┘└────┬─────┘»
q_4: ─────────────────────────────────────┤ X ├─────────────■──────»
                                          └───┘                    »
«     ┌─────────────┐┌────────┐     ┌──────┐┌──────────┐
«q_0: ┤0            ├┤0       ├─────┤0     ├┤0         ├
«     │             ││        │     │      ││          │
«q_1: ┤1            ├┤1       ├─────┤1     ├┤1         ├
«     │  ϕinc(3)_dg ││  QFT^† │     │  QFT ││  Φinc(3) │
«q_2: ┤2            ├┤2       ├─────┤2     ├┤2         ├
«     │             ││        │     │      ││          │
«q_3: ┤3            ├┤3       ├──o──┤3     ├┤3         ├
«     └─────────────┘└────────┘┌─┴─┐└──────┘└──────────┘
«q_4: ─────────────────────────┤ X ├────────────────────
«                              └───┘
</pre>

<p>
We implement the corresponding operation in real space to have something to test against:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">ModularIncrementGate</span>(Gate):
    <span class="org-doc">"""Implements |j&gt; -&gt; |a+j mod N&gt;."""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, increment: <span class="org-builtin">int</span>, modulus: <span class="org-builtin">int</span>,
                 label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>):
        <span class="org-doc">"""Create a new modular incrementer gate.</span>

<span class="org-doc">        Args:</span>
<span class="org-doc">            increment: The increment 'a' hardcoded into the circuit.</span>
<span class="org-doc">            modulus: The modulus 'N' hardcoded into the circuit.</span>

<span class="org-doc">        Note: The last wire is an ancillary qubit which needs to be initialized to |0&gt;.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">num_qubits</span> <span class="org-operator">=</span> modulus_size(modulus) <span class="org-operator">+</span> 2
        <span class="org-builtin">super</span>().__init__(f<span class="org-string">"inc(</span>{increment}<span class="org-string">)mod(</span>{modulus}<span class="org-string">)"</span>, num_qubits, [], label<span class="org-operator">=</span>label)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_increment</span> <span class="org-operator">=</span> increment
        <span class="org-keyword">self</span>.<span class="org-variable-name">_modulus</span> <span class="org-operator">=</span> modulus

    <span class="org-keyword">def</span> <span class="org-function-name">_define</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">mfinc</span> <span class="org-operator">=</span> ModularFourierIncrementGate(<span class="org-keyword">self</span>._increment, <span class="org-keyword">self</span>._modulus)

        <span class="org-variable-name">qreg_size</span> <span class="org-operator">=</span> mfinc.num_qubits <span class="org-operator">-</span> 1  <span class="org-comment-delimiter"># </span><span class="org-comment">one ancilla</span>

        <span class="org-variable-name">qft</span> <span class="org-operator">=</span> make_qft(qreg_size)
        <span class="org-variable-name">qft_dg</span> <span class="org-operator">=</span> make_qft_dg(qreg_size)

        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(qreg_size <span class="org-operator">+</span> 1)

        qc.append(qft, <span class="org-builtin">range</span>(qreg_size))
        qc.append(mfinc, <span class="org-builtin">range</span>(qreg_size <span class="org-operator">+</span> 1))
        qc.append(qft_dg, <span class="org-builtin">range</span>(qreg_size))

        <span class="org-keyword">self</span>.<span class="org-variable-name">definition</span> <span class="org-operator">=</span> qc
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">gate</span> <span class="org-operator">=</span> ModularIncrementGate(3, 7)
gate.definition.draw()
</pre>
</div>

<pre class="example" id="orgb2604c5">
     ┌──────┐┌────────────────┐┌────────┐
q_0: ┤0     ├┤0               ├┤0       ├
     │      ││                ││        │
q_1: ┤1     ├┤1               ├┤1       ├
     │  QFT ││                ││  QFT^† │
q_2: ┤2     ├┤2 Φinc(3)mod(7) ├┤2       ├
     │      ││                ││        │
q_3: ┤3     ├┤3               ├┤3       ├
     └──────┘│                │└────────┘
q_4: ────────┤4               ├──────────
             └────────────────┘
</pre>

<p>
This function can be used to test (manually or via CI) that the above implementations for
incrementation or modular incrementation works:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">quantum_add</span>(a: <span class="org-builtin">int</span>, b: <span class="org-builtin">int</span>, modulus: <span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-constant">None</span>, size: <span class="org-builtin">int</span> <span class="org-operator">=</span> <span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">int</span>:
    <span class="org-doc">"""Compute a + b or a + b mod modulus.</span>

<span class="org-doc">    Args:</span>
<span class="org-doc">        a,b: The two summands.</span>
<span class="org-doc">        size: The number of qubits to represent a and b. Ignored if modulus is given.</span>
<span class="org-doc">        modulus: Some number required to be larger than a and b.</span>

<span class="org-doc">    Note:</span>
<span class="org-doc">        Uses make_incrementer or make_modular_incrementer depending whether modulus is</span>
<span class="org-doc">        given or not.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">assert</span> a <span class="org-operator">&gt;=</span> 0 <span class="org-keyword">and</span> b <span class="org-operator">&gt;=</span> 0, <span class="org-string">"a and b must be positive"</span>

    <span class="org-keyword">if</span> modulus <span class="org-keyword">is</span> <span class="org-constant">None</span>:
        <span class="org-keyword">assert</span> size <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>, <span class="org-string">"Specify 'size'"</span>
        <span class="org-variable-name">inc</span> <span class="org-operator">=</span> IncrementGate(size, a)
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(size)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">assert</span> a <span class="org-operator">&lt;</span> modulus <span class="org-keyword">and</span> b <span class="org-operator">&lt;</span> modulus, <span class="org-string">"a and b must be smaller than modulus"</span>
        <span class="org-variable-name">inc</span> <span class="org-operator">=</span> ModularIncrementGate(a, modulus)
        <span class="org-variable-name">size</span> <span class="org-operator">=</span> inc.num_qubits
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(size)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Not nice but works: Implicitly treats ancilla for the modular case correctly.</span>
    qc.initialize(f<span class="org-string">"</span>{b:0{size}b}<span class="org-string">"</span>)
    qc.append(inc, <span class="org-builtin">range</span>(size))
    qc.measure_all()

    <span class="org-variable-name">sim</span> <span class="org-operator">=</span> AerSimulator()
    <span class="org-variable-name">qc_obj</span> <span class="org-operator">=</span> transpile(qc, sim)
    <span class="org-variable-name">counts</span> <span class="org-operator">=</span> sim.run(qc_obj).result().get_counts()

    <span class="org-variable-name">largest_count</span> <span class="org-operator">=</span> 0
    <span class="org-keyword">for</span> bits, count <span class="org-keyword">in</span> counts.items():
        <span class="org-keyword">if</span> count <span class="org-operator">&gt;</span> largest_count:
            <span class="org-variable-name">largest_count</span> <span class="org-operator">=</span> count
            <span class="org-variable-name">result</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(bits, base<span class="org-operator">=</span>2)

    <span class="org-keyword">return</span> result
</pre>
</div>
</div>
</div>

<div id="outline-container-org3f35fb0" class="outline-3">
<h3 id="org3f35fb0">Multiplication in Fourier Space</h3>
<div class="outline-text-3" id="text-org3f35fb0">
<p>
Next we implement
</p>

<p>
\[
  V(a,N): \quad \ket{x,b} \mapsto \ket{x, b + ax \mod N} .
\]
</p>

<p>
This is essentially the multiplication operation using an auxiliary register which serves
as the output register. The idea of the circuit is simple. It is based on the identity:
</p>

<p>
\[
  ax \mod N = \sum_{i=0}^n x_i(a\cdot 2^i) ,
\]
</p>

<p>
where \(n\) is the number of bits. The sum on the right can be implemented by a series of
\(n+1\) controlled (by the \(x_i\)) incrementation operations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">make_VaN</span>(a: <span class="org-builtin">int</span>, modulus: <span class="org-builtin">int</span>, num_ctrls: <span class="org-builtin">int</span> <span class="org-operator">=</span> 0, fast_mode<span class="org-operator">=</span><span class="org-constant">True</span>) <span class="org-operator">-&gt;</span> Gate:
    <span class="org-doc">"""Implements |x,b&gt; -&gt; |x,b+ax mod N&gt;.</span>

<span class="org-doc">    Args:</span>
<span class="org-doc">        fast_mode: Usage of ModularFourierIncrementGate slows down everything dramatically,</span>
<span class="org-doc">            use make_modular_fourier_incrementer directly in case of fast_mode=True.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">int_size</span> <span class="org-operator">=</span> modulus_size(modulus) <span class="org-operator">+</span> 1

    <span class="org-variable-name">qreg_ctrl</span> <span class="org-operator">=</span> QuantumRegister(num_ctrls, <span class="org-string">"c"</span>)
    <span class="org-variable-name">qreg_x</span> <span class="org-operator">=</span> QuantumRegister(int_size, <span class="org-string">"x"</span>)
    <span class="org-variable-name">qreg_b</span> <span class="org-operator">=</span> QuantumRegister(int_size, <span class="org-string">"b"</span>)
    <span class="org-variable-name">qreg_anc</span> <span class="org-operator">=</span> AncillaRegister(1, <span class="org-string">"a"</span>)

    <span class="org-variable-name">qft</span> <span class="org-operator">=</span> make_qft(int_size) <span class="org-keyword">if</span> num_ctrls <span class="org-operator">==</span> 0 <span class="org-keyword">else</span> make_qft(int_size).control(num_ctrls)
    <span class="org-variable-name">qft_dg</span> <span class="org-operator">=</span> make_qft_dg(int_size) <span class="org-keyword">if</span> num_ctrls <span class="org-operator">==</span> 0 <span class="org-keyword">else</span> make_qft_dg(int_size).control(num_ctrls)

    <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(qreg_ctrl, qreg_x, qreg_b, qreg_anc)

    qc.append(qft, <span class="org-builtin">list</span>(qreg_ctrl) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_b))

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(int_size <span class="org-operator">-</span> 1):
        <span class="org-variable-name">ai</span> <span class="org-operator">=</span> a <span class="org-operator">*</span> 2<span class="org-operator">**</span>i <span class="org-operator">%</span> modulus

        <span class="org-keyword">if</span> fast_mode:
            <span class="org-variable-name">cfinc</span> <span class="org-operator">=</span> make_modular_fourier_incrementer(ai, modulus, num_ctrls<span class="org-operator">=</span>num_ctrls <span class="org-operator">+</span> 1)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">cfinc</span> <span class="org-operator">=</span> ModularFourierIncrementGate(ai, modulus).control(num_ctrls <span class="org-operator">+</span> 1)

        qc.append(cfinc, <span class="org-builtin">list</span>(qreg_ctrl) <span class="org-operator">+</span> [qreg_x[i]] <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_b) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_anc))

    qc.append(qft_dg, <span class="org-builtin">list</span>(qreg_ctrl) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_b))

    <span class="org-variable-name">prefix</span> <span class="org-operator">=</span> make_control_prefix(num_ctrls)
    <span class="org-keyword">return</span> qc.to_gate(label<span class="org-operator">=</span>f<span class="org-string">"</span>{prefix}<span class="org-string">(b + </span>{a}<span class="org-string">x mod </span>{modulus}<span class="org-string">)"</span>)
</pre>
</div>

<p>
As an example, here is a circuit which multiplies the input by <code>3</code> modulo <code>11</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">gate</span> <span class="org-operator">=</span> make_VaN(3, 11, fast_mode<span class="org-operator">=</span><span class="org-constant">False</span>)  <span class="org-comment-delimiter"># </span><span class="org-comment">Nicer picture without fast_mode - sorry</span>
gate.definition.draw()
</pre>
</div>

<pre class="example" id="org979edd2">

 q_0: ─────────────────■────────────────────────────────────────────────────────────────────────────
                       │
 q_1: ─────────────────┼──────────────────■─────────────────────────────────────────────────────────
                       │                  │
 q_2: ─────────────────┼──────────────────┼──────────────────■──────────────────────────────────────
                       │                  │                  │
 q_3: ─────────────────┼──────────────────┼──────────────────┼──────────────────■───────────────────
                       │                  │                  │                  │
 q_4: ─────────────────┼──────────────────┼──────────────────┼──────────────────┼───────────────────
      ┌──────┐┌────────┴────────┐┌────────┴────────┐┌────────┴────────┐┌────────┴────────┐┌────────┐
 q_5: ┤0     ├┤0                ├┤0                ├┤0                ├┤0                ├┤0       ├
      │      ││                 ││                 ││                 ││                 ││        │
 q_6: ┤1     ├┤1                ├┤1                ├┤1                ├┤1                ├┤1       ├
      │      ││                 ││                 ││                 ││                 ││        │
 q_7: ┤2 QFT ├┤2                ├┤2                ├┤2                ├┤2                ├┤2 QFT^† ├
      │      ││  Φinc(3)mod(11) ││  Φinc(6)mod(11) ││  Φinc(1)mod(11) ││  Φinc(2)mod(11) ││        │
 q_8: ┤3     ├┤3                ├┤3                ├┤3                ├┤3                ├┤3       ├
      │      ││                 ││                 ││                 ││                 ││        │
 q_9: ┤4     ├┤4                ├┤4                ├┤4                ├┤4                ├┤4       ├
      └──────┘│                 ││                 ││                 ││                 │└────────┘
q_10: ────────┤5                ├┤5                ├┤5                ├┤5                ├──────────
              └─────────────────┘└─────────────────┘└─────────────────┘└─────────────────┘
</pre>

<p>
Finally we arrive at the circuit we actually care for:
</p>

<p>
\[
  U(a,N): \ket{x} \mapsto \ket{ax \mod N}  .
\]
</p>

<p>
The circuit works by first calculating the result using \(V(a,N)\). In the second step the
result is moved into the input register utilizing swap gates. Finally, in the third step,
we need to uncompute garbage, what can be done by \(V(a^{-1},N)^\dagger\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">make_UaN</span>(a: <span class="org-builtin">int</span>, modulus: <span class="org-builtin">int</span>, num_ctrls: <span class="org-builtin">int</span> <span class="org-operator">=</span> 0) <span class="org-operator">-&gt;</span> Gate:
    <span class="org-doc">"""Implements |x&gt; -&gt; |ax mod N&gt;."""</span>
    <span class="org-variable-name">L</span> <span class="org-operator">=</span> modulus_size(modulus) <span class="org-operator">+</span> 1

    <span class="org-variable-name">qreg_ctrl</span> <span class="org-operator">=</span> QuantumRegister(num_ctrls, <span class="org-string">"c"</span>)
    <span class="org-variable-name">qreg</span> <span class="org-operator">=</span> QuantumRegister(L, <span class="org-string">"q"</span>)
    <span class="org-variable-name">qreg_anc</span> <span class="org-operator">=</span> AncillaRegister(L <span class="org-operator">+</span> 1, <span class="org-string">"a"</span>)

    <span class="org-variable-name">VaN</span> <span class="org-operator">=</span> make_VaN(a, modulus, num_ctrls)
    <span class="org-variable-name">Va1N</span> <span class="org-operator">=</span> make_VaN(<span class="org-builtin">pow</span>(a, <span class="org-operator">-</span>1, modulus), modulus, num_ctrls)
    <span class="org-variable-name">Va1N_dg</span> <span class="org-operator">=</span> Va1N.definition.inverse().to_gate(label<span class="org-operator">=</span>f<span class="org-string">"</span>{Va1N.label}<span class="org-string">^&#8224;"</span>)

    <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(qreg_ctrl, qreg, qreg_anc)

    qc.append(VaN, <span class="org-builtin">list</span>(qreg_ctrl) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_anc))

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(qreg.size <span class="org-operator">-</span> 1):  <span class="org-comment-delimiter"># </span><span class="org-comment">last bit just for overflow</span>
        <span class="org-variable-name">swap</span> <span class="org-operator">=</span> SwapGate() <span class="org-keyword">if</span> num_ctrls <span class="org-operator">==</span> 0 <span class="org-keyword">else</span> SwapGate().control(num_ctrls)
        qc.append(swap, <span class="org-builtin">list</span>(qreg_ctrl) <span class="org-operator">+</span> [qreg[i], qreg_anc[i]])

    qc.append(Va1N_dg, <span class="org-builtin">list</span>(qreg_ctrl) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_anc))

    <span class="org-comment-delimiter"># </span><span class="org-comment">FIXME: for some weird reason I *must* convert this to_gate here (and convert it back during</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">usage) to make the transpile step work.</span>
    <span class="org-keyword">return</span> qc.to_gate()


<span class="org-keyword">class</span> <span class="org-type">UaNGate</span>(Gate):
    <span class="org-doc">"""Implements |x&gt; -&gt; |ax mod N&gt;."""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(
            <span class="org-keyword">self</span>, a: <span class="org-builtin">int</span>,
            modulus: <span class="org-builtin">int</span>,
            label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>,
    ):
        <span class="org-doc">"""Create a new U(a, N) gate."""</span>
        <span class="org-variable-name">L</span> <span class="org-operator">=</span> modulus_size(modulus) <span class="org-operator">+</span> 1
        <span class="org-variable-name">num_qubits</span> <span class="org-operator">=</span> 2<span class="org-operator">*</span>L <span class="org-operator">+</span> 1
        <span class="org-builtin">super</span>().__init__(
            f<span class="org-string">"</span>{a}<span class="org-string">x mod </span>{modulus}<span class="org-string">"</span>,
            num_qubits,
            [],
            label<span class="org-operator">=</span>label,
        )
        <span class="org-keyword">self</span>.<span class="org-variable-name">_increment</span> <span class="org-operator">=</span> a
        <span class="org-keyword">self</span>.<span class="org-variable-name">_modulus</span> <span class="org-operator">=</span> modulus

    <span class="org-keyword">def</span> <span class="org-function-name">_define</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_UaN(<span class="org-keyword">self</span>._increment, <span class="org-keyword">self</span>._modulus).definition
        <span class="org-keyword">self</span>.<span class="org-variable-name">definition</span> <span class="org-operator">=</span> qc


<span class="org-keyword">class</span> <span class="org-type">MCUaNGate</span>(ControlledGate):
    <span class="org-doc">"""Implements controlled version of |x&gt; -&gt; |ax mod N&gt;."""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(
            <span class="org-keyword">self</span>, a: <span class="org-builtin">int</span>,
            modulus: <span class="org-builtin">int</span>,
            num_ctrl_qubits: <span class="org-builtin">int</span>,
            ctrl_state: Optional[Union[<span class="org-builtin">str</span>, <span class="org-builtin">int</span>]] <span class="org-operator">=</span> <span class="org-constant">None</span>,
            label: Optional[<span class="org-builtin">str</span>] <span class="org-operator">=</span> <span class="org-constant">None</span>,
    ):
        <span class="org-doc">"""Create a new CU(a, N) gate."""</span>
        <span class="org-keyword">assert</span> ctrl_state <span class="org-keyword">is</span> <span class="org-constant">None</span>, <span class="org-string">"sorry ctrl_state not implemented"</span>
        <span class="org-variable-name">L</span> <span class="org-operator">=</span> modulus_size(modulus) <span class="org-operator">+</span> 1
        <span class="org-variable-name">num_qubits</span> <span class="org-operator">=</span> 2<span class="org-operator">*</span>L <span class="org-operator">+</span> 1
        <span class="org-builtin">super</span>().__init__(
            f<span class="org-string">"mcuan"</span>,
            num_qubits <span class="org-operator">+</span> num_ctrl_qubits,
            [],
            num_ctrl_qubits<span class="org-operator">=</span>num_ctrl_qubits,
            label<span class="org-operator">=</span>label,
            base_gate<span class="org-operator">=</span>UaNGate(a, modulus),
        )
        <span class="org-keyword">self</span>.<span class="org-variable-name">_increment</span> <span class="org-operator">=</span> a
        <span class="org-keyword">self</span>.<span class="org-variable-name">_modulus</span> <span class="org-operator">=</span> modulus

    <span class="org-keyword">def</span> <span class="org-function-name">_define</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_UaN(<span class="org-keyword">self</span>._increment, <span class="org-keyword">self</span>._modulus, num_ctrls<span class="org-operator">=</span><span class="org-keyword">self</span>.num_ctrl_qubits).definition
        <span class="org-keyword">self</span>.<span class="org-variable-name">definition</span> <span class="org-operator">=</span> qc
</pre>
</div>

<p>
This is how looks like for \(a=3\) and modulus \(7\):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">Ua</span> <span class="org-operator">=</span> UaNGate(3, 11)
Ua.definition.draw()
</pre>
</div>

<pre class="example" id="orgbd7cb45">
      ┌───────────────────┐            ┌─────────────────────┐
 q_0: ┤0                  ├─X──────────┤0                    ├
      │                   │ │          │                     │
 q_1: ┤1                  ├─┼──X───────┤1                    ├
      │                   │ │  │       │                     │
 q_2: ┤2                  ├─┼──┼──X────┤2                    ├
      │                   │ │  │  │    │                     │
 q_3: ┤3                  ├─┼──┼──┼──X─┤3                    ├
      │                   │ │  │  │  │ │                     │
 q_4: ┤4                  ├─┼──┼──┼──┼─┤4                    ├
      │                   │ │  │  │  │ │                     │
 q_5: ┤5  (b + 3x mod 11) ├─X──┼──┼──┼─┤5  (b + 4x mod 11)^† ├
      │                   │    │  │  │ │                     │
 q_6: ┤6                  ├────X──┼──┼─┤6                    ├
      │                   │       │  │ │                     │
 q_7: ┤7                  ├───────X──┼─┤7                    ├
      │                   │          │ │                     │
 q_8: ┤8                  ├──────────X─┤8                    ├
      │                   │            │                     │
 q_9: ┤9                  ├────────────┤9                    ├
      │                   │            │                     │
q_10: ┤10                 ├────────────┤10                   ├
      └───────────────────┘            └─────────────────────┘
</pre>

<p>
Note that three bits are sufficient to represent the number \(7\). That explains why three
swap gates are used.
</p>
</div>
</div>

<div id="outline-container-org826641a" class="outline-3">
<h3 id="org826641a">Order Finding</h3>
<div class="outline-text-3" id="text-org826641a">
<p>
In this section I want to fill a (tiny) gap in the algorithm for order finding (section
5.3.1).
</p>

<p>
Recall that after executing the phase estimation routine we obtain an \(2L+1\) bit number
\(\varphi\). If we are not too unlucky it equals <i>approximately</i> \(s/r\) for a non-zero \(z\). The
error is given by the number of bits used (\(2L+1\)). From a <a href="continued_fractions.html#6c146ca8-7130-4b91-9e06-983fcbf6143e">sufficient criterion to be a
convergent</a> it is deduced that \(s/r\) must be a convergent of \(\varphi\).
</p>

<p>
So far so good. But which of the convergents \(p_n/q_n\) is the right one? The book does not
really tell us. What we know is that \(q_n < N\). It would be convenient if it is the last
convergent with this property. <b>We prove that this is indeed true</b>. But first let us see
why this is a non-trivial fact.
</p>
</div>

<div id="outline-container-orgf388620" class="outline-4">
<h4 id="orgf388620">What is the issue?</h4>
<div class="outline-text-4" id="text-orgf388620">
<p>
To <i>illustrate</i> the problem assume that \(N\) is very large, say a number which needs
\(L=100\) bits. Moreover assume that the order \(r\) is very small, say \(r=3\). Assume \(s=1\)
and observe that \(s/r\) cannot be exactly represented in binary. Ask <code>python</code> what it
<i>thinks</i> the best rational approxmation to \(1/3\) is:
</p>

<div class="org-src-container">
<pre class="src src-python">Fraction(1<span class="org-operator">/</span>3)
</pre>
</div>

<pre class="example">
6004799503160661/18014398509481984
</pre>


<p>
Might we be at risk to deduce that the order is <code>18014398509481984</code>?
</p>

<p>
The reason for this large denominator is that \(1/3\) is represented by a <code>double</code> precision
data type which by the <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE standard</a> has <code>52</code> bits available for the fractional part. Also
note that \(1/3\) is slightly less than \(2^{-1}\). Hence one might suspect that the double
precision representation of \(\frac{1}{3}\) starts to show its lack of exactness at a
denominator size of roughly \(2^{53}\). In fact, this is what happens:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-builtin">print</span>(Fraction(1<span class="org-operator">/</span>3).limit_denominator(2<span class="org-operator">**</span>53))
<span class="org-builtin">print</span>(Fraction(1<span class="org-operator">/</span>3).limit_denominator(2<span class="org-operator">**</span>54))
</pre>
</div>

<pre class="example">
1/3
6004799503160661/18014398509481984
</pre>


<p>
Unsurprisingly the denominator is a power of two:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">assert</span> 18014398509481984 <span class="org-operator">==</span> 2<span class="org-operator">**</span>54
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
PASSED
</pre>
</div>
</div>

<div id="outline-container-orgc31a25c" class="outline-4">
<h4 id="orgc31a25c">A lemma resolving the issue</h4>
<div class="outline-text-4" id="text-orgc31a25c">
<p>
Let us show that the correct convergent \(p_n/q_n\) is indeed the one with maximal \(q_n\)
which still satisfies \(q_n < N\). First let us show an important Lemma:
</p>

<p>
Let \(s < r < N\) be non-negative integers and \(\varphi\in[0,1)\) real. Assume
</p>

<p>
<a id="org04d7a65"></a>
\[
  \abs{\varphi - \frac{s}{r}} \leq \frac{1}{2 N^2} .
\]
</p>

<p>
Then \(s/r\) is a convergent of \(\varphi\) and the next convergent has a denominator which is
larger than \(N\).
</p>

<p>
Once this is established recall that \(N\) is an \(L\) bit integer and \(\varphi\) is precise up
to \(2L+1\) bits. This implies that the premise of the lemma is satisfied and shows the
claim. It is left to prove the Lemma.
</p>

<dl class="org-dl">
<dt>Remarks</dt><dd><ul class="org-ul">
<li>Originally I had only the second proof which occured to me naturally while diving (a
little bit) into the <a href="continued_fractions.html">theory of continued fractions</a>. After a discussion with
<a href="https://github.com/jacobwatkins1">Jacob Watkins</a>, rooted in <a href="https://quantumcomputing.stackexchange.com/questions/16666/continued-fractions-with-shors-algorithm-which-convergent">this StackExchange question</a> we found out that one can do a
very simple elementary proof if the fact that convergents strictly monotonically
decrease their distance to the their limit is taken for granted (so it is a black-box
proof in a sense 😄). Interestingly the latter can be proved by the methods used in
the second proof. For this reason I let the second proof stay here.</li>
<li>The first proof also shows that \(s/r\) is not only the last convergent. It is even the
last <i>best approximation</i> of \(\varphi\) with a denominator smaller than \(N\). A <i>best
approximation</i> (of some target number) is a rational \(p/q\) for which no other
rational \(p'/q'\) with \(q'\leq q\) exists which is at least equally close to the target.
This justifies that <code class="src src-python">Fraction(&#981;).limit_denominator(N)</code> can be used to find
\(s/r\) in the phase estimation problem for order finding.</li>
<li>That \(s/r\) is a convergent follows from the <a href="continued_fractions.html#6c146ca8-7130-4b91-9e06-983fcbf6143e">sufficient criterion</a> to be a convergent
together with \(r < N\). For this reason the proofs concentrate on the second part of
the theorem.</li>
</ul></dd>
</dl>

<p>
PROOF 1: We will show that \(r/s\) is the only rational number with a denominator smaller
than \(N\) which satisfies the <a href="#org04d7a65">above inequality</a>. Let \(p/q\) be another such number with \(q <
N\). By the triangle inequality we have
</p>

<p>
\[
  \abs{\frac{p}{q} - \frac{s}{r}} \leq \frac{1}{N^2} .
\]
</p>

<p>
Since \(r,q < N\), this implies
</p>

<p>
\[
  \abs{pr - sq} \leq \frac{rq}{N^2} < 1.
\]
</p>

<p>
Hence \(pr=sq\). In other words \(p/q=s/r\) (but not necessarily \(p=s\) and \(q=s\) which is only
the case under coprimness assumption). Hence \(s/r\) is the only rational <a href="#org04d7a65">this close</a> to
\(\varphi\) with denominator being smaller than \(N\). Since each convergent is strictly
closer to \(\varphi\) than the previous one (<a href="continued_fractions.html#error-estimate-section">see here</a>) the claim is proved. QED.
</p>

<p>
PROOF 2: Let us write \(s/r=p_n/q_n\) with coprime nominator and denominator. By the <a href="continued_fractions.html#orge798209">error
formula</a> for convergents and the <a href="continued_fractions.html#org272dda0">recursion formula</a> for \(p_n\) and \(q_n\) we have:
</p>

<p>
\[
  q_n (q_{n+1} + q_n/z_{n+2}) = q_n (z_{n+1} q_n + q_{n-1}) \geq 2 N^2 .
\]
</p>

<p>
Since \(q_n < N\), \(q_n < q_{n+1}\), and \(z_i\geq 1\) we deduce \(q_{n+1}>N\). QED.
</p>
</div>
</div>

<div id="outline-container-org8988433" class="outline-4">
<h4 id="org8988433">Implementation</h4>
<div class="outline-text-4" id="text-org8988433">
<p>
Next we implement phase estimation for order finding, following the book.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">eps_bits</span>(eps: <span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">int</span>:
    <span class="org-doc">"""Number of additional qubits required to guarantee a success</span>
<span class="org-doc">    probability of at least 1-eps (theoretically). See Chapter 5.2.1."""</span>
    <span class="org-keyword">assert</span> eps <span class="org-operator">&gt;</span> 0, <span class="org-string">"eps must be strictly positive."</span>
    <span class="org-keyword">return</span> math.ceil(math.log(2.0 <span class="org-operator">+</span> 0.5<span class="org-operator">/</span>eps))


<span class="org-keyword">def</span> <span class="org-function-name">make_order_finding_phase_estimation</span>(a: <span class="org-builtin">int</span>, modulus: <span class="org-builtin">int</span>, eps: <span class="org-builtin">float</span>) <span class="org-operator">-&gt;</span> QuantumCircuit:
    <span class="org-doc">"""Make a phase estimation circuit to find the order of 'a'."""</span>
    <span class="org-variable-name">L</span> <span class="org-operator">=</span> modulus_size(modulus)
    <span class="org-variable-name">t</span> <span class="org-operator">=</span> 2<span class="org-operator">*</span>L <span class="org-operator">+</span> 1 <span class="org-operator">+</span> eps_bits(eps)

    <span class="org-variable-name">qreg_top</span> <span class="org-operator">=</span> QuantumRegister(t, <span class="org-string">"t"</span>)
    <span class="org-variable-name">qreg_bot</span> <span class="org-operator">=</span> QuantumRegister(L <span class="org-operator">+</span> 1, <span class="org-string">"u"</span>)  <span class="org-comment-delimiter"># </span><span class="org-comment">one qubit for overflow</span>
    <span class="org-variable-name">qreg_anc</span> <span class="org-operator">=</span> AncillaRegister(L <span class="org-operator">+</span> 2, <span class="org-string">"a"</span>)
    <span class="org-variable-name">creg</span> <span class="org-operator">=</span> ClassicalRegister(t, <span class="org-string">"c"</span>)

    <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(qreg_top, qreg_bot, qreg_anc, creg)

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(t):
        qc.h(qreg_top[i])

    qc.x(qreg_bot[0])

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(t):
        <span class="org-variable-name">CUai</span> <span class="org-operator">=</span> MCUaNGate(<span class="org-builtin">pow</span>(a, 2<span class="org-operator">**</span>i, modulus), modulus, num_ctrl_qubits<span class="org-operator">=</span>1)
        qc.append(CUai, [qreg_top[i]] <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_bot) <span class="org-operator">+</span> <span class="org-builtin">list</span>(qreg_anc))
        <span class="org-keyword">pass</span>

    <span class="org-variable-name">qft_dg</span> <span class="org-operator">=</span> make_qft_dg(t)
    qc.append(qft_dg, qreg_top)

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(t):
        qc.measure(qreg_top[i], creg[i])

    <span class="org-keyword">return</span> qc
</pre>
</div>

<p>
The following example shows the circuit is already relatively big for very small
parameters.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_order_finding_phase_estimation(3, 7, eps<span class="org-operator">=</span>0.5)
qc.draw(fold<span class="org-operator">=</span>90)
</pre>
</div>

<pre class="example" id="org51dcd7b">
     ┌───┐                                                                              »
t_0: ┤ H ├──────■───────────────────────────────────────────────────────────────────────»
     ├───┤      │                                                                       »
t_1: ┤ H ├──────┼────────────■──────────────────────────────────────────────────────────»
     ├───┤      │            │                                                          »
t_2: ┤ H ├──────┼────────────┼────────────■─────────────────────────────────────────────»
     ├───┤      │            │            │                                             »
t_3: ┤ H ├──────┼────────────┼────────────┼────────────■────────────────────────────────»
     ├───┤      │            │            │            │                                »
t_4: ┤ H ├──────┼────────────┼────────────┼────────────┼────────────■───────────────────»
     ├───┤      │            │            │            │            │                   »
t_5: ┤ H ├──────┼────────────┼────────────┼────────────┼────────────┼────────────■──────»
     ├───┤      │            │            │            │            │            │      »
t_6: ┤ H ├──────┼────────────┼────────────┼────────────┼────────────┼────────────┼──────»
     ├───┤      │            │            │            │            │            │      »
t_7: ┤ H ├──────┼────────────┼────────────┼────────────┼────────────┼────────────┼──────»
     ├───┤      │            │            │            │            │            │      »
t_8: ┤ H ├──────┼────────────┼────────────┼────────────┼────────────┼────────────┼──────»
     ├───┤┌─────┴─────┐┌─────┴─────┐┌─────┴─────┐┌─────┴─────┐┌─────┴─────┐┌─────┴─────┐»
u_0: ┤ X ├┤0          ├┤0          ├┤0          ├┤0          ├┤0          ├┤0          ├»
     └───┘│           ││           ││           ││           ││           ││           │»
u_1: ─────┤1          ├┤1          ├┤1          ├┤1          ├┤1          ├┤1          ├»
          │           ││           ││           ││           ││           ││           │»
u_2: ─────┤2          ├┤2          ├┤2          ├┤2          ├┤2          ├┤2          ├»
          │           ││           ││           ││           ││           ││           │»
u_3: ─────┤3          ├┤3          ├┤3          ├┤3          ├┤3          ├┤3          ├»
          │           ││           ││           ││           ││           ││           │»
a_0: ─────┤4 3x mod 7 ├┤4 2x mod 7 ├┤4 4x mod 7 ├┤4 2x mod 7 ├┤4 4x mod 7 ├┤4 2x mod 7 ├»
          │           ││           ││           ││           ││           ││           │»
a_1: ─────┤5          ├┤5          ├┤5          ├┤5          ├┤5          ├┤5          ├»
          │           ││           ││           ││           ││           ││           │»
a_2: ─────┤6          ├┤6          ├┤6          ├┤6          ├┤6          ├┤6          ├»
          │           ││           ││           ││           ││           ││           │»
a_3: ─────┤7          ├┤7          ├┤7          ├┤7          ├┤7          ├┤7          ├»
          │           ││           ││           ││           ││           ││           │»
a_4: ─────┤8          ├┤8          ├┤8          ├┤8          ├┤8          ├┤8          ├»
          └───────────┘└───────────┘└───────────┘└───────────┘└───────────┘└───────────┘»
c: 9/═══════════════════════════════════════════════════════════════════════════════════»
                                                                                        »
«                                            ┌────────┐┌─┐
«t_0: ───────────────────────────────────────┤0       ├┤M├────────────────────────
«                                            │        │└╥┘┌─┐
«t_1: ───────────────────────────────────────┤1       ├─╫─┤M├─────────────────────
«                                            │        │ ║ └╥┘┌─┐
«t_2: ───────────────────────────────────────┤2       ├─╫──╫─┤M├──────────────────
«                                            │        │ ║  ║ └╥┘┌─┐
«t_3: ───────────────────────────────────────┤3       ├─╫──╫──╫─┤M├───────────────
«                                            │        │ ║  ║  ║ └╥┘┌─┐
«t_4: ───────────────────────────────────────┤4 QFT^† ├─╫──╫──╫──╫─┤M├────────────
«                                            │        │ ║  ║  ║  ║ └╥┘┌─┐
«t_5: ───────────────────────────────────────┤5       ├─╫──╫──╫──╫──╫─┤M├─────────
«                                            │        │ ║  ║  ║  ║  ║ └╥┘┌─┐
«t_6: ──────■────────────────────────────────┤6       ├─╫──╫──╫──╫──╫──╫─┤M├──────
«           │                                │        │ ║  ║  ║  ║  ║  ║ └╥┘┌─┐
«t_7: ──────┼────────────■───────────────────┤7       ├─╫──╫──╫──╫──╫──╫──╫─┤M├───
«           │            │                   │        │ ║  ║  ║  ║  ║  ║  ║ └╥┘┌─┐
«t_8: ──────┼────────────┼────────────■──────┤8       ├─╫──╫──╫──╫──╫──╫──╫──╫─┤M├
«     ┌─────┴─────┐┌─────┴─────┐┌─────┴─────┐└────────┘ ║  ║  ║  ║  ║  ║  ║  ║ └╥┘
«u_0: ┤0          ├┤0          ├┤0          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«u_1: ┤1          ├┤1          ├┤1          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«u_2: ┤2          ├┤2          ├┤2          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«u_3: ┤3          ├┤3          ├┤3          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«a_0: ┤4 4x mod 7 ├┤4 2x mod 7 ├┤4 4x mod 7 ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«a_1: ┤5          ├┤5          ├┤5          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«a_2: ┤6          ├┤6          ├┤6          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«a_3: ┤7          ├┤7          ├┤7          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     │           ││           ││           │           ║  ║  ║  ║  ║  ║  ║  ║  ║
«a_4: ┤8          ├┤8          ├┤8          ├───────────╫──╫──╫──╫──╫──╫──╫──╫──╫─
«     └───────────┘└───────────┘└───────────┘           ║  ║  ║  ║  ║  ║  ║  ║  ║
«c: 9/══════════════════════════════════════════════════╩══╩══╩══╩══╩══╩══╩══╩══╩═
«                                                       0  1  2  3  4  5  6  7  8
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3b0684" class="outline-3">
<h3 id="orge3b0684">Factoring</h3>
<div class="outline-text-3" id="text-orge3b0684">
<p>
Recall that the factoring problem is to find a non-trivial factor of a given number
\(N\). We may assume that the number is not a prime number (as satisfied when our task is to
break RSA encryption). The quantum stuff needed to solve the factoring problem is
essentially in place.
</p>

<p>
But remember that the quantum part assumes that \(N\) is neither even nor a power of a prime
(compare e.g. with the assumptions of Theorem A4.13 in the book). Fortunately these corner
cases are easily solved classically. Below I give a very simple solution which is probably
far from optimal but which already suffices to show that the corner case is efficiently
solvable.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orga5ed183"><span class="org-keyword">def</span> <span class="org-function-name">is_even</span>(N: <span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">bool</span>:
    <span class="org-keyword">return</span> N <span class="org-operator">%</span> 2 <span class="org-operator">==</span> 0


<span class="org-keyword">def</span> <span class="org-function-name">intlogx</span>(N: <span class="org-builtin">int</span>, base: <span class="org-builtin">int</span>, offset<span class="org-operator">=</span>0, exponent<span class="org-operator">=</span>1) <span class="org-operator">-&gt;</span> <span class="org-builtin">int</span>:
    <span class="org-doc">"""Largest n such that (offset + base**n)**exponent &lt;= N</span>

<span class="org-doc">    For offset=0 and exponent=1 this is just floor(log_base(x))."""</span>
    <span class="org-keyword">assert</span> 1 <span class="org-operator">&lt;</span> base <span class="org-operator">&lt;</span> N

    <span class="org-variable-name">n</span> <span class="org-operator">=</span> 1
    <span class="org-variable-name">a</span> <span class="org-operator">=</span> base
    <span class="org-keyword">while</span> (value :<span class="org-operator">=</span> (offset <span class="org-operator">+</span> a)<span class="org-operator">**</span>exponent) <span class="org-operator">&lt;</span> N:
        <span class="org-variable-name">a</span> <span class="org-operator">*=</span> base
        <span class="org-variable-name">n</span> <span class="org-operator">+=</span> 1

    <span class="org-keyword">return</span> n <span class="org-keyword">if</span> value <span class="org-operator">==</span> N <span class="org-keyword">else</span> n <span class="org-operator">-</span> 1


<span class="org-keyword">def</span> <span class="org-function-name">is_power</span>(N: <span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">int</span>:
    <span class="org-doc">"""Decide whether there is x, k &gt; 1 such that x**k = N.</span>

<span class="org-doc">    Returns: None if not, and *a* pair (x, k) as above otherwise."""</span>
    <span class="org-variable-name">k2</span> <span class="org-operator">=</span> intlogx(N, 2)

    <span class="org-comment-delimiter"># </span><span class="org-comment">For each k &lt;= k2 check if there is an x with x**k == N</span>
    <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(2, k2 <span class="org-operator">+</span> 1):
        <span class="org-variable-name">x</span> <span class="org-operator">=</span> 0
        <span class="org-comment-delimiter"># </span><span class="org-comment">This loop constructs the binary representation of the largest x with x**k &lt;= N. Each</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">iteration finds the next non-zero digit of x.</span>
        <span class="org-keyword">while</span> x<span class="org-operator">**</span>k <span class="org-operator">&lt;</span> N:
            <span class="org-variable-name">i</span> <span class="org-operator">=</span> intlogx(N, 2, offset<span class="org-operator">=</span>x, exponent<span class="org-operator">=</span>k)
            <span class="org-variable-name">x</span> <span class="org-operator">+=</span> 2<span class="org-operator">**</span>i

        <span class="org-keyword">if</span> x<span class="org-operator">**</span>k <span class="org-operator">==</span> N:
            <span class="org-keyword">return</span> x, k

    <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>

<p>
The following example gives a hint that the code implementing <code>is_power</code> isn't too bad
(see the tests in the repo form more examples):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">We use primes to make the exponent unique:</span>
<span class="org-variable-name">a_1000_bit_number</span> <span class="org-operator">=</span> 699093205353077798740186149229 <span class="org-operator">**</span> 11
is_power(a_1000_bit_number)  <span class="org-comment-delimiter"># </span><span class="org-comment">executes in a few dozen milliseconds on a modern laptop</span>
</pre>
</div>

<pre class="example">
(699093205353077798740186149229, 11)
</pre>


<p>
Finally we implement the function <code>find_factor</code> which solves the factoring problem:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">get_maximizing_keys</span>(counts: <span class="org-builtin">dict</span>[<span class="org-builtin">str</span>, <span class="org-builtin">int</span>], num: <span class="org-builtin">int</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">tuple</span>[<span class="org-builtin">str</span>]:
    <span class="org-doc">"""Get the 'num' keys of 'counts' with maximal associated values.</span>

<span class="org-doc">    Returns: An *lexicographically* sorted num-tuple of the keys."""</span>
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> <span class="org-builtin">sorted</span>(counts.items(), key<span class="org-operator">=</span><span class="org-keyword">lambda</span> a: a[1], reverse<span class="org-operator">=</span><span class="org-constant">True</span>)[:num]
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> [a[0] <span class="org-keyword">for</span> a <span class="org-keyword">in</span> result]
    <span class="org-keyword">return</span> <span class="org-builtin">tuple</span>(<span class="org-builtin">sorted</span>(result))


<span class="org-keyword">def</span> <span class="org-function-name">find_factor</span>(N: <span class="org-builtin">int</span>, eps<span class="org-operator">=</span>1.0, randrange<span class="org-operator">=</span><span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">int</span>:
    <span class="org-doc">"""Find a non-trivial factor of N - assuming it has one.</span>

<span class="org-doc">    Args:</span>
<span class="org-doc">        N: An integer larger than 1 which is assumed to be not prime.</span>
<span class="org-doc">        eps: A parameter for the phase estimation (smaller values lead to a</span>
<span class="org-doc">            smaller error rate). Must be larger 0.</span>
<span class="org-doc">        randrange: please ignore this parameter, just for testing (sorry).</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">assert</span> eps <span class="org-operator">&gt;</span> 0, <span class="org-string">"eps must be positive."</span>
    <span class="org-keyword">assert</span> N <span class="org-operator">&gt;</span> 1, <span class="org-string">"N must be larger than 1."</span>

    <span class="org-keyword">if</span> is_even(N):
        <span class="org-keyword">return</span> 2

    <span class="org-keyword">if</span> (ret :<span class="org-operator">=</span> is_power(N)) <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> ret[0]

    <span class="org-comment-delimiter"># </span><span class="org-comment">Just for testing (sorry):</span>
    <span class="org-variable-name">randrange</span> <span class="org-operator">=</span> randrange <span class="org-keyword">or</span> random.randrange

    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">a</span> <span class="org-operator">=</span> randrange(2, N)
        <span class="org-builtin">print</span>(f<span class="org-string">"Trying a=</span>{a}<span class="org-string">"</span>)

        <span class="org-variable-name">gcd</span> <span class="org-operator">=</span> math.gcd(a, N)
        <span class="org-keyword">if</span> gcd <span class="org-operator">&gt;</span> 1:
            <span class="org-keyword">return</span> gcd

        <span class="org-comment-delimiter"># </span><span class="org-comment">From here on N is a neither even, nor a power. By assumption it is also non-prime.</span>
        <span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_order_finding_phase_estimation(a, N, eps)
        <span class="org-variable-name">sim</span> <span class="org-operator">=</span> AerSimulator()
        <span class="org-variable-name">qc_obj</span> <span class="org-operator">=</span> transpile(qc, sim)

        <span class="org-comment-delimiter"># </span><span class="org-comment">Note: on a simulator the number of shots does not significantly influence the</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">running time. This is reasonable since the simulator has access to the wave</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">function form which it can cheaply sample (at least this is how I guess it</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">works).</span>
        <span class="org-variable-name">counts</span> <span class="org-operator">=</span> sim.run(qc_obj, shots<span class="org-operator">=</span>1000).result().get_counts()

        <span class="org-variable-name">bit_list</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>(counts.keys())
        <span class="org-variable-name">weights</span> <span class="org-operator">=</span> <span class="org-builtin">list</span>(counts.values())
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(100):  <span class="org-comment-delimiter"># </span><span class="org-comment">this simulates 100 independent runs</span>
            <span class="org-variable-name">bits</span> <span class="org-operator">=</span> random.choices(bit_list, weights)[0]
            <span class="org-builtin">print</span>(f<span class="org-string">"Shot </span>{i}<span class="org-string"> measured </span>{bits}<span class="org-string">"</span>)

            <span class="org-variable-name">s_div_r</span> <span class="org-operator">=</span> Fraction(<span class="org-builtin">int</span>(bits), 2<span class="org-operator">**</span><span class="org-builtin">len</span>(bits))
            <span class="org-variable-name">convergent</span> <span class="org-operator">=</span> get_convergent(s_div_r, N)
            <span class="org-variable-name">r</span> <span class="org-operator">=</span> convergent.denominator
            <span class="org-builtin">print</span>(f<span class="org-string">"r=</span>{r}<span class="org-string">"</span>)

            <span class="org-keyword">if</span> <span class="org-keyword">not</span> is_even(r):
                <span class="org-keyword">continue</span>

            <span class="org-variable-name">r2</span> <span class="org-operator">=</span> r <span class="org-operator">//</span> 2
            <span class="org-variable-name">x</span> <span class="org-operator">=</span> (a <span class="org-operator">**</span> r2) <span class="org-operator">%</span> N

            <span class="org-keyword">if</span> x <span class="org-operator">!=</span> 1:
                <span class="org-variable-name">gcd</span> <span class="org-operator">=</span> math.gcd(x <span class="org-operator">-</span> 1, N)
                <span class="org-keyword">if</span> gcd <span class="org-operator">&gt;</span> 1:
                    <span class="org-keyword">return</span> gcd

            <span class="org-keyword">if</span> x <span class="org-operator">!=</span> N <span class="org-operator">-</span> 1:
                <span class="org-variable-name">gcd</span> <span class="org-operator">=</span> math.gcd(x <span class="org-operator">+</span> 1, N)
                <span class="org-keyword">if</span> gcd <span class="org-operator">&gt;</span> 1:
                    <span class="org-keyword">return</span> gcd
</pre>
</div>

<p>
Let us try to factor the smallest number for which phase estimation is needed (any smaller
number is either prime, even, or a power of a prime). But note that the probability that
\(a\) has a common factor with \(N\) is still high.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">N</span> <span class="org-operator">=</span> 15
<span class="org-variable-name">factor</span> <span class="org-operator">=</span> find_factor(N)
<span class="org-builtin">print</span>(f<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">A factor of </span>{N}<span class="org-string"> is </span>{factor}<span class="org-string">."</span>)
</pre>
</div>

<pre class="example">
Trying a=7
Shot 0 measured 1100000000
r=4

A factor of 15 is 3.
</pre>


<p>
It should take around 50 core-seconds to execute. Certainly not very impressive but it
shows that it works in principle. But note that we can't go much beyond this tiny example
since the simulation time depends exponentially on the number of qubits. For example to
factor <code>21</code> based on <code>a=19</code> took around 54 core-minutes on my laptop.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb567b40" class="outline-2">
<h2 id="orgb567b40">Exercises</h2>
<div class="outline-text-2" id="text-orgb567b40">
</div>
<div id="outline-container-org9717b51" class="outline-3">
<h3 id="org9717b51">Exercise 5.1</h3>
<div class="outline-text-3" id="text-org9717b51">
<p>
Give a direct proof that the linear transformation defined by Equation (5.2):
</p>

<p>
\[
  y_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x_j e^{\frac{2\pi\ii}{N}jk}
\]
</p>

<p>
is unitary.
</p>
</div>

<div id="outline-container-org1045093" class="outline-4">
<h4 id="org1045093">Proof</h4>
<div class="outline-text-4" id="text-org1045093">
<p>
An operator is unitary iff it maps one (arbitrarily chosen) orthonormal basis to an orthonormal
basis. In other words, it suffices to show that
</p>

<p>
\[
  \langle m| \FT^\dagger \FT |n\rangle = \delta_{mn} .
\]
</p>

<p>
Let us abbreviate \(a=e^{2\pi\ii/N}\). For \(n\neq m\), using the formula for <i>geometric series</i>, we have:
</p>

<p>
\[
  \langle m| \FT^\dagger \FT |n\rangle = \frac{1}{N} \sum_{kj} a^{nj-mk} \langle k|j\rangle
  = \frac{1}{N} \sum_{k} a^{(n-m)k}
  = \frac{a^{(n-m)N}-1}{a^{n-m}-1}
  = 0 .
\]
</p>

<p>
On the other hand, for \(n=m\) the summation over \(k\) in the above equality chain clearly equals
\(1\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org90476e8" class="outline-3">
<h3 id="org90476e8">Exercise 5.2</h3>
<div class="outline-text-3" id="text-org90476e8">
<p>
Explicitly compute the Fourier transform of the \(n\) qubit state \(|00\ldots0\rangle\).
</p>
</div>

<div id="outline-container-org30e1040" class="outline-4">
<h4 id="org30e1040">Solution</h4>
<div class="outline-text-4" id="text-org30e1040">
<p>
We have
</p>

<p>
\[
  \FT |00\ldots0\rangle = \frac{1}{2 ^{n/2}} \sum_{k=0}^{2^n-1} e^{\frac{2\pi\ii}{2^n}k} |k\rangle ,
\]
</p>

<p>
where we identify the (non-negative) integers \(k\) with their (standard) binary representation (as
usual).
</p>
</div>
</div>
</div>

<div id="outline-container-org22f76d9" class="outline-3">
<h3 id="org22f76d9">Exercise 5.3 (Classical fast Fourier transform)</h3>
<div class="outline-text-3" id="text-org22f76d9">
<p>
Suppose we wish to perform a Fourier transform of a vector containing \(2^n\) complex numbers on a
classical computer. Verify that the straightforward method for performing the Fourier transform,
based upon direct evaluation of Equation (5.1) requires \(\Theta(2^{2n})\) elementary arithmetic
operations. Find a method for reducing this to \(\Theta(n2^n)\) operations, based upon Equation
(5.4) (the product formula for the Quantum Fourier Transform).
</p>
</div>

<div id="outline-container-orgcda7d0c" class="outline-4">
<h4 id="orgcda7d0c">Proof</h4>
<div class="outline-text-4" id="text-orgcda7d0c">
<p>
First we consider the standard formula:
</p>

<p>
\[
  y_k = \frac{1}{2^{n/2}} \sum_{j=0}^{2^n-1} x_j e^{\frac{2\pi\ii}{2^n}jk}
\]
</p>

<p>
The following five "rather" elementary operations on real (\(x\)), complex (\(z_{i}\)), and integers
(\(n\)) arguments are sufficient to compute the above expression:
</p>

<p>
\[
  (z_1,z_2)\mapsto z_1 + z_2 ;\quad (z_1,z_2)\mapsto z_1\cdot z_2;
  \quad x\mapsto \sqrt{x} ;\quad x\mapsto e^{2\pi\ii x} ;\quad
  n\mapsto 2^{-n} .
\]
</p>

<p>
The exercise does not specify what an "elementary" operation is. But I think it is necessary to have
at least an informal characterization of what we mean by "elementary". We call an operation
<i>elementary</i> if it can be implemented with the help of constantly many instructions from the
instruction set of a modern computer processor (take a normal laptop as example).
</p>

<p>
To be a little bit more specific, we model a "modern computer" by the instruction set of <a href="https://webassembly.github.io/spec/core/syntax/instructions.html">webassembly</a>
(WASM). This makes sense since webassembly aims to be compatible with a wide range of concrete
architectures.
</p>

<p>
Note that an operation consisting of constantly many elementary operations is itself
elementary. In the following we give a <i>justification</i> why the above functions are elementary.
</p>

<p>
The first three operations are usually "elementary enough" to be directly available on (classical)
hardware - at least for (real) single or double precision floating point numbers. The corresponding
<i>instructions</i> are called <code>add</code>, <code>mul</code> and <code>sqrt</code> in WASM. What exactly these instructions do
(adding two numbers and returning the result, or replacing one number by its sum with another one)
is not relevant for us. What matters, is that this shows that the first three operations are indeed
easy to compute on modern hardware.
</p>

<p>
The fourth operation can be implemented by the cosine and sine function, exploiting the well known
formula \(e^{i\theta}=\cos\theta+\ii\sin\theta\). Some architectures have <code>sin</code> and <code>cos</code> as
instructions. This is not the case for WASM. Instead a WASM programmer has to use a library. But
since cosine and sine are just unavoidable here and ubiquitous anyway, let us cheat here a bit and
declare those functions to be elementary.
</p>

<p>
The fifth operation is a <i>little bit</i> tricky too. A simple implementation would require \(n-1\)
multiplications. A well-known trick, utilizing \(a^{2k}=(a^k)^2\) and \(a^{2k+1}=a\cdot(a^k)^2\),
reduces this to \(\Theta(\log(n))\) multiplications. Quite fast but an elementary operation should
need a constant number of instructions. Fortunately there is an even simpler way. First calculate
\(2^n\) by taking \(1\) and applying a left shift with \(n\) (<code>shl</code> in WASM). In many programming
languages this is written <code>1&lt;&lt;n</code> and it is typically crucial to work with <i>integer</i> types instead of
floats (since bit-shifts have no meaningful semantics on floats). Then convert to a float
(<code>f64.reinterpret.i64</code>) and obtain \(2^{-n}=1/2^n\) (<code>div</code>).
</p>

<p>
Actually counting the number of operations is rather trivial. Clearly
</p>

<p>
\[
  y_k = \frac{1}{2^{n/2}} \sum_{j=0}^{2^n-1} x_j e^{\frac{2\pi\ii}{2^n}jk}
\]
</p>

<p>
needs \(\Theta(2^n)\) of the above basic operations. We have to do this for \(k\in\{0,1,\ldots,2^n-1\}\)
resulting in a total of \(\Theta(2^{2n})\) operations.
</p>

<p>
Now let us turn to the fast Fourier transform. The product formula involves the following function
</p>

<p>
\[
  (k,j)\mapsto e_k(j) := e^{2\pi\ii \cdot 0.j_{n-k+1}\ldots j_n} .
\]
</p>

<p>
Note
</p>

<p>
\[
  0.j_{n-k+1}\ldots j_n = j 2^{-k} \mod 1 = \mathrm{trunc}(j 2^{-k}).
\]
</p>

<p>
Since the truncation operation (<code>trunc</code>) is a valid WASM instruction, we see that \(e_k(j)\) is
comprised of constantly many elementary operations and thus is elementary itself.
</p>

<p>
Given a vector of complex numbers \(x\), let us write \(|x\rangle=\sum_jx_j|j\rangle\). In the
following, the basic idea is to reduce a <i>call</i> to the Fourier transform \(\FT_n\) on \(n\) bits to two
calls of the Fourier transform \(\FT_{n-1}\) on \(n-1\) bits - recursively. By the product formula,
writing \(j=2j'+j_n\), we have
</p>

\begin{align*}
  \, |y\rangle &:= \FT_n |x\rangle
  = 2^{-n/2} \sum_{j=0}^{2^n-1} x_j \bigotimes_{k=1}^n (|0\rangle + e_k(j)|1\rangle) \\
  &= 2^{-n/2} \sum_{j=0}^{2^n-1} x_j (|0\rangle + (-1)^{j_n}|1\rangle)
     \bigotimes_{k=1}^{n-1} (|0\rangle + e^{2\pi\ii j_n 2^{-k-1}} e_k(j')|1\rangle) \\
  &= \frac{1}{\sqrt{2}} \sum_{j_n=0}^1 (|0\rangle + (-1)^{j_n}|1\rangle)
     \underbrace{
       2^{-(n-1)/2} \sum_{j'=0}^{2^{n-1}-1} x_{2j'+j_n} (|0\rangle + e^{2\pi\ii j_n 2^{-k-1}} e_k(j')|1\rangle)
     }_{=:|z^{(j_n)}\rangle} .
\end{align*}

<p>
Let us denote the \(2^{n-1}\) dimensional vectors \((x_{2j'+j_n})_{j'}\) by \(x^{(j_n)}\). Let
\(|y^{(j_n)}\rangle=\FT_{n-1}|x^{(j_n)}\rangle\). Then we have
</p>

<p>
\[
  \,|z^{(0)}\rangle = |y^{(0)}\rangle = \sum_{j'=0}^{2^{n-1}-1} y^{(0)}_{j'}|j'\rangle
  \text{ and } |z^{(1)}\rangle = \sum_{j'=0}^{2^{n-1}-1} e^{2\pi\ii j'2^{-n}} y^{(0)}_{j'} |j'\rangle .
\]
</p>

<p>
The first equality follows directly from the product formula. The second one also follows from the
product formula - note that the bit pattern of \(|j'\rangle\) dictates which of the factors
\(e^{2\pi\ii\,j_n2^{-k-1}}\) appear in the coefficients. Lets go on with the calculation:
</p>

\begin{align*}
  \,|y\rangle &= \frac{1}{\sqrt{2}} \sum_{j_n=0}^1 (|0\rangle + (-1)^{j_n}|1\rangle) |z^{(j_n)}\rangle \\
  &= \frac{1}{\sqrt{2}} \sum_{j=0}^{2^n-1} (|0\rangle + (-1)^{j_n}|1\rangle) z^{(j_n)}_{j'} |j'\rangle \\
  &= \sum_{j'=0}^{2^{n-1}-1} \underbrace{\frac{1}{\sqrt{2}}(z^{(0)}_{j'} + z^{(1)}_{j'})}_{y_{j'}} |0j'\rangle +
     \sum_{j'=0}^{2^{n-1}-1} \underbrace{\frac{1}{\sqrt{2}}(z^{(0)}_{j'} - z^{(1)}_{j'})}_{y_{2^{n-1}+j'}} |1j'\rangle .
\end{align*}


<p>
Let us briefly summarize the algorithm for calculating the coefficients of \(|y\rangle\) which can be
extracted from the above calculations:
</p>

<ol class="org-ol">
<li>Calculate \(|y^{(j_n)}\rangle=\FT_{n-1}|x^{(j_n)}\rangle\) - recursively as long as \(n>1\),</li>
<li>Calculate \(|z^{(j_n)}\rangle\) from \(|y^{(j_n)}\rangle\) as above,</li>
<li>Calculate \(|y\rangle\) from \(|z^{(j_n)}\rangle\) as above,</li>
</ol>

<p>
where \(j_n\in\{0,1\}\). Let \(c_n\) be the number of elementary operations required by this
algorithm. Clearly step one needs \(2c_{n-1}\) operations. Step two needs at most \(c2^n\) operations
for some constant \(c\). The same is true for step three - possibly enlarging \(c\). Hence
</p>

<p>
\[
  c_{n} \leq 2c_{n-1} + 2c2^n .
\]
</p>

<p>
It is not hard to see that this implies
</p>

<p>
\[
  c_{n} \leq 2(n-1)c2^n + 2^{n-1} c_1 = O(n2^n) .
\]
</p>

<p>
It is also not hard to see that \(n2^n\) is also a lower bound (up to a constant factor) for the
number of operations. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfb4a13d" class="outline-3">
<h3 id="orgfb4a13d">Exercise 5.4</h3>
<div class="outline-text-3" id="text-orgfb4a13d">
<p>
Give a decomposition of the controlled-\(R_k\) gate into single qubit and <code>CNOT</code> gates.
</p>
</div>

<div id="outline-container-org5934073" class="outline-4">
<h4 id="org5934073">Solution</h4>
<div class="outline-text-4" id="text-org5934073">
<p>
Let us abbreviat \(\theta_k=2\pi2^{-k}\). Note that \(R_k=e^{\ii\theta_{k+1}}R_z(\theta_k)\). It is easy
to find a solution based on the ABC-construction from Figure 4.6 and the proof of Corollary 4.2.
</p>

<p>
In fact, the following circuit (\(C=B=R_{k+1}^\dagger\), \(A=R_k\), \(\alpha=\theta_{k+1}\)) implements \(C(R_k)\):
</p>

<pre class="example">
                                         ┌─────────┐
q_0: ───────────────■─────────────────■──┤ R_{k+1} ├
     ┌───────────┐┌─┴─┐┌───────────┐┌─┴─┐└─┬─────┬─┘
q_1: ┤ R_{k+1}^† ├┤ X ├┤ R_{k+1}^† ├┤ X ├──┤ R_k ├──
     └───────────┘└───┘└───────────┘└───┘  └─────┘
</pre>


<p>
To see this recall that \(XZX=-Z\). Hence by the functional calculus
</p>

<p>
\[
  XR_{k+1}^\dagger X = e^{-\ii\theta_{k+2}} XR_z(-2\pi2^{-k-1})X
  = e^{-\ii\theta_{k+2}} R_z(2\pi2^{-k-1}) = e^{-\ii\theta_{k+1}} R_{k+1} .
\]
</p>

<p>
The factor \(e^{\ii\theta_{k+1}}\) gets compensated by the \(R_{k+1}\) on the upper qubit. The claim
follows from this together with \(R_k=R_{k+1}^2\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org03191e5" class="outline-3">
<h3 id="org03191e5">Exercise 5.5</h3>
<div class="outline-text-3" id="text-org03191e5">
<p>
Give a quantum circuit to perform the inverse quantum Fourier transform.
</p>
</div>

<div id="outline-container-orgda21fac" class="outline-4">
<h4 id="orgda21fac">Solution</h4>
<div class="outline-text-4" id="text-orgda21fac">
<p>
The standard way to get the invere of some circuit is to just write down all the gates in revers
order and conjugate them (replace \(R_k\) by \(R_k^\dagger\) in our case since <code>SWAP</code> and \(H\) are
self-inverse).
</p>

<p>
Actually it is sufficient to <i>just</i> replace all \(R_k\) by \(R_k^\dagger\) (and not reverse the gate
order). To see this, recall that the inverse Fourier transform is given by
</p>

<p>
\[
  x_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} y_j e^{-\frac{2\pi\ii}{N}jk} .
\]
</p>

<p>
The difference to the Fourier transform itself is just the minus sign - which could be put into \(j\)
when deriving the product formula for the <i>inverse</i> Fourier transform:
</p>

<p>
\[
  \FT^\dagger :
\, |j\rangle \mapsto
   \frac{\left(|0\rangle + e^{-2\pi\ii0.j_n}\right) \left(|0\rangle + e^{-2\pi\ii0.j_{n-1}j_n}\right)
   \cdots \left(|0\rangle + e^{-2\pi\ii0.j_1j_2\ldots j_n}\right)}{2^{n/2}} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org05e0a35" class="outline-3">
<h3 id="org05e0a35">Exercise 5.6 (Approximate quantum Fourier transform)</h3>
<div class="outline-text-3" id="text-org05e0a35">
<p>
The quantum circuit construction of the quantum Fourier transform apparently requires gates of
exponential precision in the number of qubits used. However, such precision is never required in any
quantum circuit of polynomial size. For example, let \(U\) be the ideal quantum Fourier transform on
\(n\) qubits, and \(V\) be the transform which results if the controlled-\(R_k\) gates are performed to a
precision \(\Delta=1/p(n)\) for some polynomial \(p(n)\). Show that the error
\(\norm{U-V}=\max_{|\psi\rangle}\norm{(U-V)|\psi\rangle\) scales as \(\Theta(n^2/p(n))\), and thus
polynomial precision in each gate is sufficient to guarantee polynomial accuracy in the output
state.
</p>
</div>

<div id="outline-container-orge9ad4cd" class="outline-4">
<h4 id="orge9ad4cd">Proof</h4>
<div class="outline-text-4" id="text-orge9ad4cd">
<p>
This is actually a direct consequence of Box 4.1 and the fact that the implementation of the Fourier
transform has \(m=\Theta(n^2)\) gates. In fact, writing \(U=\prod_{i=1}^mU_i\) as the product of its
implementing gates, and similarly \(V\) we see that
</p>

<p>
\[
  \norm{U-V} = \norm{\prod_{i=1}^mU_i - \prod_{i=1}^mV_i}
  \leq \sum_{i=1}^m \norm{U_i - V_i}
  \leq m \Delta = \Theta(n^2 / p(n)) .
\]
</p>

<p>
The first inequality is the second statement in Box 4.1 (errors of products of unitary operators
<i>at worst</i> add up). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org31d77f5" class="outline-3">
<h3 id="org31d77f5">Exercise 5.7</h3>
<div class="outline-text-3" id="text-org31d77f5">
<p>
Additional insight into the circuit in Figure 5.2 may be obtained by showing, as you should now do,
that the effect of the sequence of controlled-\(U\) operations like that in Figure 5.2 is to take the
state \(|j\rangle|u\rangle\) to \(|j\rangle\,U^j|u\rangle\) (Note that this does not depend on
\(|u\rangle\) being an eigenstate of \(U\).)
</p>
</div>

<div id="outline-container-org98d1ccc" class="outline-4">
<h4 id="org98d1ccc">Proof</h4>
<div class="outline-text-4" id="text-org98d1ccc">
<p>
This is more or less obvious but let us go at least a little bit into detail.
</p>

<p>
Let \(G_k\) for \(k=0,\ldots,t-1\) be the \(k\)​-th of the controlled powers of \(U\) (from the left as
viewed in the circuit, that is, in application order).
</p>

<p>
By definition we have
</p>

<p>
\[
  G_k |j\rangle |u\rangle = \begin{cases} |j\rangle |u\rangle & \text{if } j_k=0 \\ |j\rangle U^{2^k} |u\rangle & \text{if } j_k=1 \end{cases}
  = |j\rangle U^{j_k2^k} |u\rangle .
\]
</p>

<p>
Thus
</p>

<p>
\[
  \prod_{k=0}^{t-1} G_k |j\rangle |u\rangle = |j\rangle \prod_{k=0}^{t-1} U^{j_k2^k} |u\rangle
  = |j\rangle U^{\sum_{k=0}^{t-1} j_k 2^k} |u\rangle
  = |j\rangle U^j |u\rangle .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org34b634d" class="outline-3">
<h3 id="org34b634d">Exercise 5.8</h3>
<div class="outline-text-3" id="text-org34b634d">
<p>
Suppose the phase estimation algorithm takes the state \(|0\rangle|u\rangle\) to the state
\(|\tilde{\varphi}_u\rangle|u\rangle\), so that given the input \(|0\rangle(\sum_uc_u|u\rangle)\), the
algorithm outputs \(\sum_uc_u|\tilde{\varphi}_u\rangle|u\rangle\). Show that if \(t\) is chosen
according to (5.35), then the probability for measuring \(\varphi_u\) accurate to \(n\) bits at the
conclusion of the phase estimation algorithm is at least \(|c_u|^2(1-\varepsilon)\).
</p>
</div>

<div id="outline-container-orgd9b5cc7" class="outline-4">
<h4 id="orgd9b5cc7">Proof</h4>
<div class="outline-text-4" id="text-orgd9b5cc7">
<p>
The action of the phase estimation circuit is
</p>

<p>
\[
\,|0\rangle(\sum_uc_u|u\rangle) \mapsto \sum_uc_u|\tilde{\varphi}_u\rangle|u\rangle
\]
</p>

<p>
by linearity of the circuit - as claimed by the exercise statement. Tracing out the \(u\)​-register (in
the RHS) yields the following mixed state in the first register:
</p>

<p>
\[
  \rho = \sum_u |c_u|^2 |\tilde{\varphi}_u\rangle \langle\tilde{\varphi}_u| .
\]
</p>

<p>
Let us now consider <i>any</i> of the eigenstates \(|u\rangle\) - call it \(|v\rangle\) to give it distinct
name. Let \(b<2^t\) be any non-negative integer with \(|\varphi_v-b|\,\leq\,e\), where \(e\) is as in the
book, guaranteeing that \(b\) approximates \(\varphi_v\) by at least \(n\) bits. The probability to
measure \(b\) is given by:
</p>

<p>
\[
  p(b) = \trace{|b\rangle\langle b|\rho} = \trace{|b\rangle\langle b| \rho |b\rangle\langle b|}
  \geq \trace{|b\rangle\langle b| |c_v|^2|\tilde{\varphi}_v\rangle\langle\tilde{\varphi}_v| |b\rangle\langle b|}
  = |c_v|^2 |\langle b|\varphi_v\rangle|^2 .
\]
</p>

<p>
The inequality above follows from the fact that each summand in \(\rho\), even when conjugated with
some projection, yields a non-negative contribution to the trace. Hence the probability to measure
one of the \(b\) which approximate \(\varphi_v\) by at least \(n\) bits is at least
\(|c_v|^2(1-\varepsilon)\) (by the choice of \(t\) and what was shown in the book for the special case
\(c_v=1\)). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf8ed32c" class="outline-3">
<h3 id="orgf8ed32c">Exercise 5.9</h3>
<div class="outline-text-3" id="text-orgf8ed32c">
<p>
Let \(U\) be a unitary transform with eigenvalues \(\pm1\), which acts on a state \(|\psi\rangle\). Using
the phase estimation procedure, construct a quantum circuit to collapse \(|\psi\rangle\) into one or
the other of the two eigenspaces of \(U\), giving also a classical indicator as to which space the
final state is in. Compare your result with Exercise 4.34.
</p>
</div>

<div id="outline-container-org3ccc108" class="outline-4">
<h4 id="org3ccc108">Solution</h4>
<div class="outline-text-4" id="text-org3ccc108">
<p>
In this case the two phases are \(\varphi_+=0\) and \(\varphi_-=1/2\). Since these two numbers can be
expressed <i>exactly</i>, utilizing just a single bit, it is sufficient to take the phase estimation
circuit with \(t=1\) (any larger value would work too of course). Measuring \(1\) (or more generally
\(2^{t-1}\)) means a collapse onto the \(-1\) eigenstate. Measuring \(0\) means a collapse onto the \(+1\)
eigenstate.
</p>

<p>
In hindsight we see that in exercise 4.34 we already used this special case of the phase estimation
circuit. We also note that the Hadamard gate is the Fourier transform on a single qubit.
</p>
</div>
</div>
</div>

<div id="outline-container-org51204b5" class="outline-3">
<h3 id="org51204b5">Exercise 5.10</h3>
<div class="outline-text-3" id="text-org51204b5">
<p>
Show that the order of \(x=5\) modulo \(N=21\) is \(6\).
</p>
</div>

<div id="outline-container-org6162275" class="outline-4">
<h4 id="org6162275">Proof</h4>
<div class="outline-text-4" id="text-org6162275">
<p>
It is probably easiest to just make a table:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(i\)</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left">\(5^i \mod 21\)</td>
<td class="org-right">5</td>
<td class="org-right">4</td>
<td class="org-right">20</td>
<td class="org-right">16</td>
<td class="org-right">17</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
The powers of \(x=5\) can be calculated sequentially by repeatedly multiplying by \(5\) and taking the
rest after deviding by \(21\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org73c51ed" class="outline-3">
<h3 id="org73c51ed">Exercise 5.11</h3>
<div class="outline-text-3" id="text-org73c51ed">
<p>
Show that the order of \(x\) satisfies \(r\leq N\).
</p>
</div>

<div id="outline-container-org8ec5925" class="outline-4">
<h4 id="org8ec5925">Proof</h4>
<div class="outline-text-4" id="text-org8ec5925">
<p>
By the pigeonhole principle there are \(a,b\in\{1,2,\ldots,N+1\}\) with \(a < b\) such that
\(x^a=x^b\). Since \(x\) and \(N\) are coprime we can divide this by \(x^a\) (see also Exercise A4.12) and
obtain
</p>

<p>
\[
  x^{b-a} = 1 \mod N .
\]
</p>

<p>
Hence \(r\leq b-a\leq N\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbaf418a" class="outline-3">
<h3 id="orgbaf418a">Exercise 5.12</h3>
<div class="outline-text-3" id="text-orgbaf418a">
<p>
Show that \(U\) (see (5.36)) is unitary (Hint: \(x\) is co-prime to \(N\), and therefore has an inverse
modulo \(N\)).
</p>
</div>

<div id="outline-container-orga4d9ee6" class="outline-4">
<h4 id="orga4d9ee6">Proof</h4>
<div class="outline-text-4" id="text-orga4d9ee6">
<p>
Recall that \(U\) only acts non-trivially on basis states \(|i\rangle\) with \(i < N\). In that case
</p>

<p>
\[
  U|i\rangle = |xi\mod N\rangle .
\]
</p>

<p>
It is sufficient to prove that the restriction of \(U\) to the non-trivial sub-space is unitary. Note
that the mapping
</p>

<p>
\[
  \pi: i \mapsto xi \mod N
\]
</p>

<p>
is a permutation on \(\{0,1,\ldots,N-1\}\) since \(x\) has a multiplicative inverse modulo \(N\). Observe that
</p>

<p>
\[
  \langle i| U^\dagger U|j\rangle = \langle\pi(i)|\pi(j)\rangle = \delta_{ij}
\]
</p>

<p>
since \(\pi\) is a permutation. This implies that \(U\) is unitary. QED.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>We have actually shown that \(U\) is a permutation on the computational basis.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orgc1748a8" class="outline-3">
<h3 id="orgc1748a8">Exercise 5.13</h3>
<div class="outline-text-3" id="text-orgc1748a8">
<p>
Prove (5.44). (Hint: \(\sum_{s=0}^{r-1}\exp(-2\pi\ii sk/r)=r\delta_{k0}\).) In fact, prove that
</p>

<p>
\[
  \frac{1}{\sqrt{r}} \sum_{s=0}^{r-1} e^{2\pi\ii sk/r} |u_s\rangle = |x^k \mod N\rangle .
\]
</p>
</div>

<div id="outline-container-org424152e" class="outline-4">
<h4 id="org424152e">Proof</h4>
<div class="outline-text-4" id="text-org424152e">
<p>
Let us write \(x^k\) instead of \(x^k\mod N\) for short.
</p>

<p>
\[
  \frac{1}{\sqrt{r}} \sum_{s=0}^{r-1} e^{2\pi\ii sk/r} |u_s\rangle
  = \frac{1}{r} \sum_{s,l=0}^{r-1} e^{2\pi\ii s(k-l)/r} |x^l\rangle
  = \sum_{l=0}^{r-1} \delta_{kl} |x^l\rangle
  = |x^k\rangle .
\]
</p>

<p>
The second equality uses the hint given in the formulation of the exercise. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org6ede131" class="outline-3">
<h3 id="org6ede131">Exercise 5.14</h3>
<div class="outline-text-3" id="text-org6ede131">
<p>
The quantum state produced in the order-finding algorithm, before the inverse Fourier transform, is
</p>

<p>
\[
\, |\psi\rangle = \frac{1}{2^{t/2}} \sum_{j=0}^{2^t-1} |j\rangle U^j |1\rangle
  = \frac{1}{2^{t/2}} \sum_{j=0}^{2^t-1} |j\rangle |x^j \mod N \rangle ,
\]
</p>

<p>
if we initialize the second register as \(|1\rangle\). Show that the same state is obtained if we
replace \(U^j\) with a <i>different</i> unitary transform \(V\), which computes
</p>

<p>
\[
  V |j\rangle |k\rangle = |j\rangle |k + x^j \mod N\rangle ,
\]
</p>

<p>
and start the second register in the state \(|0\rangle\). Also show how to construct \(V\) using
\(O(L^3)\) gates.
</p>
</div>

<div id="outline-container-orgf457f2c" class="outline-4">
<h4 id="orgf457f2c">Proof</h4>
<div class="outline-text-4" id="text-orgf457f2c">
<p>
Recall that the "original" algorithm \(W\), using controlled \(U^j\), acts like this:
</p>

<p>
\[
  W \ket{j,k} = \ket{j} U^j \ket{k} = \ket{j, k x^j \mod N} .
\]
</p>

<p>
Therefore the first claim directly follows from
</p>

<p>
\[
  V\ket{j}\ket{0} = W \ket{j}\ket{1} .
\]
</p>

<p>
It remains to show the \(V\) can be implemented by \(O(L^3)\) gates. We will reduce \(V\) to
\(W\). Let \(\mathrm{ADDMOD}_N\) be a gate which adds the first register to the second
register modulo \(N\):
</p>

<p>
\[
  \mathrm{ADDMOD}_N: \ket{a, b} \mapsto \ket{a, a + b \mod N} .
\]
</p>

<p>
Let us briefly argue that this operation needs \(O(L)\) gates. The version without the
modulus - plain <code>ADD</code> - needs \(O(L)\) gates if implemented as a carry-adder (see
e.g. Chapter 2 in (Thomas G. Draper, 2000)). The basic idea to make this into a modular adder is
the same as in the <a href="#org21643f0">modular fourier incrementer</a>. It is even simpler now since we can drop
the Fourier transforms, but we have to replace the (unary) fourier incrementer gates by
(binary) (non-fourier) adders or (unary) incrementers. This construction can essentially
be found in chapter 2.2 in (Stephane Beauregard, 2003).
</p>

<p>
Enough words. This is a circuit implementing \(\mathrm{ADDMOD_N}\) (it uses one ancilla):
</p>


<div id="org774ddc7" class="figure">
<p><img src="./images/modular-adder-circuit.svg" alt="modular-adder-circuit.svg" class="org-svg" style="width: 100%" />
</p>
<p><span class="figure-number">Figure 1: </span>Modular Adder</p>
</div>

<p>
Here
</p>

<p>
\[
  \mathrm{INC}_N: \ket{a} \mapsto \ket{a + N} .
\]
</p>

<p>
and
</p>

<p>
\[
  \mathrm{ADD}: \ket{a, b} \mapsto \ket{a, a + b} .
\]
</p>

<p>
The control of the two <code>CX</code> gates are at the most significant bit of \(b\). This bit is
responsible to detect underflow when subtracting \(N\) with \(\mathrm{INC}_N^\dagger\). In
particular we require that the two register holding \(a\) and \(b\) do not need the most
significant bit to represent \(a\), \(b\) and \(N\).
</p>

<p>
Having this we can implement \(V\) utilizing one ancilla register initialized to \(\ket{1}\)
(same size as the other two registers):
</p>

<p>
\[
  \ket{j,k,1} \stackrel{W(1,3)}{\mapsto} \ket{j,k,x^j \mod N}
  \stackrel{\mathrm{ADDMOD}_N(3,2)}{\mapsto} \ket{j,k+x^j \mod N,x^j \mod N}
  \stackrel{W(1,3)^\dagger}{\mapsto} \ket{j,k+x^j \mod N,1} .
\]
</p>

<p>
The numbers in e.g. \(W(1,3)\) say on which registers the gate operates. Since \(W\) can be
implemented with \(O(L^3)\) gates the same is true for \(V\). QED.
</p>
</div>
</div>
</div>
<div id="outline-container-org403812a" class="outline-3">
<h3 id="org403812a">Exercise 5.15</h3>
<div class="outline-text-3" id="text-org403812a">
<p>
Show that the least common multiple of positive integers \(x\) and \(y\) is \(xy/\gcd(x,y)\),
and thus may be computed in \(O(L^2)\) operations if \(x\) and \(y\) are \(L\) bit numbers.
</p>
</div>

<div id="outline-container-orgae27d99" class="outline-4">
<h4 id="orgae27d99">Proof</h4>
<div class="outline-text-4" id="text-orgae27d99">
<p>
The claim that \(xy/\gcd(x,y)\) is the least common multiple of \(x\) and \(y\) can be seen from
the prime factorization of the two numbers (c.f. <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic">fundamental theorem of arithmetic</a>). But
be aware of the fact that operations like the \(\gcd\) are a so fundamental concept in
number theory that they might be involved in a proof of the fundamental theorem of
arithmetic. Therefore we won't dive deeper into a proof of this statement. From a
practical standpoint the complexity part of the exercise is more interesting
anyway. Therefore let us look into that instead.
</p>

<p>
The schoolbook method for multiplication and division yield algorithms with complexity
\(O(L^2)\) (see <a href="https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations">wikipedia</a>). The interesting part is to show that the \(\gcd\) can be
calculated in quadratic time too.
</p>

<p>
Recall that the \(\gcd\) can be calculated by this recursion formula:
</p>

<p>
\[
  \gcd(a, b) = \begin{cases}
    \gcd(b, a) & \text{if } b > a, \\
    a & \text{if } b = 0, \\
    \gcd(b, a \mod b) & \text{else.} \end{cases}
\]
</p>

<p>
If we unroll this recursion to a loop we need to perform the swap of the first case only
once at the beginning (if at all).
</p>

<p>
Let us show that the loop takes \(O(L)\) iterations (where \(L\) is the number of bits we use
to represent the numbers). Without loss of generality assume \(a>b\). Let \(n-1\) be the
number of iterations. More precisely, let \(n-2\) count how often we hit the else case (plus
one for hitting \(b=0\) in the last iteration). Define:
</p>

<p>
\[
  a_n = a,\quad a_{n-1}=b, \quad a_{i-2} = a_i \mod a_{i-1} \text{ for } i\in \{2,\ldots,n\} .
\]
</p>

<p>
By definition of \(n\) we have \(a_0=0\) and \(a_1\geq1\). Moreover
\(a_i\,\geq\,a_{i-1}+a_{i-2}\). Note that if the \(\geq\) in the last two sentences were
replaced by \(=\) the sequence would be identical with the Fibonacci numbers. Hence, by
mathematical induction one can show that the sequence of \(a_i\) is bounded from below by
the Fibonacci numbers. The latter grow exponentially fast and hence \((a_i)\) grows
exponentially fast as well (which can also be seen directly of course). This implies that
\(n=O(\log(a))=O(L)\) as desired.
</p>

<p>
Finally let us show that each iterations has complexity \(O(L)\), leading to an overall
complexity of \(O(L^2)\) since we just showed that at most \(O(L)\) iterations are necessary.
</p>

<p>
In fact, this follows from the following observations:
</p>

<ol class="org-ol">
<li>Comparisons like \(a=b\) or \(a>b\) have complexity \(O(L)\).</li>
<li>Swap \((a,b)\mapsto(b,a)\) has complexity \(O(L)\).</li>
<li>\(a\mod b\) has complexity \(O(L)\).</li>
</ol>

<p>
The first two claims should be known already or at least plausible. The third claim
follows implicitly from looking at <a href="#org774ddc7">our construction of the modular adder</a>. In fact,
\(a\,\mod\,b\) is modular addition without addition (the first of the three registers is not
used and the <code>ADD</code> gates can be removed). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org79fef9e" class="outline-3">
<h3 id="org79fef9e">Exercise 5.16</h3>
<div class="outline-text-3" id="text-org79fef9e">
<p>
For all \(x\geq2\) prove that \(\int_x^{x+1} 1/y^2 dy \geq 2/3 x^2\). Show that
</p>

<p>
<a id="org1aae348"></a>
\[
  \sum_{q=2}^{\infty} \frac{1}{q^2} \leq \frac{3}{2} \int_2^\infty \frac{1}{y^2} dy = \frac{3}{4} ,
\]
</p>

<p>
and thus that (5.58) holds.
</p>
</div>

<div id="outline-container-org68eba3c" class="outline-4">
<h4 id="org68eba3c">Proof</h4>
<div class="outline-text-4" id="text-org68eba3c">
<p>
An antiderivative of \(1/y^2\) is \(-1/y\). Hence
</p>

<p>
\[
  \int_x^{x+1} 1/y^2 dy = \left. -\frac{1}{y} \right|_{x}^{x+1}
  = \frac{1}{x^2+x} \geq \frac{2}{3} \cdot \frac{1}{x^2} .
\]
</p>

<p>
The factor \(2/3\) comes from the fact that
</p>

<p>
\[
  \frac{x^2}{x^2 + x} = \frac{1}{1 + 1/x} \geq \frac{2}{3} ,
\]
</p>

<p>
for \(x\geq2\). Obtaining the <a href="#org1aae348">final claim</a> is just an application of this result with
\(x=q\) using \(\int_2^\infty y^{-2} dy = 1/2\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgeb947eb" class="outline-3">
<h3 id="orgeb947eb">Exercise 5.17</h3>
<div class="outline-text-3" id="text-orgeb947eb">
<p>
Suppose \(N\) is \(L\) bits long. The aim of this exercise is to ﬁnd an efficient classical
algorithm to determine whether \(N=a^b\) for some integers \(a\geq1\) and \(b\geq2\). Show that
there exists an algorithm having complexity \(O(L^3)\).
</p>

<p>
Remark: I altered the description a bit since, in my opinion, step two of the original
formulation makes it really hard to find a <i>simple</i> algorithm. In fact \(\log_2(N)\)
requires in general an arbitrary precision floating point datatype for the return
value. Similarly the operation \(x\mapsto2^x\) takes a float as input. I would like to stay
in the integer realm - for conceptual simplicity - and hence I removed the solution
guide.
</p>
</div>

<div id="outline-container-orgec363ae" class="outline-4">
<h4 id="orgec363ae">Proof for complexity \(O(L^4)\)</h4>
<div class="outline-text-4" id="text-orgec363ae">
<p>
Let us solve a relaxed version of the exercise and search only for an algorithm with
complexity \(O(L^4)\).
</p>

<p>
<code class="src src-python">is_power</code> already implements a really simple algorithm solving the problem (see
<a href="#orga5ed183">above</a>). Let us <i>roughly</i> estimate its complexity to show that it is indeed \(O(L^4)\). First
of all note that \(k_2=O(L)\). The <code>while</code> loop inside <code>is_power</code> iterates at most \(O(L/k)\)
times (once for each <code>1</code> in the binary representation of <code>x</code>) and contains <code>intlogx</code> as
the most heavyweight operation.
</p>

<p>
<code>intlogx</code> in turn contains a <code>while</code> loop which is executed \(O(L/k)\) times and each loop
contains an exponentiation as the most heavyweight operation which has complexity
\(O(L^2k^{-2}\log(k))\) assuming quadratic complexity for multiplication (and that our
multiplication routine makes use of the fact that the numbers have size \(O(L/k)\) meaning
that not all \(L\) bits are occupied). To understand the factor \(O(\log(k))\) recall that
a well known algorithm for exponentiation (repeated squaring) works like this:
</p>

\begin{align*}
  a^{1111} &= a\cdot a^{1110} = a\cdot (a^2)^{111} = a\cdot a^2 \cdot (a^2)^{110} \\
  &= a^3 \cdot (a^2)^{110} = a^3 \cdot (a^4)^{11} = a^3 \cdot a^4 \cdot (a^4)^{10} \\
  &= a^7 \cdot (a^4)^{10} = a^9 \cdot (a^8)^1 = a^{15} .
\end{align*}

<p>
This example should help to understand the following: To compute \(a^k\) with <code>L</code>-bit number
\(a\) and <code>K</code>-bit exponent \(k\) we need \(O(K)\) multiplications and \(O(L)\) space.
</p>

<p>
Therefore, each iteration of the <code>for</code> loop in <code>is_power</code> has complexity
\(O(L^4k^{-3}\log(k))\). Summing this for \(k\) in the range \(2,\ldots,k_2=O(L)\) leads to an
overall complexity of \(O(L^4)\). QED.
</p>
</div>
</div>

<div id="outline-container-orge107ae7" class="outline-4">
<h4 id="orge107ae7">Proof for complexity \(O(L^3)\)</h4>
<div class="outline-text-4" id="text-orge107ae7">
<p>
Let us improve the implementation of <code>is_power</code> to loose one factor \(L\). Recall that for
each \(k\) we compute the largest integer \(x\) such that \(x^k\leq N\). This takes
\(O(L^2k^{-2})\) steps since each \(1\) in its binary expansion is responsible for \(O(L/k)\)
steps and there can be up to \(O(L/k)\) ones in the binary expansion. Just to illustrate
this, if \(x=1001101\) the algorithm successively computes:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">step</th>
<th scope="col" class="org-right">x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1000000</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1001000</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1001100</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1001101</td>
</tr>
</tbody>
</table>

<p>
To obtain e.g. the <code>1001000</code> in step two the algorithm looks at each of these numbers
<code>1000001</code>, <code>1000010</code>, <code>1000100</code>, <code>1001000</code>, <code>1010000</code>, sees that the last one is too large
and takes the second to last.
</p>

<p>
One can do something cleverer. In fact, first search for the <i>smallest</i> power of two \(2^i\)
which satisfies \(2^{ik} \geq N\) (complexity \((O(L/k))\)). Then do a binary search to find
\(x\in\{1,\ldots,2^i\}\) (complexity \(O(L/k)\)). This saves us one factor \(L/k\) as
desired. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org172fa0c" class="outline-3">
<h3 id="org172fa0c">Exercise 5.18 (Factoring 91)</h3>
<div class="outline-text-3" id="text-org172fa0c">
<p>
Suppose we wish to factor \(N=91\). Conﬁrm that steps 1 and 2 are passed. For step 3,
suppose we choose \(x=4\), which is co-prime to \(91\). Compute the order \(r\) of \(x\) with
respect to \(N\), and show that \(x^{r/2} = 64 \neq -1 \mod 91\), so the algorithm
succeeds, giving \(\gcd(64-1,91)=7\). It is unlikely that this is the most efficient method
you’ve seen for factoring \(91\).  Indeed, if all computations had to be carried out on a
classical computer, this reduction would not result in an efﬁcient factoring algorithm, as
no efficient method is known for solving the order-ﬁnding problem on a classical computer.
</p>
</div>

<div id="outline-container-org7f012e5" class="outline-4">
<h4 id="org7f012e5">Solution</h4>
<div class="outline-text-4" id="text-org7f012e5">
<p>
Clearly \(91\) is not even and it is also not hard to verify that it is not a power. Hence
the order finding subroutine is applied.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">assert</span> is_power(91) <span class="org-keyword">is</span> <span class="org-constant">None</span>
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
PASSED
</pre>


<p>
To compute the order of \(x=4\) we make a table:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>i</code></th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">6</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>x^i mod N</code></td>
<td class="org-right">4</td>
<td class="org-right">16</td>
<td class="org-right">64</td>
<td class="org-right">74</td>
<td class="org-right">23</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Hence the order is \(r=6\) and \(x^{r/2}=64\mod91\). This gives us \(7=\gcd(63,91)\) as a factor
of \(91\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb838818" class="outline-3">
<h3 id="orgb838818">Exercise 5.19</h3>
<div class="outline-text-3" id="text-orgb838818">
<p>
Show that \(N=15\) is the smallest number for which the order-ﬁnding subroutine is applied
when using Shor's algorithm, that is, it is the smallest composite number that is not even
or a power of some smaller integer.
</p>
</div>

<div id="outline-container-orga69dc64" class="outline-4">
<h4 id="orga69dc64">Proof</h4>
<div class="outline-text-4" id="text-orga69dc64">
<p>
In a sense the exercise statement contains the answer: \(15\) is just the smallest integer
which is larger than \(1\), no prime, not even and not power of some other number. This can be
easily verified by checking every smaller number for each of these properties. QED.
</p>

<p>
This solves the exercise, but let us take the opportunity to recall why each of these
properties is required as a precondition of the quantum part of Shor's algorithm:
</p>

<dl class="org-dl">
<dt>not a prime</dt><dd>This is just a precondition of the problem itself. Nothing is expected from the
algorithm if the input is a prime number - and it certainly cannot find a non-trivial
factor for trivial reasons. This is a reasonable assumption in applications like
breaking RSA since we know that the number is (supposed to be) a product of two primes
in that case.</dd>
<dt>not even</dt><dd>For a run of the order finding routine to be useful two conditions must be met: phase
estimation must succeed, and the found order must be even one of the two factors
\((x^{r/2}-1)(x^{r/2}+1)\) should have a non-trivial \(\gcd\) with \(N\). These two conditions
are only met with certain probabilities. The probability for the first can be controlled
by providing sufficiently many additional qubits in the phase estimation circuit. An
estimate for the probability of the second condition is given in Theorem A4.13. But this
theorem needs \(N\) to be odd. <i>But</i> note that this does not imply that the algorithm
would not work. In fact the phase estimation can even for \(N=14\) provide us with a
factor: Assume \(a=5\) is chosen. \(a\) has order \(6\). The funny thing is that even though
\(5^3=-1\mod14\) this is actually OK since it yields the factor 2! Just use a modified
version of <code>find_factor</code> to verify that this indeed works.</dd>
<dt>no power of a prime</dt><dd>Theorem A4.13 requires this too. Moreover \(x^2=1\mod N\) won't ever have a <i>non-trivial</i>
solution if \(N\) is a power of an odd prime! This follows from Theorem A4.10 together
with the easy to prove fact that cyclic groups have at most two square roots of the
identity (note that all cyclic groups are isomorphic to the group \((\{0,\ldots,n-1\},+)\)
with addition modulo \(n\). But again, this does not mean the algorithm has to loop
forever. It just means that based on the Theorems showed in the book nothing can be
guaranteed.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orgf540a17" class="outline-3">
<h3 id="orgf540a17">Exercise 5.20</h3>
<div class="outline-text-3" id="text-orgf540a17">
<p>
Suppose \(f(x+r)=f(x)\), and \(0\leq x < N\) , for \(N\) an integer multiple of \(r\). Compute the
Fourier transform on \(\ZZ_N\):
</p>

<p>
\[
  \hat{f}(l) = \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} e^{-2\pi\ii lx/N} f(x) ,
\]
</p>

<p>
and relate the result to the Fourier transform on \(\ZZ_r\) (5.63).
</p>
</div>

<div id="outline-container-orgadd5b91" class="outline-4">
<h4 id="orgadd5b91">Solution</h4>
<div class="outline-text-4" id="text-orgadd5b91">
<p>
By assumption \(N=nr\) for some integer \(n\). Moreover, let us write \(x=yr+z\) where
\(0\leq\,z\,<\,r\). Then
</p>

\begin{align*}
  \FT_N f(l) &= \frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} e^{-2\pi\ii lx/N} f(x) \\
  &= \frac{1}{\sqrt{N}} \sum_{y=0}^{n-1} \sum_{z=0}^{r-1} e^{-2\pi\ii ly/n} e^{-2\pi\ii lz/N} f(z) .
\end{align*}

<p>
In the second equality we used the fact hat \(f\) is \(r\)​-periodic, and hence \(f(x)=f(z)\).
</p>

<p>
Recall that \(\sum_{y=0}^{n-1}\exp(-2\pi\ii ly/n)\) is \(n\) if \(l=nl'\) for some \(l'\) and \(0\)
otherwise (this follows directly from the formula for <a href="https://en.wikipedia.org/wiki/Geometric_series#Sum">geometric sums</a>, or abstractly from
the <a href="appendix_2.html#org7cdb0b6">orthogonality relations</a> of the irreducible characters).
</p>

<p>
Hence the summation over \(y\) directly yields \(\FT_Nf(l)=0\) if \(l\) is not a multiple of
\(n\). Hence in the following we assume that \(l=nl'\) for some \(l'\).
</p>

\begin{align*}
  \FT_N f(nl') &= \frac{n}{\sqrt{N}} \sum_{z=0}^{r-1} e^{-2\pi\ii l' z/r} f(x)
  = \sqrt{n} \FT_r f(l') .
\end{align*}

<p>
Let us summarize this. For \(l=nl'+m\) where \(0\leq m < n\) we have:
</p>

<p>
<a id="orgb4ce87d"></a>
\[
  \FT_Nf(nl'+m) = \begin{cases} \sqrt{n} \FT_rf(l') & \text{if } m=0 \\ 0 & \text{otherwise.} \end{cases}
\]
</p>

<p>
Note that the prefactor \(\sqrt{n}\) is nothing fundamental here. It depends on certain
conventions. For example it could be \(n\) if we would define the Fourier transform without
the \(1/\sqrt{N}\).
</p>
</div>
</div>

<div id="outline-container-orgee0dedf" class="outline-4">
<h4 id="orgee0dedf">Discussion</h4>
<div class="outline-text-4" id="text-orgee0dedf">
<p>
This result could easily be obtained without calculation. In fact, we know that the characters
</p>

<p>
\[
  \chi_l^N(x) = e^{-2\pi\ii lx/N} \text{ for } l \in \ZZ_N
\]
</p>

<p>
form an <a href="appendix_2.html#org7cdb0b6">orthonormal basis</a> of the class functions on \(\ZZ_N\). Since the group is Abelian,
every function \(\ZZ_N\to\CC\) is a class function (the conjugacy classes only contain
single elements in that case). If a function is \(r\)​-periodic this means that it is
actually a function on \(\ZZ_r\) and can be written as a sum of the irreducible characters
of \(\ZZ_r\). If \(N=nr\) is a multiple of \(r\) the characters of \(\ZZ_r\) are contained in the
characters of \(\ZZ_N\):
</p>

<p>
\[
  \chi_{l'}^r = \chi_{nl'}^N .
\]
</p>

<p>
This <i>essentially</i> explains <a href="#orgb4ce87d">the relation</a> between \(\FT_N\) and \(\FT_r\). The prefactor
\(\sqrt{n}\) can be explained by observing that the scalar products also have a prefactor
which is chosen in a way such that the characters have norm \(1\):
</p>

<p>
\[
  \langle \chi_l^r, \chi_k^r \rangle = \frac{1}{\sqrt{r}} \sum_{j\in\ZZ_r} \chi_l^r(j)^* \chi_k^r(j)
  = \delta_{lk} .
\]
</p>

<p>
Hence a scaling is necessary. Observe that this particular choice of scalar product with
the particular prefactor of the Fourier transform make the Fourier transform unitary.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-5-21" class="outline-3">
<h3 id="exercise-5-21">Exercise 5.21</h3>
<div class="outline-text-3" id="text-exercise-5-21">
<p>
Suppose you are given a unitary operator \(U_y\) which performs the transformation
\(U_y\ket{f(x)}=\ket{f(x+y)}\), for the periodic function described above.
</p>

<ol class="org-ol">
<li>Show that the eigenvectors of \(U_y\) are \(\ket{\hat{f}(l)}\), and calculate their
eigenvalues.</li>
<li>Show that given \(\ket{f(x_0)}\) for some \(x_0\), \(U_y\) can be used to realize a black box
which is as useful as \(U\) in solving the period-ﬁnding problem.</li>
</ol>


<dl class="org-dl">
<dt>Remark</dt><dd>It seems to me that \(U_y\) is intended to be a shift operator. But the
definition is a bit weird since \(f(x)\) can only take two values. For that reason the
formula \(U_y\ket{f(x)}=\ket{f(x+y)}\) does not make sense to me. So instead of giving a
solution (which I cannot) I explain in detail what I think is weird about this exercise.</dd>
</dl>
</div>

<div id="outline-container-org8f6a220" class="outline-4">
<h4 id="org8f6a220">Why I think the exercise is weird</h4>
<div class="outline-text-4" id="text-org8f6a220">
<p>
The formula \(U_y\ket{f(x)}=\ket{f(x+y)}\) looks odd to me. Note that \(f(x)\) is a function
which only takes two values \(0\) and \(1\). So for most functions \(f\) the formula cannot be
satisfied by any \(U_y\). For example, take the function defined on \(\{0,1,2,3,4\}\) which
maps these values to \(0,1,0,0,1\) in that order. The formula for \(y=1\) requires:
</p>

<p>
\[
  U_1\ket{0} = U_1 \ket{f(0)} = \ket{f(1)} = \ket{1} ,
\]
</p>

<p>
and on the other hand
</p>

<p>
\[
  U_1\ket{0} = U_1 \ket{f(2)} = \ket{f(3)} = \ket{0} ,
\]
</p>

<p>
which contradicts the first equation.
</p>

<p>
As I understand it \(U_y\) should be a shift operator. Which I would define like that
\((S_yf)(x)=f(x+y)\) (I call it \(S\) to make it possible to distinguish this from the
original definition). Note that I emphasize that \(S_y\) acts on the function \(f\) not on its
value \(f(x)\). So the contradiction above does not appear.
</p>

<p>
With \(S_y\) task (1) could be interpreted in a way which makes sense. But note that my
definition of \(S_y\) is <i>essentially</i> identical to the one given for \(U_k\) in Box 5.5 and
my interpretation of part (1) would lead to the shift-invariance property there. So I am
not sure if this is what was meant.
</p>

<p>
Task (2) makes even less sense to me. Let us set \(x_0=0\) for simplicity. The state
\(\ket{f(0)}\) does not contain any information on \(f(x)\) except for \(x=0\) (the function
could be completely random). So \(U_y\) must contain the full information on \(f(x)\) for any
\(x\) with the possible exception of \(x=0\). So it makes sense to define it not only on the
second register, but also on the first one - like \(U\).
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-5-22" class="outline-3">
<h3 id="exercise-5-22">Exercise 5.22</h3>
<div class="outline-text-3" id="text-exercise-5-22">
<p>
Let \(f(x_1,x_2)=a^{sx_1+x_2}\mod N\) and let \(r\) be the order of \(a\) with respect to
\(N\) (i.e. in the group \(\ZZ_N\)). Show that
</p>

<p>
<a id="orga36d0cb"></a>
\[
  \ket{\hat{f}(l_1,l_2)} = \frac{1}{r} \sum_{x_1=0}^{r-1} \sum_{x_2=0}^{r-1}
    e^{-2\pi\ii(l_1x_1+l_2x_2)/r} \ket{f(x_1,x_2)}
  = \sum_{j=0}^{r-1} e^{-2\pi\ii l_2 j/r} \ket{f(0,j)} .
\]
</p>

<p>
for \(l_1=sl_2\mod r\) and \(\ket{\hat{f}(l_1,l_2)}=0\) otherwise.
</p>

<dl class="org-dl">
<dt>Remarks</dt><dd><ul class="org-ul">
<li>We corrected wrong factors in front of the sums and cleaned up the formulation.</li>
<li><p>
I do not know if it is just me but I regularly get confused by the notation. Therefore
let me note a subtle thing about it - for those who feel the same. What do
\(\ket{f(x)}\) and \(\ket{\hat{f}(l)}\) mean? For the former this is easy. In fact, if
e.g. \(f(x)=5\) then \(\ket{f(x)}\) is \(\ket{5}\). In other words it is \(\ket{101}\) in a
register with three qubits with respect to the standard basis.
</p>

<p>
For the latter the interpretation is different! In fact, \(\hat{f}\) a priori does not
even make sense without the ket. In particular it is <i>not</i> the Fourier transform of
\(f\). Note that \(f:G\to\ZZ_r\) for some group \(G\), while we only ever calculate the
Fourier transform of functions \(G\to\CC\) (or \(G\to\CC^k\) for some \(k\) by
component-wise application of \(k\) Fourier transforms). Instead the <i>whole thing</i>
really is defined by this:
</p>

<p>
\[
      \ket{\hat{f}(l)} := \frac{1}{\sqrt{r}} \sum_{j\in \ZZ_r} e^{-2\pi\ii lj/r} \ket{f(j)}
      = \FT_{\ZZ_r} [j \mapsto\ket{f(j)}](l) ,
    \]
</p>

<p>
for the Group \(G=\ZZ_r\) and similarly for other Abelian groups like
\(\ZZ_{r_1}\times\ZZ_{r_2}\).
</p></li>
</ul></dd>
</dl>
</div>

<div id="outline-container-org9fba67b" class="outline-4">
<h4 id="org9fba67b">Proof</h4>
<div class="outline-text-4" id="text-org9fba67b">
<p>
As a first step we change the summation indices; replacing \(x_2\) by \(j=sx_1+x_2\mod r\)
(<i>change of variables</i> - as it would be called in integration theory):
</p>

<p>
\[
  \ket{\hat{f}(l_1,l_2)} = \frac{1}{r} \sum_{x_1=0}^{r-1} \sum_{j=0}^{r-1}
    e^{-2\pi\ii(l_2 j + (l_1-sl_2)x_1)/r} \ket{f(0,j)}
\]
</p>

<p>
Note that the summation over \(x_1\) <a href="appendix_2.html#orgfe8246a">leads to</a> \(\ket{\hat{f}(l_1,l_2)}=0\) if \(l_1\neq sl_1\). For
\(l_1=sl_2\) we get
</p>

<p>
<a id="orgae89551"></a>
\[
  \ket{\hat{f}(sl_2,l_2)} = \sum_{j=0}^{r-1} e^{-2\pi\ii l_2 j/r} \ket{f(0,j)} .
\]
</p>

<p>
QED.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>\(K=\{(x_1, x_2) \in \ZZ_N\otimes \ZZ_N; sx_1 + x_2 = 0\}\) is a subgroup on which \(f\) is
invariant. Note how the <a href="#orgae89551">result</a> resembles a <a href="appendix_2.html#org9bb6d68">formula</a> obtained in the appendix.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-exercise-5-23" class="outline-3">
<h3 id="exercise-5-23">Exercise 5.23</h3>
<div class="outline-text-3" id="text-exercise-5-23">
<p>
Assume that \(f\) is as in <a href="#exercise-5-22">exercise 5.22</a>. Compute
</p>

<p>
<a id="org4229b88"></a>
\[
  \frac{1}{r} \sum_{l_1=0}^{r-1} \sum_{l_2=0}^{r-1} e^{2\pi\ii(l_1x_1+l_2x_2)/r} \ket{\hat{f}(l_1,l_2)}
\]
</p>

<p>
and show that the result is \(\ket{f(x_1,x_2)}\).
</p>

<dl class="org-dl">
<dt>Remarks</dt><dd><ul class="org-ul">
<li>We corrected a sign error in the formula <a href="#org4229b88">above</a>. The error probably arised because the
book is a bit incosistent on whether the Fourier transform goes with
\(\exp(+2\pi\ii\ldots)\) or \(\exp(-2\pi\ii\ldots)\). But \(\hat{f}\) was defined with a
minus sign (in this case) hence we need a plus sign here.</li>
<li>Moreover, we corrected that the result is \(\ket{f(x_1,x_2)}\) not \(f(x_1,x_2)\). The
former is a function \(\ZZ_r\otimes\ZZ_r\to\CC^{2^n}\) while the latter is a function
\(\ZZ_r\otimes\ZZ_r\to\ZZ_N\). Here \(n\) is just size of the third register in the
discrete-logarithm algorithm (large enough to enable arithmetic modulo \(N\)).</li>
</ul></dd>
</dl>
</div>

<div id="outline-container-org734f248" class="outline-4">
<h4 id="org734f248">Proof 1</h4>
<div class="outline-text-4" id="text-org734f248">
<p>
In this part we only assume that \(\ket{\hat{f}}\) is the Fourier transform of <i>some</i>
function \(\ket{f}:\ZZ_r\times\ZZ_r\to\CC^k\) (some \(k\)). In fact, this is easier than in
the <a href="#exercise-5-23-proof-2">second proof</a> where we assume more about \(f\).
</p>

<p>
Let us write \(x\cdot l = \sum_i x_i l_i\). Then
</p>

<p>
\[
  \frac{1}{r} \sum_l e^{2\pi\ii l\cdot x/r} \ket{\hat{f}(l)}
  = \frac{1}{r^2} \sum_{l,y} e^{2\pi\ii l\cdot (x-y)/r} \ket{f(y)} .
\]
</p>

<p>
If \(x\neq y\) then the summation over \(l_1\) or the summation over \(l_2\) (or both) leads to
zero (by the <a href="appendix_2.html#orgfe8246a">orthonormality relation</a>). Hence we obtain
</p>

<p>
\[
  \frac{1}{r} \sum_{y} \delta_{x,y} \ket{f(y)} = \ket{f(x)} .
\]
</p>

<p>
QED.
</p>
</div>
</div>

<div id="outline-container-exercise-5-23-proof-2" class="outline-4">
<h4 id="exercise-5-23-proof-2">Proof 2</h4>
<div class="outline-text-4" id="text-exercise-5-23-proof-2">
<p>
Let us directly verify the result using the RHS of the <a href="#orga36d0cb">formula</a> from <a href="#exercise-5-22">exercise 5.22</a>. The
main benefit of doing this is to provide a little bit more confidence into the (IMO) slightly
unintuitive pre-factor in the RHS of said formula.
</p>

\begin{align*}
  \frac{1}{r} \sum_l e^{2\pi\ii l\cdot x/r} \ket{\hat{f}(l)}
  &= \frac{1}{r} \sum_{l_2} e^{2\pi\ii x\cdot(sl_2,l_2)/r} \ket{\hat{f}(sl_2,l_2)} \\
  &= \frac{1}{r} \sum_{l_2,j} e^{2\pi\ii l_2(sx_1+x_2-j)/r} \ket{f(0,j)} \\
  &= \sum_{j} \delta_{j,sx_1+x_2} \ket{f(0,j)} \\
  &= f(x_1,x_2) .
\end{align*}

<p>
In the first equality we use that \(\ket{\hat{f}}\) non-zero only at \((sl_2,l_2)\). In the
third equality we used the <a href="appendix_2.html#orgfe8246a">orthonormality relation</a>. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-5-24" class="outline-3">
<h3 id="exercise-5-24">Exercise 5.24</h3>
<div class="outline-text-3" id="text-exercise-5-24">
<p>
Construct the generalized continued fractions algorithm needed in step 6 of the discrete
logarithm algorithm to determine \(s\) from estimates of \(sl_2/r\) and \(l_2/r\).
</p>
</div>

<div id="outline-container-orgbf8d709" class="outline-4">
<h4 id="orgbf8d709">Solution</h4>
<div class="outline-text-4" id="text-orgbf8d709">
<p>
First of all, I am not sure what is meant by "generalized continued fraction algorithm" in
<i>this</i> context. We do not need any clever idea here - if I do not overlook something here.
</p>

<p>
Recall that the number \(t\) of bits to hold the two estimates satisfies
\(O(\log(r)+\log(1/\varepsilon))\). This guarantees that the errors in the two estimates
are \(O(r^{-C})\) with probability \(1-O(\varepsilon)\). The constant \(C>0\) can be chosen as
large as necessary. See chapter 5.2.1 on the accuracy of the Fourier transform.
</p>

<p>
Hence we may assume that with probability \(1-O(\varepsilon)\) we get <i>exact</i> values for:
</p>

<p>
\[
  sl_2 \mod r = (\widetilde{sl_2/r}) \cdot r \quad \text{ and } \quad l_2 \mod r = (\widetilde{l_2/r}) \cdot r .
\]
</p>

<p>
Note that we know \(r\) and that both numbers are integers so an error in the estimates
below, say, \(r/3\) is sufficient. Hence \(s\) can be calculated from
</p>

<p>
<a id="orgefd8b77"></a>
\[
  s = (sl_2) \cdot l_2\inv \mod r .
\]
</p>

<p>
The inverse of \(l_2\) modulo \(r\) can be calculated e.g. by euclidean algorithm. But <b>there
is a catch</b>. For this to work we need \(l_2\) to be invertible modulo \(r\). In other words
\(l_2\) must be coprime with \(r\). The worst case would be \(l_2=0\) which gives us precisely no
information on \(s\) and lets the algorithm fail.
</p>

<p>
What is the probability of \(l_2\) being coprime? First of all note that every
\(l_2\in\{0,\ldots,r-1\}\) is obtained with equal probability. This is a consequence of the
<a href="#orga36d0cb">formula</a> for the Fourier coefficients (and that \(f(0,j)=a^j\) is different for each
\(j\in\{0,\ldots,r-1\}\)).
</p>

<p>
Hence the probability \(P\) that \(l_2\) is coprime with \(r\) can be found by using Euler's totient
function \(\varphi\) which counts the coprime numbers:
</p>

<p>
\[
  P = \varphi(r) / r = \prod_i (1 - p_i\inv) .
\]
</p>

<p>
The product ranges over all primes occurring in \(r\). The worst case happens when the
number \(r\) is large and contains the first primes (something like
\(r=2\cdot3\cdot5\cdot7\cdot\ldots\)). The power of each prime does not matter for \(P\).
</p>

<p>
Unfortunately the product on the RHS extended to <i>all</i> primes converges to zero. It equals
\(1/\zeta(1)=0\) by the way, where \(\zeta\) denotes <a href="https://en.wikipedia.org/wiki/Riemann_zeta_function">Riemann's zeta</a> function. Hence we cannot
give a (positive) lower bound on \(P\) which is not dependent on \(r\).
</p>

<p>
On the other hand we can repeat the steps 1 to 5 several times to get, say, \(n\) samples
for \(l_2\). For each sample we calculate \(\gcd(l_2,r)\) and define \(r'\) by
\(r=\gcd(l_2,r)r'\). Instead of the <a href="#orgefd8b77">original equation</a> for \(s\) we solve (each time)
</p>

<p>
\[
  s = (sl_2) \cdot l_2\inv \mod r' .
\]
</p>

<p>
This procedure ends if we have sufficiently many samples \(l_2\) so that their common gcd
with \(r\) is \(1\). In other words, none of the primes contained in \(r\) divides <i>all</i> of the
samples of \(l_2\). To see that this suffices let us for simplicity assume that the
procedure terminates with the second repetition. We got \(s\mod r'_i\) for \(i=1,2\) with
\(\mathrm{lcd}(r'_1,r'_2)=r\). We can replace \(r'_2\) with \(r'_2/\gcd(r'_1,r'_2)\) to be in
the setting of the <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese remainder theorem</a> which yields \(s\mod r\).
</p>

<p>
Clearly the probability that <i>not</i> all samples are divisible by a particular prime \(p_i\)
is
</p>

<p>
\[
  (1 - p_i^{-n})
\]
</p>

<p>
if \(n\) is the number of samples. It is natural to conjecture that the probability \(P_n\)
that this is true for all primes of \(r\) is:
</p>

<p>
<a id="orgea4a424"></a>
\[
  P_n = \prod_{i}(1 - p_i^{-n}) ,
\]
</p>

<p>
where the product ranges over the primes of \(r\). This would be nice because for \(n\geq2\)
we get a positive lower bound for \(P_n\) which is independent of \(r\):
</p>

<p>
<a id="orgfa8f340"></a>
\[
  P_n \geq \frac{1}{\zeta(n)} = 1 - O(2^{-n}) .
\]
</p>

<p>
To see the asymptotic behavior just use the standard formula
\(\zeta(n)=\sum_{k=1}^\infty\,k^{-n}\). To see that the product in <a href="#orgea4a424">the formula</a> for \(P_n\) is
correct it suffices to show the following: Consider the random variables (one for each
prime in \(r\))
</p>

<p>
\[
  x_i = l_2 \mod p_i
\]
</p>

<p>
then these random variables are <a href="https://en.wikipedia.org/wiki/Independence_(probability_theory)">stochastically independent</a>. This in turn follows from
</p>

<p>
\[
  \mathrm{Prob}(x_1 = a_1) = \mathrm{Prob}(x_1 = a_1 | x_2 = a_2, \ldots)
\]
</p>

<p>
and its analogous formulas with \(x_1\) replaced by the other \(x_j\). The RHS is a
<a href="https://en.wikipedia.org/wiki/Conditional_probability">conditional probability</a>. This in turn follows from the <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese remainder
theorem</a>. Especially the formulation in terms of a ring-isomorphism
\(\ZZ_{\prod_ip_i}\to\bigoplus_i\ZZ_{p_i}\) makes it apparent.
</p>

<p>
The <a href="#orgfa8f340">lower bound</a> for \(P_n\) shows that a finite number of repetitions suffices to get an
arbitrarily high success probability.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf5e50e8" class="outline-3">
<h3 id="orgf5e50e8">Exercise 5.25</h3>
<div class="outline-text-3" id="text-orgf5e50e8">
<p>
Construct a quantum circuit for the black box \(U\) used in the quantum discrete logarithm
algorithm, which takes \(a\) and \(b\) as parameters, and performs the unitary transform
\(\ket{x_1,x_2,y}\mapsto\ket{x_1,x_2,y\,\oplus\,b^{x_1}a^{x_2}}\). How many elementary
operations are required?
</p>
</div>

<div id="outline-container-orge7bab37" class="outline-4">
<h4 id="orge7bab37">Solution</h4>
<div class="outline-text-4" id="text-orge7bab37">
<p>
Recall that in the chapter on order finding we have seen that there is a circuit using
\(O(L^3)\) gates which performs:
</p>

<p>
\[
  V_a: \ket{x,y} \mapsto \ket{a^x y \mod N} .
\]
</p>

<p>
Here \(L=O(\log(N))\) is the register size. Using \(V_a\) it is not hard to construct a
circuit performing
</p>

<p>
\[
  W_{b,a}: \ket{x_1,x_2,y} \mapsto \ket{x_1,x_2, b^{x_1} a^{x_2} y \mod N} .
\]
</p>

<p>
In fact:
</p>

<p>
\[
  \ket{x_1,x_2,y}
  \stackrel{V_a(2,3)}{\mapsto} \ket{x_1,x_2, a^{x_2} y \mod N} .
  \stackrel{V_b(1,3)}{\mapsto} \ket{x_1,x_2, b^{x_1} a^{x_2} y \mod N} .
\]
</p>

<p>
Note that this operation is already sufficient for the discrete-logarithm algorithm if the
third register is initialized to \(\ket{1}\) and not to \(\ket{0}\).
</p>

<p>
Using \(W_{b,a}\) and one ancilla register we can implement the desired operation.
</p>

\begin{align*}
  \ket{x_1,x_2,y,1}
  &\stackrel{W_{b,a}(1,2,4)}{\mapsto} \ket{x_1,x_2, y, b^{x_1} a^{x_2} \mod N} \\
  &\stackrel{\mathrm{XOR}(4,3)}{\mapsto} \ket{x_1,x_2, y \oplus b^{x_1} a^{x_2}, b^{x_1} a^{x_2} \mod N} \\
  &\stackrel{W_{b,a}(1,2,4)^\dagger}{\mapsto} \ket{x_1,x_2, y \oplus b^{x_1} a^{x_2}, 1} .
\end{align*}

<p>
The last operation just uncomputes the value in the ancilla register. The <code>XOR</code> can be
easily implemented using \(L\) controlled <code>NOT</code> gates.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-5-26" class="outline-3">
<h3 id="exercise-5-26">Exercise 5.26</h3>
<div class="outline-text-3" id="text-exercise-5-26">
<p>
Since \(K\) is a subgroup of \(G\), when we decompose \(G\) into a product of cyclic groups of
prime power order, this also decomposes \(K\). Re-express (5.77) to show that determining
\(l'_i\) allows one to sample from the corresponding cyclic subgroup \(K_{p_i}\) of \(K\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>I am not sure if I correctly understand the exercise but I think it is wrong.</dd>
</dl>
</div>

<div id="outline-container-org340c7a7" class="outline-4">
<h4 id="org340c7a7">Justification of the remark</h4>
<div class="outline-text-4" id="text-org340c7a7">
<p>
In general just looking at an <i>individual</i> \(l_i\) does not necessarily contain any useful
information. Let us consider a simple example.
</p>

<p>
Let \(n > 1\), \(G=\ZZ_2^n\) and let \(e=(1,1,\ldots,1)\in G\) be the all ones bit-string. Let
\(K=\langle\,e\,\rangle\). Clearly \(K\cong\ZZ_2\), so we already see that the decomposition
of \(K\) does not correspond "component-wise" to the decomposition of \(G\). Moreover we have:
</p>

<p>
\[
  K^\perp = \{ l\in G| \sum_i l_ie_i = 0 \mod 2 \} = \{l| l \text{ has an even number of ones}\} .
\]
</p>

<p>
The notion of the <a href="appendix_2.html#section-dual-subgroup">dual subgroup</a> was introduced in appendix 2 (from <i>this</i> website) and
also used in the <a href="#exercise-5.28-solution">solution of exercise 5.28</a>. It contains the non-zero Fourier coefficients
of the functions \(f\) appearing in the hidden subgroup problem. It is also shown that each
\(l\in\,K^\perp\) is measured with the same probability (this follows from the fact that \(f\)
is different on each coset).
</p>

<p>
Note that the characterization of \(l\in K^\perp\) is a <i>global</i> property. For a fixed \(i\)
the \(l_i\) can take any possible value, \(0\) or \(1\). In case of even \(n\) the probability is
exactly \(1/2\) for each possibility. To understand that this is <i>really</i> not useful observe
that for \(K=0\) (implying \(K^\perp=G\)) we get the <i>exact</i> same statistical behavior (for
even \(n\)) if we just look at individual \(l_i\) in isolation.
</p>
</div>
</div>
</div>

<div id="outline-container-org84c6624" class="outline-3">
<h3 id="org84c6624"><span class="todo WIP">WIP</span> Exercise 5.27</h3>
<div class="outline-text-3" id="text-org84c6624">
<p>
Of course, the decomposition of a general ﬁnite Abelian group \(G\) into a product of cyclic
groups of prime power order is usually a difficult problem (at least as hard as factoring
integers, for example). Here, quantum algorithms come to the rescue again: explain how the
algorithms in this chapter can be used to efficiently decompose \(G\) as desired.
</p>
</div>

<div id="outline-container-org69a9357" class="outline-4">
<h4 id="org69a9357">Some thoughts</h4>
<div class="outline-text-4" id="text-org69a9357">
<p>
First of all, the <a href="#exercise-5.28-solution">solution of exercise 5.28</a> shows that we do not really need to have a
decomposition into groups of prime power order. It is sufficient to have a decomposition
</p>

<p>
<a id="orgef43c1f"></a>
\[
  G = \bigoplus_{i=1}^n \ZZ_{r_i} ,
\]
</p>

<p>
with <i>some</i> numbers \(r_i\).
</p>

<p>
On the other hand, if we really want to have prime powers (for whatever reason) Shor's
algorithm is sufficient to efficiently find such a decomposition - provided we already
have a decomposition into cyclic groups as <a href="#orgef43c1f">above</a>. Let us briefly justify why. Because of
\(\ZZ_{mn}\cong\ZZ_m\oplus\ZZ_n\) for <i>coprime</i> \(m\) and \(n\) (and the fact that this isomorphism
can be efficiently computed in either direction) it is sufficient to find all prime
factors of all the \(r_i\).
</p>

<p>
To find all prime factors of \(r_i\) do the following. Apply the factoring algorithm to
\(r_i\). This yields a non-trivial factor \(f_i\). Hence we obtain a decomposition into
\(r_i=f_i\cdot(r_i/f_i)\). Now recursively apply the factoring algorithm to each factor
(probabilities are discussed in the next paragraph). We stop if the no non-trivial factor
could be returned. Overall we need at most \(2\log_2(r_i)\) applications of the factoring
algorithm since each \(r_i\) has at most \(\log_2(r_i)\) factors.
</p>

<p>
We have to ensure that for some small \(\varepsilon>0\) the factoring algorithm succeeds
with probability \(1-\varepsilon\). Luckily this is possible for any \(\varepsilon\) (the
algorithm in section 5.3.2 only needs to be repeated a number of times which only depends
on \(\varepsilon\)). The overall success probability for a single \(r_i\) is at least
\(1-2\varepsilon\log_2(r_i)\). For all \(r_i\) simultaneously the probability is at least
\(1-2\varepsilon\log_2(r)\) (use \((1-x)(1-y)\geq1-x-y\) to see this).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>In general a group might not be represented as a direct sum of cyclic
groups. Unfortunately I do not know what representations occur in the wild (and are
interesting at the same time). So I have to leave open the discussion of those
representations for now.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-exercise-5-28" class="outline-3">
<h3 id="exercise-5-28">Exercise 5.28</h3>
<div class="outline-text-3" id="text-exercise-5-28">
<p>
Write out a detailed specification of the quantum algorithm to solve the hidden subgroup
problem, complete with runtime and success probability estimates, for ﬁnite Abelian
groups.
</p>
</div>

<div id="outline-container-exercise-5.28-solution" class="outline-4">
<h4 id="exercise-5.28-solution">Solution</h4>
<div class="outline-text-4" id="text-exercise-5.28-solution">
<p>
In the following \(f:G\to Y\) is a function from a finite abelian group \(G\) to a (finite)
set \(Y\). Let \(K\) be a subgroup of \(G\) and assume that the restrictions of \(f\) to any of
the cosets of \(K\) are constant. Hence the function can be regarded as defined on the
quotient group \(G/K\). Moreover we assume that \(f:G/K\to Y\) is injective.
</p>

<p>
We assume that \(G\) is already represented as a decomposition:
</p>

<p>
\[
  G = \bigoplus_{i=1}^n \ZZ_{r_i} .
\]
</p>

<p>
We do <i>not</i> require that the \(r_i\) are powers of primes. This decomposition also fixes an
<a href="appendix_2.html#orgbc05c73">isomorphism</a> \(G\to\hat{G},\;l\mapsto\chi_l\),
</p>

<p>
\[
  \chi_l(g) = e^{2\pi\ii \sum_{j=1}^n g_jl_j/r_j} .
\]
</p>

<p>
Finally we assume that there is a binary operation \(\oplus\) on \(Y\) with a left-neutral
element \(0\in Y\), i.e. \(0\oplus y=y\) for all \(y\).
</p>

<dl class="org-dl">
<dt>Algorithm (for the hidden subgroup problem)</dt><dd><dl class="org-dl">
<dt>Inputs</dt><dd><ol class="org-ol">
<li>\(n\) register of differing sizes \(t_i=O(m_j+\log(n/\varepsilon))\) with
\(m_j=O(\log(r_j))\). One register of size \(N\) for the function evaluation (probably
\(N=O(\log(\abs{Y}))\), but this naturally depends on the black box \(U\) mentioned
below). Let \(t=\sum_it_i\).</li>
<li>A black box \(U\) which performs the operation
\[
       \bigotimes_{i=1}^n \ket{x_i} \otimes \ket{y}
       \mapsto \bigotimes_{i=1}^n \ket{x_i} \otimes \ket{y \oplus f(x)} ,
       \]</li>
</ol></dd>
<dt>Outputs</dt><dd>A generating set for the hidden subgroup \(K\) with probability \(1-\varepsilon\).</dd>
<dt>Runtime</dt><dd><p>
Overall
</p>

<p>
\[ J = O(\log(\abs{G})(\log(\log(\abs{G}))+\log(1/\varepsilon))) \]
</p>

<p>
uses of the black box \(U\) and for each repetition \(O(\sum_i t_i^2)\) quantum gates for
other quantum operations (mostly Fourier transforms). Among the classical post
processing the smith decomposition is probably the most heavyweight which probably
needs \(O(J^3)\) operations (I did not check this, but I would be surprised if it is not
true).
</p></dd>
<dt>Procedure</dt><dd><ol class="org-ol">
<li>Initialization to \(\ket{0}\) (all registers).</li>

<li>Perform a Hadamard transform \(H^{\otimes t}\) on the first \(n\) registers to obtain:
\[
       \rightarrow \frac{1}{\sqrt{2^t}} \sum_{x\in\{0,1\}^t} \ket{x} \ket{0}
       \]</li>

<li><p>
Apply \(U\):
</p>

\begin{align*}
  \rightarrow \frac{1}{\sqrt{2^t}} \sum_x \ket{x} \ket{f(x)}
  &= \frac{1}{\sqrt{2^t}} \sum_x \ket{x} \frac{1}{\sqrt{\abs{G}}}  \sum_{l\in G} \chi_l(-x) \ket{\hat{f}(l)} \\
  &= \frac{1}{\sqrt{\abs{G}}} \sum_{l\in G} \left(\frac{1}{\sqrt{2^t}}\sum_{x} \chi_l(-x) \ket{x} \right) \ket{\hat{f}(l)} \\
  &= \frac{1}{\sqrt{\abs{G}}} \sum_{l\in G} \bigotimes_{j=1}^n \left(\frac{1}{\sqrt{2^{t_j}}}\sum_{x_j=0}^{2^{t_j}-1} e^{-2\pi\ii x_jl_j/r_j} \ket{x_j} \right) \ket{\hat{f}(l)}
\end{align*}

<p>
In the first equality we use the <a href="appendix_2.html#section-fourier-abelian-groups">Fourier representation</a> of the function
\(x\mapsto\ket{f(x)}\). This makes sense because we can interpret \(x\) as an element
of \(G\) by identifying \(x_i\) with \(x_i\mod r_i\).
</p></li>

<li><p>
Apply the inverse Fourier transform of \(\bigoplus_{i=1}^n\ZZ_{2^{t_i}}\) (<i>not</i> \(G\)) to the
first \(n\) registers:
</p>

<p>
\[
       \rightarrow \frac{1}{\sqrt{\abs{G}}} \sum_{l\in G} \bigotimes_{j=1}^n \ket{\widetilde{l_j/r_j}} \ket{\hat{f}(l)}
       \]
</p>

<p>
<a href="appendix_2.html#orgcba566c">That is</a>, we apply the standard inverse Fourier transform on each
register. According to chapter 5.2.1 for a given \(l\) the \(\widetilde{l_j/r_j}\) are
\(m_j\) bit approximations of \(l_j/r_j\) with probability \(1-O(\varepsilon/n)\)
(each). Hence all of them are good approximations <i>simultaneously</i> with probability
\(1-O(\varepsilon)\).
</p></li>

<li>Measure the first \(n\) registers, and recover \(l\) from the
\(\widetilde{l_j/r_j}\). This works with certainty (provided step 4 worked out as
desired) if \(m_j=O(\log(r_j))\) is large enough. In fact, recall that we already
know \(r_j\). Hence we just need \(2^{-m_j}\leq\,r_j/2\) to make that work.</li>

<li><p>
Repeat steps 1 to 5 to obtain
</p>

<p>
\[ J = O(\log(\abs{G})(\log(\log(\abs{G}))+\log(1/\varepsilon))) \]
</p>

<p>
samples \(l^{(1)},\ldots,l^{(J)}\) for \(l\).
</p></li>

<li><p>
Let \(r=\mathrm{lcd}(r_1,\ldots,r_n)\), \(s_i=r/r_i\) and find solutions
\(k^{(1)},\ldots,k^{(n)}\) of
</p>

<p>
\[
         \sum_{i=1}^n s_i l_i^{(j)} k_i = 0 \mod r \text{ for } j \in \{1,\ldots,J\} .
       \]
</p>

<p>
as described in <a href="appendix_2.html#orgb42b6b9">appendix 2</a>. These solutions are a (not necessarily minimal)
generating set (with a probability as specified in the runtime section).
</p></li>
</ol></dd>
</dl></dd>
</dl>

<p>
Let us justify why this works.
</p>

<p>
The \(l\) which we obtain in step 5 are not arbitrary. Recall that the Fourier transform
looks like this:
</p>

<p>
\[
  \ket{\hat{f}(l)} = \frac{1}{\sqrt{\abs{G}}} \sum_{g\in G} \chi_l(g) \ket{f(g)} .
\]
</p>

<p>
From the <a href="appendix_2.html#org2115ca8">basic theorem</a> on dual subgroups (appendix 2) we see that \(\ket{\hat{f}(l)}\) is
zero for \(l\notin\,K^\perp\). But we can show more! In fact, \(f\) is not only constant on
cosets of \(K\) it is even injective. This implies that the \(\ket{f(g)}\) for \(g\in G\) form an
orthonormal set. To put this into use, let us assume that \(h\in\,K^\perp\) and use that
then \(\chi_h\) is constant on cosets too.
</p>

<p>
\[
  \ket{\hat{f}(h)} = \frac{1}{\sqrt{\abs{G}}} \sum_{q\in G/K} \sum_{k\in K} \chi_h(q) \ket{f(q)}
  = \frac{\abs{K}}{\sqrt{\abs{G}}} \sum_{q\in G/K} \chi_h(q) \ket{f(q)}.
\]
</p>

<p>
Note that this is (up to a factor) just the Fourier transform on \(G/K\). We did not use
injectivity so far. But injectivity implies that \(\norm{\ket{\hat{f}(l)}}^2=\abs{K}\). To summarize:
</p>

<p>
\[
  \norm{\ket{\hat{f}(l)}}^2 = \begin{cases}
    \abs{K} & \text{if } l \in K^\perp \\
    0 & \text{otherwise.} \end{cases}
\]
</p>

<p>
This implies that in step 5 we sample \(l\) from \(K^\perp\) with <i>uniform</i> probability
distribution (uniformity is important as we will see later on).
</p>

<p>
In <a href="appendix_2.html#orgb42b6b9">appendix 2</a> we proved that step 7 indeed yields a generating set for \(K\) <b>if</b> the
\(l^{(j)}\) generate \(K^\perp\). Thus the final question is with what probability this
happens. Let us first prove a Lemma.
</p>

<p>
Recall that any finite abelian group \(G\) can be decomposed as
\(\bigoplus_{i=1}^n\ZZ_{p_{i}^{r_i}}\) with prime numbers \(p_i\) (not necessarily all
distinct). The primes and their exponents are unique. Hence \(\kappa(G):=n\) is
well-defined. Note that \(\kappa(G)=O(\log(\abs{G}))\).
</p>

<p>
<a id="org3bb2346"></a>
</p>
<dl class="org-dl">
<dt>Lemma</dt><dd>Let \(G\) be a finite abelian group and let \(n=\kappa(G)\). The probability that
\(mn\) elements of \(G\) which are chosen <i>uniformly</i> at random are a generating set is at
least \(1-n2^{-m}\).</dd>
<dt>Proof</dt><dd><p>
Let us define \(P(G,j)\) as the probability that \(j+\kappa(G)\) randomly chosen elements
generate \(G\). We have
</p>

<p>
\[
    P(\ZZ_{p^r}\oplus G, j + m) \geq (1 - 1/p^m) P(G, j) .
  \]
</p>

<p>
Let us justify this. We sample the first \(j+\kappa(G)\) elements and hope that it,
projected to \(G\), generates \(G\) (probability \(P(G,j)\)). Then we take \(m\) additional
elements and hope that their projection to \(\ZZ_{p^r}\) hits a number, which is not
divisible by \(p\), at least once (probability at least \(1-1/p^m\)). If both happens we get
a generating set for \(\ZZ_{p^r}\oplus G\). This appears to be a terrible way to estimate
the probabilities but it serves the purpose 👍.
</p>

<p>
As a special case of the above reasoning we get
</p>

<p>
\[
    P(\ZZ_{p^r}, m) \geq 1 - 1/p^m .
  \]
</p>

<p>
Induction on \(n=\kappa(G)\), using that \(2\) is the smallest prime, yields
</p>

<p>
\[
    P(G,mn)\geq (1 - 1/2^m)^n .
  \]
</p>

<p>
The claim now follows from \((1-x)^n\geq1-nx\) (use mathematical induction to see
this simple inequality). QED.
</p></dd>
</dl>

<p>
To have a success probability of \(1-O(\varepsilon)\) in the context of the lemma we thus
need to set
</p>

<p>
\[
  m = O(\log(n)+\log(1/\varepsilon)) = O(\log(\log(\abs{G}))+\log(1/\varepsilon))
\]
</p>

<p>
This explains the choice of \(J\) in step 6 and concludes the justification that the
algorithm works as specified.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf53b794" class="outline-3">
<h3 id="orgf53b794">Exercise 5.29</h3>
<div class="outline-text-3" id="text-orgf53b794">
<p>
Give quantum algorithms to solve the Deutsch and Simon problems listed in Figure 5.5,
using the framework of the hidden subgroup problem.
</p>
</div>

<div id="outline-container-orgba82b20" class="outline-4">
<h4 id="orgba82b20">Solution for Deutsch's problem</h4>
<div class="outline-text-4" id="text-orgba82b20">
<p>
Let us briefly recall Deutsch's problem.
</p>

<p>
Let \(G=\ZZ_2\) and consider a function \(f:G\to X=\ZZ_2\). There are two cases
</p>

<dl class="org-dl">
<dt>Constant</dt><dd>\(f\equiv\mathrm{const}\) (hidden subgroup \(K=G\)).</dd>
<dt>Balanced</dt><dd>\(f(0)\neq f(1)\) (hidden subgroup \(K=0\)).</dd>
</dl>

<p>
The task is to find out to which case a given \(f\) belongs. Of course this problem is
really boring (there are only four possible functions \(f\)), but the more general
Deutsch-Josza problem does <i>not apriori</i> fit into the hidden-subgroup framework. But
please also read the <a href="#orgc31aaec">remarks</a> at the end.
</p>

<dl class="org-dl">
<dt>Algorithm (for Deutsch's problem)</dt><dd><dl class="org-dl">
<dt>Inputs</dt><dd><ol class="org-ol">
<li>Two register, each with one qubit.</li>
<li>A black box \(U\) performing \(\ket{x,y}\mapsto\ket{x,y\oplus f(x)}\).</li>
</ol></dd>
<dt>Outputs</dt><dd>The case (<i>constant</i> or <i>balanced</i>) to which \(f\) belongs.</dd>
<dt>Runtime</dt><dd>One application of \(U\) (per repetition). The constant case is always correctly
inferred. The balanced case is correctly inferred with probability \(1/2\). Repeating the algorithm
\(n\) times increases the success probability in the balanced case to \(1-2^{-n}\) since measuring
\(m=1\) once in step 5 already ensures certainty.</dd>
<dt>Procedure</dt><dd><ol class="org-ol">
<li>Initialize both register to zero: \(\ket{0}\ket{0}\).</li>
<li><p>
Perform the Hadamard gate \(H\) on the first register
</p>

<p>
\[ \rightarrow \frac{1}{\sqrt{2}} \sum_{x=0}^1 \ket{x}\ket{0} \]
</p></li>
<li><p>
Apply \(U\):
</p>

\begin{align*}
\rightarrow \frac{1}{\sqrt{2}} \sum_{x=0}^1 \ket{x}\ket{f(x)}
&= \frac{1}{\sqrt{2}} \sum_{x=0}^1 \ket{x} \frac{1}{\sqrt{2}} \sum_{l=0}^1 (-1)^{xl} \ket{\hat{f}(l)} \\
&= \frac{1}{\sqrt{2}} \sum_{l=0}^1 \left(\frac{1}{\sqrt{2}} \sum_{x=0}^1 (-1)^{xl} \ket{x} \right) \ket{\hat{f}(l)} \\
&= \frac{1}{\sqrt{2}} \sum_{l=0}^1 H\ket{l} \ket{\hat{f}(l)} .
\end{align*}</li>
<li>Apply the Hadamard gate \(H\) to the first register (again):
\[ \rightarrow \frac{1}{\sqrt{2}} \sum_{l=0}^1 \ket{l} \ket{\hat{f}(l)} \]</li>
<li>Measure the first register and obtain \(m=0\) or \(m=1\).</li>
<li>Upon \(m=0\) return "constant" otherwise return "balanced". If we repeat steps 1 to 5 \(n\)
times then upon measuring \(0\) all the time we return "constant", otherwise "balanced".</li>
</ol></dd>
</dl></dd>
</dl>

<p>
Why does it work? The Hadamard transform of \(x\mapsto\ket{f(x)}\) is
</p>

<p>
\[
  \ket{\hat{f}(l)} = \frac{1}{\sqrt{2}} \sum_{x=0}^1 (-1)^{xl} \ket{f(x)} .
\]
</p>

<p>
If \(f\) is constant we have the wave function concentrated at \(l=0\) which means that we measure \(0\)
in step 5 with certainty. If \(f\) is balanced we have a \(50\%\) chance of measuring either \(0\) or \(1\)
(hence only a \(50\%\) chance for the correct output).
</p>

<dl class="org-dl">
<dt>Remarks <a id="orgc31aaec"></a></dt><dd><ul class="org-ul">
<li><p>
By "accident" the algorithm directly generalizes to the Deutsch-Josza problem. We only
have to replace \(G\) by \(\ZZ_2^n\), \(H\) by \(H^{\otimes n}\), \(xl\) by \(\sum_ix_il_i\) and
the first register has to hold \(n\) qubits. Moreover in step 6 we return "constant" if we
measure all-zeros and "balanced" otherwise. But we cannot naturally assign a hidden
subgroup in general.
</p>

<p>
Let us sketch why this works. If \(f\) is constant again \(l=0\) (vector of bits in this
case) is the only non-zero Fourier coefficient. In the balanced case it is easy to see
that \(l=0\) concentrates <i>exactly</i> \(50\%\) of the probability. The rest is more or less
arbitrarily distributed among the other bit-strings.
</p></li>
<li><p>
This algorithm is different then the algorithm given for Deutsch or Deutsch-Josza in
section 1.4.3 or 1.4.4. Those algorithms are better in the sense that one application
suffices to get a correct return value <i>with certainty</i>.
</p>

<p>
There are two differences. The better algorithm starts with \(\ket{0}\ket{1}\) and it
applies a another Hadamard gate to the second register in step 2. This leads to the
following state in step 3:
</p>

<p>
\[
    \left( \frac{1}{\sqrt{2}} \sum_{x=0}^1 (-1)^{f(x)}\ket{x} \right) \ket{-} .
    \]
</p>

<p>
In particular the first register contains \(\pm\ket{+}\) for a constant function and
\(\pm\ket{-}\) for a balanced function. This leads to \(100\%\) correctness in step 6.
</p></li>
</ul></dd>
</dl>
</div>
</div>

<div id="outline-container-org53aabb6" class="outline-4">
<h4 id="org53aabb6">Solution for Simon's problem</h4>
<div class="outline-text-4" id="text-org53aabb6">
<p>
Let us briefly recall Simon's problem.
</p>

<p>
Let \(G=\ZZ_2^n\) and consider a function \(f:G\to X\) for some set \(X\) (we assume that there
is a binary operation \(\oplus\) on \(X\) which has a left-neutral element \(0\in X\)). Assume
that there exists some \(s\in\ZZ_2^n\) (the secret) such that \(f\) satisfies
</p>

<p>
\[
  f(y) = f(x) \quad \Longleftrightarrow \quad y = x \text{ or } y = x \oplus s .
\]
</p>

<p>
The problem is to determine the value of the secret.
</p>

<p>
Here the hidden subgroup is the two-element subgroup \(K=\{0,s\}\). The direction
\(\Leftarrow\) in the condition on \(f\) means that \(f\) is constant on cosets of \(K\). The
other direction means that \(f\) has a different value on each coset.
</p>

<p>
The "canonical" set of such functions is given by all \(f:G\to G/K\) with \(f(x):=x+K\). All
other examples arise from these by composing with an arbitrary injective function
\(G/K\,\to\,X\).
</p>

<dl class="org-dl">
<dt>Algorithm (for Simon's problem)</dt><dd><dl class="org-dl">
<dt>Inputs</dt><dd><ol class="org-ol">
<li>Two register, the first with \(n\) qubits, the second large enough for the operations
on \(X\).</li>
<li>A black box \(U\) performing \(\ket{x}\ket{y}\mapsto\ket{x}\ket{y\oplus f(x)}\).</li>
</ol></dd>
<dt>Outputs</dt><dd>The secret \(s\).</dd>
<dt>Runtime</dt><dd>\(J=nm\) calls to \(U\) and \(O(n^2)\) quantum operations in each run (mostly
quantum Fourier transform). Finally some classical overhead solving a linear system of
\(J\) equation in \(n\) variables (roughly \(O(J^3)\) operations). The success probability
is at least \(1-n2^{-m}\).</dd>
<dt>Procedure</dt><dd><ol class="org-ol">
<li>Initialize the state \(\ket{0}\ket{0}\).</li>
<li><p>
Apply \(H^{\otimes n}\) to the first register:
</p>

<p>
\[
         \rightarrow \frac{1}{\sqrt{2^n}} \sum_{x=0}^{2^n-1} \ket{x}\ket{0}
       \]
</p></li>
<li><p>
Apply \(U\):
</p>

\begin{align*}
  \rightarrow \frac{1}{\sqrt{2^n}} \sum_{x=0}^{2^n-1} \ket{x}\ket{f(x)}
  &= \frac{1}{\sqrt{2^n}} \sum_{x=0}^{2^n-1} \ket{x}\ket{f(x)} \frac{1}{\sqrt{2^n}} \sum_{l=0}^{2^n-1} (-1)^{l\cdot x}\ket{\hat{f}(l)} \\
  &= \frac{1}{\sqrt{2^n}} \sum_{l=0}^{2^n-1} \left( \frac{1}{\sqrt{2^n}} \sum_{x=0}^{2^n-1} (-1)^{l\cdot x} \ket{x} \right) \ket{\hat{f}(l)}
\end{align*}</li>
<li>Measure the first register to obtain some \(l\).</li>
<li>Repeat steps 1 to 4 \(J=mn\) times to get \(l^{(1)},\ldots,l^{(J)}\).</li>
<li><p>
Find a solution \(s\) of
</p>

<p>
\[
         s \cdot l^{(j)} = 0 \mod 2 \text{ for } j=1,\ldots,J .
       \]
</p>

<p>
as described in <a href="appendix_2.html#orgb42b6b9">appendix 2</a>. Return this solution.
</p></li>
</ol></dd>
</dl></dd>
</dl>

<p>
Why does this work? First of all from the general theory of hidden subgroup framework we
know that the \(l\) measured in step 4 is an element of \(K^\perp\). The thing which is
special here is that the probability is indeed <i>exactly</i> \(1\) here since the quantum
Fourier transform likes it if the number of qubits is a power of \(2\) (see the beginning of
section 5.2).
</p>

<p>
The choice of \(J\) leads to the success probability asserted in the runtime section because
of <a href="#org3bb2346">a simple lemma</a> on random generators of groups.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf29f0e5" class="outline-2">
<h2 id="orgf29f0e5">References</h2>
<div class="outline-text-2" id="text-orgf29f0e5">
<p>
Stephane Beauregard (2003). <i>Circuit for Shor's algorithm using 2n+3 qubits</i>.</p>

<p>
Thomas G. Draper (2000). <i>Addition on a Quantum Computer</i>.</p>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1.50 (<a href="https://orgmode.org">Org</a> mode 9.6.9)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>