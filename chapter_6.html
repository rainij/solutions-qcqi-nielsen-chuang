<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 6</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 6</h1>\[
\newcommand{\CC}{\mathbb{C}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\orac}{\mathrm{Orac}}
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org12c2e67">Setup</a></li>
<li><a href="#orge0b9c99">Exercises</a>
<ul>
<li><a href="#org18d7e7f">Exercise 6.1</a></li>
<li><a href="#org24e39e3">Exercise 6.2</a></li>
<li><a href="#org997a0d6">Exercise 6.3</a></li>
<li><a href="#org0a1bf51">Exercise 6.4</a></li>
<li><a href="#org7bcfc8c">Exercise 6.5</a></li>
<li><a href="#org088bb18">Exercise 6.6</a></li>
<li><a href="#org430e27b">Exercise 6.7</a></li>
<li><a href="#org237321e">Exercise 6.8</a></li>
<li><a href="#exercise-6.9">Exercise 6.9</a></li>
<li><a href="#org8454038">Exercise 6.10</a></li>
<li><a href="#org4579d68">Exercise 6.11 (Multiple solution continuous quantum search)</a></li>
<li><a href="#orgb57169e">Exercise 6.12 (Alternative Hamiltonian for quantum search)</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org12c2e67" class="outline-2">
<h2 id="org12c2e67">Setup</h2>
<div class="outline-text-2" id="text-org12c2e67">
<div class="org-src-container">
<pre class="src src-python" id="orgaf12bc0"><span class="org-keyword">import</span> sympy <span class="org-keyword">as</span> sp
<span class="org-keyword">from</span> sympy.vector <span class="org-keyword">import</span> CoordSys3D

<span class="org-keyword">from</span> chapter_4 <span class="org-keyword">import</span> Ry, theta, Z
</pre>
</div>

<p>
Set up some variables:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> <span class="org-operator">=</span> sp.symbols(<span class="org-string">'a b'</span>, real<span class="org-operator">=</span><span class="org-constant">True</span>)  <span class="org-comment-delimiter"># </span><span class="org-comment">usage for a,b or alpha,beta in the book</span>
<span class="org-variable-name">c</span>, <span class="org-variable-name">s</span> <span class="org-operator">=</span> sp.symbols(<span class="org-string">'c s'</span>, real<span class="org-operator">=</span><span class="org-constant">True</span>)  <span class="org-comment-delimiter"># </span><span class="org-comment">usage for cosine and sine</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge0b9c99" class="outline-2">
<h2 id="orge0b9c99">Exercises</h2>
<div class="outline-text-2" id="text-orge0b9c99">
</div>
<div id="outline-container-org18d7e7f" class="outline-3">
<h3 id="org18d7e7f">Exercise 6.1</h3>
<div class="outline-text-3" id="text-org18d7e7f">
<p>
Show that the unitary operator corresponding to the phase shift in the Grover iteration is
\(2\ket{0}\bra{0}-I\).
</p>
</div>

<div id="outline-container-orge182107" class="outline-4">
<h4 id="orge182107">Proof</h4>
<div class="outline-text-4" id="text-orge182107">
<p>
Recall that the phase shift operator in Grover's algorithm does the following to the
standard basis states:
</p>

<p>
\[
  \ket{x} \mapsto \begin{cases} \ket{0} & \text{if } x=0 \\ -\ket{x} & \text{otherwise.} \end{cases}
\]
</p>

<p>
Since \(\sprod{0}{x}=\delta_{x,0}\) this is the same as what \(2\ket{0}\bra{0}-I\) does. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org24e39e3" class="outline-3">
<h3 id="org24e39e3">Exercise 6.2</h3>
<div class="outline-text-3" id="text-org24e39e3">
<p>
Let \(\ket{\psi}=N^{-1/2}\sum_{i=0}^{N-1}\ket{k}=H^{\otimes n}\ket{0}\). Show that the operation
\(2\ket{\psi}\bra{\psi}-I\) applied to a general state \(\sum_k\alpha_k\ket{k}\) produces
</p>

<p>
\[
  \sum_k \left[ -\alpha_k + 2\mean{\alpha} \right] \ket{k} ,
\]
</p>

<p>
where \(\mean{\alpha}=\sum_k\alpha_k/N\) is the mean value of the \(\alpha_k\). For this
reason, \(2\ket{\psi}\bra{\psi}-I\) is sometimes referred to as the <i>inversion about mean</i>
operation.
</p>
</div>

<div id="outline-container-org5dc050e" class="outline-4">
<h4 id="org5dc050e">Proof</h4>
<div class="outline-text-4" id="text-org5dc050e">
<p>
First of all we note that
</p>

<p>
\[
  \ket{\psi}\bra{\psi} = \frac{1}{N} \sum_{ij} \ket{i}\bra{j} .
\]
</p>

<p>
Hence
</p>

\begin{align*}
  (2\ket{\psi}\bra{\psi}-I) \sum_k \alpha_k \ket{k}
  &= \sum_k -\alpha_k \ket{k} + 2\sum_{ijk} \frac{\alpha_k}{N} \ket{i}\sprod{j}{k} \\
  &= \sum_k -\alpha_k \ket{k} + 2\sum_{ik} \frac{\alpha_k}{N} \ket{i} \\
  &= \sum_k -\alpha_k \ket{k} + 2\sum_{i} \mean{\alpha} \ket{i} \\
  &= \sum_k (-\alpha_k + 2\mean{\alpha}) \ket{k} .
\end{align*}

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org997a0d6" class="outline-3">
<h3 id="org997a0d6">Exercise 6.3</h3>
<div class="outline-text-3" id="text-org997a0d6">
<p>
Show that in the \(\ket{\alpha}\), \(\ket{\beta}\) basis, we may write the Grover iteration as a rotation
</p>

<p>
\[
  G = \begin{bmatrix} \cos(\theta) & -\sin(\theta) \\ \sin(\theta) & \cos(\theta) \end{bmatrix} ,
\]
</p>

<p>
where \(\theta\) is a real number in the range \(0\) to \(\pi/2\) (assuming for simplicity that
\(M\leq N/2\); this limitation will be lifted shortly), chosen so that
</p>

<p>
<a id="org675b590"></a>
\[
  \sin(\theta) = \frac{2\sqrt{M(N-M)}}{N} .
\]
</p>
</div>

<div id="outline-container-orge18c06b" class="outline-4">
<h4 id="orge18c06b">Proof</h4>
<div class="outline-text-4" id="text-orge18c06b">
<p>
Recall that \(M\) is the number of solutions of \(f(x)=1\) and that
</p>

<p>
<a id="org077554d"></a>
\[
  \ket{\alpha} = \frac{1}{\sqrt{N-M}} \sum_{f(x)=0} \ket{x} ,
  \quad \text{and} \quad
  \ket{\beta} = \frac{1}{\sqrt{M}} \sum_{f(x)=1} \ket{x} .
\]
</p>

<p>
Moreover
</p>

<p>
\[
  \ket{\psi} = H^{\otimes n} \ket{0}
  = \underbrace{\sqrt{\frac{N-M}{N}}}_{=:\cos(\theta/2)} \ket{\alpha} +
    \underbrace{\sqrt{\frac{M}{N}}}_{=:\sin(\theta/2)} \ket{\beta} .
\]
</p>

<p>
This is consistent with the <a href="#org675b590">formula for \(\theta\)</a> from the exercise statement, which can be
seen by the trigonometric identity \(\sin(2x)=2\sin(x)\cos(x)\). The Grover iteration \(G\) is
the product of the inversion about \(\psi\), and the oracle \(\orac\) (inversion about
\(\alpha\)). We ignore the workspace here.
</p>

<p>
\[
  G = \mathrm{inv}(\psi) \cdot \orac
\]
</p>

<p>
By definition of \(\alpha\) and \(\beta\) we have
</p>

<p>
\[
  \orac = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix} .
\]
</p>

<p>
Note that this is the Pauli-Z matrix. Let
</p>

<p>
\[
  U(\theta) = \begin{bmatrix} \cos(\theta) & -\sin(\theta) \\ \sin(\theta) & \cos(\theta) \end{bmatrix} .
\]
</p>

<p>
Note that \(U(\theta/2)=R_y(\theta)\) (Pauli-Y rotation) and that \(U(\theta/2)(1,0)\) is the
coordinate representation of \(\ket{\psi}\). Hence
</p>

<p>
\[
  \mathrm{inv}(\psi) = U(\theta/2)
  \cdot \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}
  \cdot U(-\theta/2) .
\]
</p>

<p>
To show the claim only a short calculation is left. Let us do it with the help of <code>sympy</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">Inv_psi</span> <span class="org-operator">=</span> sp.simplify(Ry <span class="org-operator">*</span> Z <span class="org-operator">*</span> Ry.H)  <span class="org-comment-delimiter"># </span><span class="org-comment">Ry = Ry(theta)</span>
<span class="org-variable-name">Orac</span> <span class="org-operator">=</span> Z

<span class="org-keyword">assert</span> Ry.subs(theta, 2<span class="org-operator">*</span>theta) <span class="org-operator">==</span> Inv_psi <span class="org-operator">*</span> Orac
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
PASSED
</pre>


<p>
Another way to see this (without much calculation) is to note that
\(ZU(-\phi)Z=U(\phi)\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org0a1bf51" class="outline-3">
<h3 id="org0a1bf51">Exercise 6.4</h3>
<div class="outline-text-3" id="text-org0a1bf51">
<p>
Give explicit steps for the quantum search algorithm, for the case of multiple solutions
(\(1 < M \leq N/2\)).
</p>
</div>

<div id="outline-container-orgbe5c715" class="outline-4">
<h4 id="orgbe5c715">Solution</h4>
<div class="outline-text-4" id="text-orgbe5c715">
<p>
The difference to the special case \(M=1\) is essentially the number of repetitions of the
Grover iteration. Also note that \(M\) has an influence on the success probability.
</p>

<p>
We assume that \(N=2^n\), \(f:\{0,1\}^n\to\{0,1\}\), and that \(M\) is the number of solutions
of \(f(x)=1\), as in the book. Moreover let (recall that we assume \(M\leq N/2\))
</p>

<p>
\[
  \theta = \arcsin\left(\frac{2\sqrt{M(N-M)}}{N}\right)
\]
</p>

<p>
This formula comes from <a href="#org675b590">exercise 6.3</a>. In the solution of that exercise we showed that
</p>

<p>
\[
  \ket{\psi} := H^{\otimes n} \ket{0} = \cos(\theta/2) \ket{\alpha} + \sin(\theta/2) \ket{\beta} .
\]
</p>

<p>
Here \(\alpha\) and \(\beta\) are as in the <a href="#org077554d">solution of exercise 6.3</a>. Let us write
</p>

<p>
\[
  \ket{\varphi} := \cos(\varphi) \ket{\alpha} + \sin(\varphi) \ket{\beta} .
\]
</p>

<p>
Hence \(\ket{\psi}=\ket{\theta/2}\), \(\beta=\ket{\pi/2}\) and \(G\) acts as
\(\ket{\varphi}\mapsto\ket{\varphi+\theta}\). In particular, since we aim to rotate
\(\ket{\psi}\) to \(\ket{\beta}\) (approximately), the number of repetitions for the Grover
algorithm is:
</p>

<p>
\[
  R = \mathrm{round}\left( \frac{\pi}{2\theta} - \frac{1}{2} \right) = O \left( \sqrt{\frac{N}{M}} \right) ,
\]
</p>

<p>
(for \(M\leq N/2\)).
</p>

<dl class="org-dl">
<dt>Algorithm (Quantum Search (Grover) for \(0 < M \leq N/2\))</dt><dd><dl class="org-dl">
<dt>Inputs</dt><dd><ul class="org-ul">
<li>An \(n\) bit register and a one bit register.</li>
<li>A black box oracle \(U_f\) which performs the transformation \(U_f\ket{x,q}=\ket{x,q\oplus f(x)}\).</li>
</ul></dd>
<dt>Outputs</dt><dd>A solution \(x_0\) of \(f(x_0)=1\) with probability at least
\(1-\sin(\theta/2)^2=1-M/N\geq1/2\) (since the Grover iterations miss \(\pi/2\) by at most
\(\theta/2\)). Every solution has the same chance to get "chosen".</dd>
<dt>Runtime</dt><dd>\(R=O(\sqrt{N/M})\) calls to the oracle and to \((2\ket{\psi}\bra{\psi}-I)\),
and \(O(n)\) gates/operations for other things.</dd>
<dt>Procedure</dt><dd><ol class="org-ol">
<li>Initialize registers to \(\ket{0}\ket{0}\).</li>
<li><p>
Apply \(H^{\otimes n}\otimes HX\):
</p>

<p>
\[
       \rightarrow \frac{1}{2^{n/2}} \sum_{x=0}^{2^n-1} \ket{x} \ket{-}
       = \ket{\psi}\ket{-}
       = \ket{\theta/2}\ket{-}
       \]
</p></li>
<li><p>
Apply \(R\) repetitions of \((2\ket{\psi}\bra{\psi}-I)U_f\):
</p>

<p>
\[
       \rightarrow \ket{(2R+1)\theta/2}\ket{-}
       \approx \ket{\beta}\ket{-}
       \]
</p></li>
<li>Measure the first register to obtain some \(x_0\). Return \(x_0\).</li>
</ol></dd>
</dl></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org7bcfc8c" class="outline-3">
<h3 id="org7bcfc8c">Exercise 6.5</h3>
<div class="outline-text-3" id="text-org7bcfc8c">
<p>
Show that the augmented oracle \(U_f'\) may be constructed using one application of the
original oracle \(U_f\), and elementary quantum gates, using the extra qubit \(\ket{q}\).
</p>

<ul class="org-ul">
<li>What strikes me is the fact that it is possible to do this with just <i>one</i> application
of the oracle! We will see that it is not possible to do this <i>classically</i> in a
reversible way.</li>
</ul>
</div>

<div id="outline-container-orgd825870" class="outline-4">
<h4 id="orgd825870">Proof</h4>
<div class="outline-text-4" id="text-orgd825870">
<p>
According to the book we have to implement \(U_f'\) as a <i>controlled</i> (by \(q\)) version of
\(U_f\) which acts like this:
</p>

<p>
\[
  \ket{q,x,y} \mapsto \ket{q,x,y\oplus \overline{q}f(x)} .
\]
</p>

<p>
Recall that the techniques of chapter 4 require to decompose \(U_f\) into elementary gates
and recursively add controls. We do <i>not</i> do this for the following reasons:
</p>

<ul class="org-ul">
<li>\(U_f\) is a black box. So we are not supposed to assume anything about its internal
workings. In particular it might <i>not</i> be implemented by the "usual" elementary gates.</li>
<li>Even if it was (and we get access to the circuit during execution of the algorithm) the
generic standard recursive procedure produces a relatively complicated circuit (in
general).</li>
<li>There is a simple way to get \(U'_f\) using \(U_f\) as a black box!</li>
</ul>

<p>
The key to see this is the fact that the oracle \(U_f\) leaves \(\ket{x}\ket{+​}\) fixed. Let us introduce
a fourth (auxiliary) register holding one qubit, initialized to \(\ket{+}\). We want to
implement \(U'_f\) as:
</p>

<p>
\[
  \ket{q,x,y,+} \mapsto \ket{q,x,y\oplus \overline{q}f(x),+} .
\]
</p>

<p>
It is not hard to see that
</p>

<p>
\[ U'_f=\mathrm{CSWAP}(1,3,4)\cdot U_f \cdot \mathrm{CSWAP}(1,3,4) \]
</p>

<p>
accomplishes exactly that. Here \(\mathrm{CSWAP}(1,3,4)\) is the controlled swap gate
exchanging registers three and four conditioned on register one. QED.
</p>
</div>
</div>

<div id="outline-container-org54c3151" class="outline-4">
<h4 id="org54c3151">Proof of the remark</h4>
<div class="outline-text-4" id="text-org54c3151">
<p>
In the framework of (classical) reversible computation as sketched in chapter 3.2.5 in the
book we need at least two applications of the oracle.
</p>

<p>
Before we prove this let us first show a classical reversible algorithm which uses two
applications of the oracle:
</p>

\begin{align*}
  \ket{q,x,y,0}
  &\stackrel{U_f(2,4)}{\longmapsto} &\ket{q,x,y,f(x)} \\
  &\stackrel{X(1)}{\longmapsto}     &\ket{\overline{q},x,y,f(x)} \\
  &\stackrel{\mathrm{Toff}(1,4,3)}{\longmapsto} &\ket{\overline{q},x,y\oplus\overline{q}f(x),f(x)} \\
  &\stackrel{X(1)}{\longmapsto}     &\ket{q,x,y\oplus\overline{q}f(x),f(x)} \\
  &\stackrel{U_f(2,4)}{\longmapsto} &\ket{q,x,y\oplus\overline{q}f(x),0}
\end{align*}

<p>
The second application of the oracle is needed to uncompute the garbage from the auxiliary
register. An intuitive way to see the necessity of the second application is to look at
the information present in the registers. In case of \(q=1\) the final state does <i>not</i>
contain a single bit of information about \(f\). On the other hand, if we apply the oracle
just once it leaves one bit of information about \(f\) (the value of \(f\) at some input, but
not necessarily at \(x\)). So the computation after the application of the oracle would have
to <i>erase</i> the information which is not possible with reversible computation (without
using the oracle, and hence some information about \(f\), again).
</p>

<p>
Let us give a (hopefully) more rigorous proof. Assume to the contrary that it was possible
with just one application of the oracle and an additional \(m\) qubit auxiliary register
(initialized to \(0\)). The circuit (which is just a sequence of reversible gates) can be
divided into three parts. The part \(A\) before the oracle, the application of the oracle
\(U_f\), and the part \(B\) after the oracle:
</p>

\begin{align*}
  \ket{q,x,y,0}
  &\stackrel{A}{\longmapsto} \ket{a_1, a_2, a_3, a_4} \\
  &\stackrel{U_f(p)}{\longmapsto} \ket{a'_1, a'_2, a'_3, a'_4} \\
  &\stackrel{B}{\longmapsto} \ket{q,x,y\oplus\overline{q}f(x),0}
\end{align*}

<p>
In the second step the \(p\) "signifies" our choice to what \(n+1\) qubits to apply the
oracle. Let us merge the \(a_i\) into a single vector \(z\) (just for notational
simplicity). Same for \(z'\) vs the \(a_i\).
</p>

<p>
After the oracle step for a certain \(j_0\) we have
\(z'_{j_0}=z_{j_0}\oplus\,f(\tilde{x})\). Here the \(\tilde{x}=\tilde{x}(q,x,A,p)\) only
depends on \(q\), \(x\), the first part \(A\), and the places \(p\) to which the oracle is
applied. Note that for \(q=0\) clearly \(\tilde{x}=x\) (otherwise, there is no way to obtain
\(f(x)\)), but for \(q=1\) (the interesting case) we cannot conclude this.
</p>

<p>
Now let us simulate the above circuit on a larger circuit with four <i>zones</i>. A <i>zone</i> is
just a group of registers. The first zone is a read-only zone containing \(q,x,y\) all the
time. The second and third zone contains the same four registers (each) as the above
circuit. The last zone contains only a one-qubit circuit.
</p>

<p>
Let us denote by \(\mathrm{Sim}(A,i)\) for \(i\in\{2,3\}\) the circuit which executes \(A\) at
zone \(i\). The simulations of \(U_f\) and \(B\) are defined similarly.
</p>

<p>
Consider the circuit which acts as follows:
</p>

<ol class="org-ol">
<li>Start
\[ \ket{q,x,y;0;0;0} \]</li>
<li>Copy \(q,x,y\) to zone \(2\):
\[ \rightarrow \ket{q,x,y;q,x,y,0;0;0} \]</li>
<li>Apply \(\mathrm{Sim}(A,2)\):
\[ \rightarrow \ket{q,x,y;z;0;0} \]</li>
<li>Apply \(\mathrm{Sim}(U_f(p),2)\):
\[ \rightarrow \ket{q,x,y;z';0;0} \]</li>
<li>Apply \(\mathrm{Sim}(B,2)\):
\[ \rightarrow \ket{q,x,y;q,x,y\oplus \overline{q}f(x),0;0;0} \]</li>
</ol>

<p>
Now let us see how we can extract \(f(\tilde{x})\) from the final state (without using the
oracle). The possibility of being able to do this is a contradiction since clearly no
traces of \(f\) are left in the final state for \(q=1\).
</p>

<ol class="org-ol">
<li value="6">Uncompute \(\mathrm{Sim}(B,2)\):
\[ \rightarrow \ket{q,x,y;z';0;0} \]</li>
<li>Copy \(q,x,y\) to zone \(3\):
\[ \rightarrow \ket{q,x,y;z';q,x,y,0;0} \]</li>
<li>Apply \(\mathrm{Sim}(A,3)\):
\[ \rightarrow \ket{q,x,y;z';z;0} \]</li>
<li><p>
Add zone three to zone two (using bit-wise addition):
</p>

<p>
\[ \rightarrow \ket{q,x,y;z'';z;0} \]
</p>

<p>
Note that \(z''\) contains just one non-trivial bit \(z''_{j_0}=f(\tilde{x})\) (the others
are trivially zero).
</p></li>
<li>Copy \(z''_{j_0}=f(\tilde{x})\) to the fourth zone and erase it from zone two (by a <code>CNOT</code> controlled
by the fourth zone):
\[ \rightarrow \ket{q,x,y;0;z;f(\tilde{x})} \]</li>
<li>Uncompute \(\mathrm{Sim}(A,3)\) (not important, just for reasons of feng shui):
\[ \rightarrow \ket{q,x,y;0;0;f(\tilde{x})} \]</li>
</ol>

<p>
We have managed to extract a bit of information about \(f\) no matter the value of \(q\). This
is a contradiction as already explained above. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org088bb18" class="outline-3">
<h3 id="org088bb18">Exercise 6.6</h3>
<div class="outline-text-3" id="text-org088bb18">
<p>
Verify that the gates in the dotted box in the second ﬁgure of Box 6.1 perform the
conditional phase shift operation \(2\ket{00}\bra{00}-I\), up to an unimportant global phase
factor.
</p>
</div>

<div id="outline-container-org2f44c48" class="outline-4">
<h4 id="org2f44c48">Proof</h4>
<div class="outline-text-4" id="text-org2f44c48">
<p>
The circuit in the dotted region implements the following operator
</p>

<p>
\[
  X \otimes X \cdot \underbrace{I\otimes H \cdot C(X) \cdot I\otimes H}_{C(Z)} \cdot X \otimes X
\]
</p>

<p>
Recall that the controlled <code>Z</code>-gate acts as follows on the standard basis:
</p>

<p>
\[
  C(Z) \ket{x} = \begin{cases} -\ket{11} & \text{for } x=11 \\
  \ket{x} & \text{otherwise.} \end{cases}
\]
</p>

<p>
The <code>X</code>-gate just exchanges the roles of \(0\) and \(1\):
</p>

<p>
\[
  X \otimes X \cdot C(Z) \cdot X \otimes X \cdot  \ket{x}
  = \begin{cases} -\ket{00} & \text{for } x=00 \\ \ket{x} & \text{otherwise.} \end{cases}
\]
</p>

<p>
Up to a factor of \(-1\) (the global phase factor) this is precisely what
\(2\ket{00}\bra{00}-I\) does. QED.
</p>
</div>
</div>
</div>
<div id="outline-container-org430e27b" class="outline-3">
<h3 id="org430e27b">Exercise 6.7</h3>
<div class="outline-text-3" id="text-org430e27b">
<p>
Verify that the circuits shown in Figures 6.4 and 6.5 implement the operations
\(\exp(-\ii\ket{x}\bra{x}\Delta t)\) and \(\exp(-\ii\ket{\psi}\bra{\psi}\Delta t)\),
respectively, with \(\ket{\psi}=H^{\otimes n}\ket{0}\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
There is a typo in the rotation matrix. The matrix should be
</p>

<p>
\[ \begin{bmatrix} 1 & 0 \\ 0 & e^{-\ii\Delta t} \end{bmatrix} \]
</p>

<p>
The minus-sign is missing in the figures of the circuits.
</p></dd>
</dl>
</div>

<div id="outline-container-org1281067" class="outline-4">
<h4 id="org1281067">Proof for the first circuit</h4>
<div class="outline-text-4" id="text-org1281067">
<p>
Since \(\proj{x}\) is a projection (that is, an operator for which \(P^2=P\)) the series
expansion of the exponential function implies
</p>

<p>
\[
  e^{-\ii\proj{x}\Delta t} = e^{-\ii\Delta t} \proj{x} + (I - \proj{x})
\]
</p>

<p>
Hence
</p>

<p>
\[
  e^{-\ii\proj{x}\Delta t} \ket{y} = \begin{cases} \ket{y} & \text{if } y\neq x \\
    e^{-\ii\Delta t} \ket{x} & \text{if } y=x \end{cases} \;
  = e^{-\ii\Delta t f(y)} \ket{y} .
\]
</p>

<p>
On the other hand this is exactly what the circuit
(\(U_f\mathrm{diag}(1,\exp(-\ii\,\Delta\,t))U_f\)) does.
</p>

\begin{align*}
  \ket{y,0}
  &\stackrel{U_f}{\longmapsto} \ket{y,f(y)} \\
  &\stackrel{[\ldots]}{\longmapsto} e^{-\ii\Delta t f(y)} \ket{y,f(y)} \\
  &\stackrel{U_f}{\longmapsto} e^{-\ii\Delta t f(y)} \ket{y,0}
\end{align*}

<p>
QED.
</p>
</div>
</div>

<div id="outline-container-org5b23c56" class="outline-4">
<h4 id="org5b23c56">Proof for the second circuit</h4>
<div class="outline-text-4" id="text-org5b23c56">
<p>
In the same way as in the first part we see that
</p>

<p>
\[
  e^{-\ii\proj{\psi}\Delta t} \ket{\varphi} = \begin{cases} \ket{\varphi} & \text{if } \ket{\varphi}\perp \ket{\psi} \\
    e^{-\ii\Delta t} \ket{\psi} & \text{if } \ket{\varphi}=\ket{\psi} \end{cases}
\]
</p>

<p>
Again this is exactly what the circuit does. Let us first consider the case
\(\ket{\varphi}=\ket{\psi}\):
</p>

\begin{align*}
  \ket{\psi,0}
  &\stackrel{H^{\otimes n}}{\longmapsto} \ket{0,0} \\
  &\stackrel{C_0^n(X)}{\longmapsto} \ket{0,1} \\
  &\stackrel{[\ldots]}{\longmapsto} e^{-\ii\Delta t} \ket{0,1} \\
  &\stackrel{C_0^n(X)}{\longmapsto} e^{-\ii\Delta t} \ket{0,0} \\
  &\stackrel{H^{\otimes n}}{\longmapsto} e^{-\ii\Delta t} \ket{\psi,0} .
\end{align*}

<p>
For the case \(\ket{\varphi}\perp\ket{\psi}\) we only have to note that
\(H^{\otimes\,n}\ket{\varphi}\) is orthogonal to \(\ket{0}\) and hence the controlled \(X\) gate
does nothing. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org237321e" class="outline-3">
<h3 id="org237321e">Exercise 6.8</h3>
<div class="outline-text-3" id="text-org237321e">
<p>
Suppose the simulation step is performed to an accuracy \(O(\Delta t^r)\). Show that the
number of oracle calls required to simulate \(H\) to reasonable accuracy is
\(O(N^{-r/2(r-1)})\). Note that as \(r\) becomes large the exponent of \(N\) approaches \(1/2\).
</p>
</div>

<div id="outline-container-orgfa8a55e" class="outline-4">
<h4 id="orgfa8a55e">Proof</h4>
<div class="outline-text-4" id="text-orgfa8a55e">
<p>
From equation (6.23) we know that the simulation time is \(t=\pi/2\alpha=O(\sqrt{N})\). Hence
the number of steps is \(t/\Delta t = O(\Delta t\inv \sqrt{N})\). Since the error of a product
of <i>unitary</i> operators scales linearly we see that the overall error is
</p>

<p>
\[
  O(\Delta t^{r-1} \sqrt{N})
\]
</p>

<p>
This must be \(O(1)\) and hence we must choose \(\Delta t = O(N^{-1/2(r-1)})\). To minimize
the number of steps we set \(\Delta t \approx N^{-1/2(r-1)}\) and obtain the claim. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-6.9" class="outline-3">
<h3 id="exercise-6.9">Exercise 6.9</h3>
<div class="outline-text-3" id="text-exercise-6.9">
<p>
Verify Equation (6.25): Let \(c=\cos(\Delta t/2)\), \(s=\sin(\Delta t/2)\):
</p>

<p>
\[
  U(\Delta t) = \left( c^2 - s^2 \, \vec{\psi}\cdot\hat{z} \right) I -
  \ii s \left(c \, (\vec{\psi}+\hat{z}) + s \, \vec{\psi}\times\hat{z} \right) \cdot \vec{\sigma} .
\]
</p>

<p>
(Hint: see <a href="chapter_4.html#exercise-4-15">Exercise 4.15</a>.)
</p>
</div>

<div id="outline-container-org743c1e6" class="outline-4">
<h4 id="org743c1e6">Proof</h4>
<div class="outline-text-4" id="text-org743c1e6">
<p>
Let \(\hat{z}=(0,0,1)\) and \(\vec{\psi}=(2\alpha\beta,0,\alpha^2-\beta^2)\). From the
paragraph above equation (6.25) we deduce
</p>

<p>
\[
  U(\Delta t) = e^{-\ii \proj{\psi} \Delta t} \cdot e^{-\ii \proj{x} \Delta t}
  = e^{-\ii \Delta t}
    \cdot e^{-\ii \vec{\psi}\cdot\vec{\sigma} \Delta t/2}
    \cdot e^{-\ii \hat{z}\cdot\vec{\sigma} \Delta t/2} .
\]
</p>

<p>
The first of the three terms is the unimportant global phase. The second and the third are
rotations around \(\vec{\psi}\) and \(\hat{z}\) and angle \(\Delta t\) (both). Hence we are
indeed in the setting of exercise 4.15. From that exercise we deduce that \(U(\Delta t)\) is
a rotation around an axis \(\vec{n}\) by an angle \(\theta\)
</p>

<p>
\[
  U(\Delta t) = e^{-\ii \Delta t} \left( \cos(\theta/2) I + \sin(\theta/2) \vec{n}\cdot\vec{\sigma} \right)
\]
</p>

<p>
such that:
</p>

<p>
\[
  \cos(\theta/2) = c^2 - s^2 \, \vec{\psi}\cdot\hat{z}
\]
</p>

<p>
and
</p>

<p>
\[
  \sin(\theta/2) \vec{n} = sc \, (\vec{\psi}+\hat{z}) + s^2 \, \vec{\psi}\times\hat{z} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>
<div id="outline-container-org8454038" class="outline-3">
<h3 id="org8454038">Exercise 6.10</h3>
<div class="outline-text-3" id="text-org8454038">
<p>
Show that by choosing \(\Delta t\) appropriately we can obtain a quantum search algorithm
which uses \(O(\sqrt{N})\) queries, and for which the ﬁnal state is \(\ket{x}\) exactly, that
is, the algorithm works with probability \(1\), rather than with some smaller probability.
</p>
</div>

<div id="outline-container-exercise-6.10-proof" class="outline-4">
<h4 id="exercise-6.10-proof">Proof</h4>
<div class="outline-text-4" id="text-exercise-6.10-proof">
<p>
To not obscure the proof by too much technicalities I only prove the result for <i>large
enough</i> \(N\). Let \(c=\cos(\Delta t/2)\) and \(s=\sin(\Delta t/2)\).
</p>

<p>
From the proof of <a href="#exercise-6.9">exercise 6.9</a> we know that \(U(\Delta t)\) is a rotation of angle \(\theta\)
about \(\vec{r}\) where:
</p>

<p>
<a id="orge54cc0a"></a>
\[
  \cos(\theta/2) = c^2 - s^2 \, \vec{\psi}\cdot\hat{z}
\]
</p>

<p>
and
</p>

<p>
<a id="orgb903e12"></a>
\[
  \sin(\theta/2) \vec{r} = sc \, (\vec{\psi}+\hat{z}) + s^2 \, \vec{\psi}\times\hat{z} .
\]
</p>

<p>
Also recall that \(\hat{z}=(0,0,1)\) and \(\vec{\psi}=(2\alpha\beta,0,\alpha^2-\beta^2)\)
where \(\alpha=1/\sqrt{N}\) and \(\beta=\sqrt{(N-1)/N}\). Let us further elaborate on
\(\theta\). Using one of the <a href="#orge54cc0a">above formulas</a> we get
</p>

<p>
<a id="orgdc16329"></a>
\[
  \cos(\theta/2) = 1 - \frac{2s}{N} .
\]
</p>

<p>
From the Taylor expansion \(\cos(x)=1-x^2/2+O(x^4)\) of the cosine function we obtain
</p>

<p>
<a id="org68ff3ff"></a>
\[
  \theta = 4 \sqrt{\frac{s}{N}} + O(sN\inv) .
\]
</p>

<p>
Now consider the axis of rotation. Below with \(\sim\) we mean that the LHS is equal to the
RHS up to a real factor. Using the <a href="#orgb903e12">axis-formula</a> a <a href="#org09acce6">short calculation</a> yields
</p>

<p>
<a id="org5e604af"></a>
\[
  \vec{r} \sim (\beta c, -\beta s, \alpha c) .
\]
</p>

<p>
The squared norm of the RHS is \(1-\alpha^2s^2\). Hence
</p>

<p>
<a id="org7e8389a"></a>
\[
  \vec{r} = (\beta c, -\beta s, \alpha c) / \sqrt{1-\alpha^2s^2} = (\beta c, -\beta s, \alpha c) + O(s^2N\inv) .
\]
</p>

<p>
From the <a href="#orgb903e12">original formula</a> for \(\vec{r}\) we see that
\(\vec{r}\cdot\hat{z}=\vec{r}\cdot\vec{\psi}\approx\alpha\,c=O(N^{-1/2})\). This implies
that \(\hat{z}\) indeed lies on the same orbit as \(\psi\). Let \(\omega\) be the angle of the
rotation about \(\vec{r}\) which is needed to rotate \(\vec{\psi}\) into \(\hat{z}\). Let
</p>

<p>
\[
  \hat{z}' = \hat{z} - (\hat{z}\cdot\vec{r}) \; \vec{r}
  = \hat{z} - \frac{\alpha c}{\sqrt{1-\alpha^2 c^2}} \; \vec{r}
  = \hat{z} + O(N^{-1/2}) \; \vec{r}
\]
</p>

<p>
and
</p>

<p>
\[
  \vec{\psi}' = \vec{\psi} - (\vec{\psi}\cdot\vec{r}) \; \vec{r}
  = \vec{\psi} - \frac{\alpha c}{\sqrt{1-\alpha^2 c^2}} \; \vec{r}
  = \vec{\psi} + O(N^{-1/2}) \; \vec{r} .
\]
</p>

<p>
Hence
</p>

<p>
\[
  \cos(\omega) = \vec{\psi}' \cdot \hat{z}'
  = \vec{\psi} \cdot \hat{z} + O(N\inv)
  = \alpha^2 - \beta^2 + O(N\inv)
  = -1 + O(N\inv) ,
\]
</p>

<p>
and therefore \(\omega=\pi+O(N^{-1/2})\). Using this and the <a href="#org68ff3ff">formula</a> for \(\theta\) we see
that the number of required \(\theta\) rotations is
</p>

<p>
\[
  \frac{\omega}{\theta} = \frac{\pi}{4\sqrt{s}} \sqrt{N} + O(1) .
\]
</p>

<p>
To enable a 100% probability this number must be an integer. The standard case with
\(\Delta t=\pi\) means \(s=1\). By the <a href="https://en.wikipedia.org/wiki/Intermediate_value_theorem">intermediate value theorem</a> (the expression is
continuous) there is an \(s\in[1-cN^{-1/2},1]\) (for some constant \(c>0\) depending on the
constant in the \(O(1)\) above) such that this is true. Clearly \(\omega/\theta=O(\sqrt{N})\)
for such \(s\). QED.
</p>
</div>
</div>

<div id="outline-container-org7f05618" class="outline-4">
<h4 id="org7f05618">Appendix</h4>
<div class="outline-text-4" id="text-org7f05618">
<p>
Let us use <code>sympy</code> to do the boring calculations. First let us define \(\hat{z}\) and
\(\vec{\psi}\) in a 3D cartesian coordinate system. Moreover we set up our slightly <a href="#org5e604af">scaled
version</a> <code>r1</code> of \(\vec{r}\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">N</span> <span class="org-operator">=</span> CoordSys3D(<span class="org-string">'N'</span>)

<span class="org-variable-name">z</span> <span class="org-operator">=</span> N.k
<span class="org-variable-name">psi</span> <span class="org-operator">=</span> 2<span class="org-operator">*</span>a<span class="org-operator">*</span>b<span class="org-operator">*</span>N.i <span class="org-operator">+</span> (a<span class="org-operator">**</span>2 <span class="org-operator">-</span> b<span class="org-operator">**</span>2)<span class="org-operator">*</span>N.k

<span class="org-variable-name">r_formula_rhs</span> <span class="org-operator">=</span> s<span class="org-operator">*</span>c<span class="org-operator">*</span>(psi <span class="org-operator">+</span> z) <span class="org-operator">+</span> s<span class="org-operator">**</span>2 <span class="org-operator">*</span> psi.cross(z)
<span class="org-variable-name">r1</span> <span class="org-operator">=</span> b<span class="org-operator">*</span>c<span class="org-operator">*</span>N.i <span class="org-operator">-</span> b<span class="org-operator">*</span>s<span class="org-operator">*</span>N.j <span class="org-operator">+</span> a<span class="org-operator">*</span>c<span class="org-operator">*</span>N.k
</pre>
</div>

<p>
<a id="org09acce6"></a>
Here we check that our <a href="#org7e8389a">formula</a> for \(\vec{r}\) is valid:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">norm2_r1</span> <span class="org-operator">=</span> r1.dot(r1).subs(b<span class="org-operator">**</span>2, 1 <span class="org-operator">-</span> a<span class="org-operator">**</span>2).subs(c<span class="org-operator">**</span>2, 1 <span class="org-operator">-</span> s<span class="org-operator">**</span>2)

<span class="org-keyword">assert</span> r_formula_rhs.subs(b<span class="org-operator">**</span>2, 1 <span class="org-operator">-</span> a<span class="org-operator">**</span>2) <span class="org-operator">==</span> 2<span class="org-operator">*</span>a<span class="org-operator">*</span>s <span class="org-operator">*</span> r1
<span class="org-keyword">assert</span> sp.simplify(norm2_r1) <span class="org-operator">==</span> 1 <span class="org-operator">-</span> a<span class="org-operator">**</span>2 <span class="org-operator">*</span> s<span class="org-operator">**</span>2
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
PASSED
</pre>
</div>
</div>
</div>
<div id="outline-container-org4579d68" class="outline-3">
<h3 id="org4579d68">Exercise 6.11 (Multiple solution continuous quantum search)</h3>
<div class="outline-text-3" id="text-org4579d68">
<p>
Guess a Hamiltonian with which one may solve the continuous time search problem in the
case where the search problem has \(M\) solutions.
</p>
</div>

<div id="outline-container-org15ca356" class="outline-4">
<h4 id="org15ca356">Solution</h4>
<div class="outline-text-4" id="text-org15ca356">
<p>
My Ansatz looks as follows
</p>

<p>
\[
  H = \proj{\chi} + \proj{\psi} ,
\]
</p>

<p>
where
</p>

<p>
\[
  \chi = \frac{1}{\sqrt{M}} \sum_{f(x)=1} \ket{x}
\]
</p>

<p>
and we let \(\ket{\psi}\) unspecified at first (as always we take
\(\ket{\psi}=H^{\otimes\,n}\ket{0}\) in the end). It turns out that section 6.2
<i>essentially</i> works out analogously with this Hamiltonian if one replaces \(x\) with \(\chi\).
</p>

<p>
In particular we arrive at the same formula for the Hamiltonian and formula (6.23) which
states that the corresponding unitary group rotates (the still arbitrary) \(\ket{\psi}\)
into \(\ket{\chi}\):
</p>

<p>
\[
  \cos(\alpha t) \ket{\psi} - i\sin(\alpha t) \ket{\chi} .
\]
</p>

<p>
Thus after time \(t=\pi/\alpha\) the system is rotated in a state which when measured
produces a solution of \(f(x)=1\) (equal probability for each possibility). So what is the
difference? Something must be different, right? I am glad you asked! Actually <i>so far
nothing</i> is different!
</p>

<p>
Essentially the only thing which differs is the value of \(\alpha\) once we fix
\(\ket{\psi}\). As in chapter 6.2 we have to choose \(\ket{\psi}\) in a way which allows us to
determine \(\alpha\) without knowing \(\ket{\chi}\). This is where we fix
\(\ket{\psi}=H^{\otimes\,n}\ket{0}\). This in turn leads to
</p>

<p>
\[ \alpha=\sqrt{M/N} . \]
</p>

<p>
Let us finally investigate the implications for the performance of an approximation
similar to the one in the book. It is easiest to just follow the <a href="#exercise-6.10-proof">proof of exercise
6.10</a>. For simplicity we restrict our short analysis to the case \(M=o(N)\).
</p>

<p>
The angle \(\theta\) of rotation is determined by (c.f. <a href="#orgdc16329">the case</a> for \(M=1\))
</p>

<p>
\[
  \cos(\theta/2) = 1 - \frac{2Ms}{N} .
\]
</p>

<p>
Hence
</p>

<p>
\[
  \theta = 4 \sqrt{\frac{sM}{N}} + O(sMN\inv) .
\]
</p>

<p>
The same reasoning as in exercise 6.10 allows us to estimate the angle \(\omega\) between \(\vec{\psi}\) and \(\hat{z}\):
</p>

<p>
\[
  \cos(\omega) = -1 + O(MN\inv) .
\]
</p>

<p>
Hence \(\omega\approx\pi\). We conclude that the number of iterations is
\(\omega/\theta=\Theta(\sqrt{N/M})\) (if we choose \(\Delta t=\pi\) and thus \(s=1\)). But keep in
mind that we used \(M=o(N)\) in this analysis!
</p>
</div>
</div>
</div>
<div id="outline-container-orgb57169e" class="outline-3">
<h3 id="orgb57169e">Exercise 6.12 (Alternative Hamiltonian for quantum search)</h3>
<div class="outline-text-3" id="text-orgb57169e">
<p>
Suppose
</p>

<p>
\[
  H = \ket{x}\bra{\psi} + \ket{\psi}\bra {x} .
\]
</p>

<ol class="org-ol">
<li>Show that it takes time \(O(1)\) to rotate from the state \(\ket{\psi}\) to the state
\(\ket{x}\), given an evolution according to the Hamiltonian \(H\).</li>
<li>Explain how a quantum simulation of the Hamiltonian \(H\) may be performed, and determine
the number of oracle calls your simulation technique requires to obtain the solution
with high probability.</li>
</ol>
</div>

<div id="outline-container-orga4f04a7" class="outline-4">
<h4 id="orga4f04a7">Proof of (1)</h4>
<div class="outline-text-4" id="text-orga4f04a7">
<p>
Let \(\ket{\psi}=\alpha\ket{x}+\beta\ket{y}\). In the basis \((\ket{x},\ket{y})\)
</p>

<p>
\[
  H = \alpha I + \beta X + \alpha Z .
\]
</p>

<p>
Note that the term involving the identity \(I\) is not important since it only corresponds
to a global phase in \(e^{-\ii Ht}\). Recall from the book that the Hamiltonian
\(H_0=\proj{x}+\proj{\psi}\) is equal to \(I+\alpha(\beta X+\alpha Z)\). Hence
</p>

<p>
\[
  e^{-\ii Ht} \sim e^{-\ii H_0 \alpha \inv t}
\]
</p>

<p>
where \(\sim\) means <i>up to a global phase</i>. We already know from equation (6.23) that \(H_0\)
rotates \(\ket{\psi}\) into \(\ket{x}\) after time \(t=\pi/2\alpha\). Hence \(H\) does the same
after time \(t=\pi/2=O(1)\). QED.
</p>
</div>
</div>

<div id="outline-container-org333418d" class="outline-4">
<h4 id="org333418d">Solution to (2)</h4>
<div class="outline-text-4" id="text-org333418d">
<p>
First of all note that the two summands of \(H\) (I mean \(\ket{x}\bra{\psi}\) and
\(\ket{\psi}\bra {x}\)) are not self adjoint. Hence their exponentials
(e.g. \(e^{-\ii\ket{x}\bra{\psi}}\)) are not unitary. So we cannot simulate the summands by
a circuit.
</p>

<p>
On the other hand from the first part we already know that the exponential of \(H\) is
<i>essentially</i> a time-scaled version of the exponential of \(H_0\). So if we can simulate the
latter this yields a simulation of the former. The resource requirements are the same of
course. Not sure if this is the intended meaning of the exercise though.
</p>
</div>
</div>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.0.91 (<a href="https://orgmode.org">Org</a> mode 9.6.6)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>