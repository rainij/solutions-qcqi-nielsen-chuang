<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 10</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 10</h1>\[
\newcommand{\BB}{\mathbb{B}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\HH}{\mathbb{H}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\jj}{\mathrm{j}}
\newcommand{\kk}{\mathrm{k}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\RF}{\mathrm{RF}}
\newcommand{\sys}{\mathrm{sys}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\cx}{\mathrm{CX}}
\newcommand{\cy}{\mathrm{CY}}
\newcommand{\cz}{\mathrm{CZ}}
\newcommand{\cat}{\ket{\mathrm{cat}}}
\newcommand{\catp}[1]{\ket{\mathrm{cat}_{#1}}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % deprecated, use braket instead.
\newcommand{\braket}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\rank}[1]{\mathrm{rank}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\wt}[1]{\mathrm{wt}\left(#1\right)}
\newcommand{\prob}[1]{\mathrm{Prob}\left[#1\right]}
\newcommand{\orac}{\mathrm{Orac}}
\newcommand{\?}{} % sometimes I need just a separator other than whitespace
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga5e608c">Setup</a>
<ul>
<li><a href="#orgb6ae7d1">Imports</a></li>
<li><a href="#chapter-10-utility-code">Utility code</a></li>
<li><a href="#org8474e84">Notation</a></li>
<li><a href="#orge8cf4d6">Stabilizer codes</a></li>
<li><a href="#chapter-10-css-as-stabilizer">CSS codes in the stabilizer formalism</a></li>
</ul>
</li>
<li><a href="#orgd95b2d1">Exercises</a>
<ul>
<li><a href="#org2695255">Exercise 10.1</a></li>
<li><a href="#org655d907">Exercise 10.2</a></li>
<li><a href="#org97aaf0d">Exercise 10.3</a></li>
<li><a href="#org15eed7c">Exercise 10.4</a></li>
<li><a href="#org4491027">Exercise 10.5</a></li>
<li><a href="#org540c24d">Exercise 10.6</a></li>
<li><a href="#orgb276f36">Exercise 10.7</a></li>
<li><a href="#org63ff6a4">Exercise 10.8</a></li>
<li><a href="#orgec35081">Exercise 10.9</a></li>
<li><a href="#org3149f74">Exercise 10.10</a></li>
<li><a href="#orgfc2ae3f">Exercise 10.11</a></li>
<li><a href="#orgef8400a">Exercise 10.12</a></li>
<li><a href="#org7f3f392">Exercise 10.13</a></li>
<li><a href="#org32930e3">Exercise 10.14</a></li>
<li><a href="#orga1c45ef">Exercise 10.15</a></li>
<li><a href="#org650743c">Exercise 10.16</a></li>
<li><a href="#org431b41d">Exercise 10.17</a></li>
<li><a href="#exercise-10.18">Exercise 10.18</a></li>
<li><a href="#org6a84211">Exercise 10.19</a></li>
<li><a href="#exercise-10.20">Exercise 10.20</a></li>
<li><a href="#org47ad261">Exercise 10.21 (Singleton bound)</a></li>
<li><a href="#orgab97920">Exercise 10.22</a></li>
<li><a href="#org45d6190">Exercise 10.23</a></li>
<li><a href="#org3dd9e2c">Exercise 10.24</a></li>
<li><a href="#org0bd0704">Exercise 10.25</a></li>
<li><a href="#orgddc0e7d">Exercise 10.26</a></li>
<li><a href="#orgdec3914">Exercise 10.27</a></li>
<li><a href="#org3f62e9b">Exercise 10.28</a></li>
<li><a href="#org1ad2418">Exercise 10.29</a></li>
<li><a href="#orgdedc9b8">Exercise 10.30</a></li>
<li><a href="#orgd1d2008">Exercise 10.31</a></li>
<li><a href="#exercise-10.32">Exercise 10.32</a></li>
<li><a href="#exercise-10.33">Exercise 10.33</a></li>
<li><a href="#org2139687">Exercise 10.34</a></li>
<li><a href="#exercise-10.35">Exercise 10.35</a></li>
<li><a href="#org790eb4b">Exercise 10.36</a></li>
<li><a href="#orgdb4583b">Exercise 10.37</a></li>
<li><a href="#org0cb0aa2">Exercise 10.38</a></li>
<li><a href="#exercise-10.39">Exercise 10.39</a></li>
<li><a href="#orgea4223a">Exercise 10.40</a></li>
<li><a href="#orgb0f089f">Exercise 10.41</a></li>
<li><a href="#orgdc7b506">Exercise 10.42</a></li>
<li><a href="#orgcf27ad7">Exercise 10.43</a></li>
<li><a href="#exercise-10.44">Exercise 10.44</a></li>
<li><a href="#org2f461db">Exercise 10.45 (Correcting located errors)</a></li>
<li><a href="#org84aec97">Exercise 10.46</a></li>
<li><a href="#org20d1135">Exercise 10.47</a></li>
<li><a href="#orgde81c5d">Exercise 10.48</a></li>
<li><a href="#org95edcfe">Exercise 10.49</a></li>
<li><a href="#org1c174f9">Exercise 10.50</a></li>
<li><a href="#org00c7292">Exercise 10.51</a></li>
<li><a href="#orgeac7242">Exercise 10.52</a></li>
<li><a href="#exercise-10.53">Exercise 10.53</a></li>
<li><a href="#orgc5d2f05">Exercise 10.54</a></li>
<li><a href="#org6d146e0">Exercise 10.55</a></li>
<li><a href="#org32fd85a">Exercise 10.56</a></li>
<li><a href="#exercise-10.57">Exercise 10.57</a></li>
<li><a href="#org1371cfc">Exercise 10.58</a></li>
<li><a href="#org9b28084">Exercise 10.59</a></li>
<li><a href="#org8f6b7a5">Exercise 10.60</a></li>
<li><a href="#org537dc1d">Exercise 10.61</a></li>
<li><a href="#org03eacbc">Exercise 10.62</a></li>
<li><a href="#org0414a45">Exercise 10.63</a></li>
<li><a href="#orgdbd2d68">Exercise 10.64 (Back propagation of errors)</a></li>
<li><a href="#exercise-10.65">Exercise 10.65</a></li>
<li><a href="#orgbdcea7b">Exercise 10.66 (Fault-tolerant \(\pi/8\) gate construction)</a></li>
<li><a href="#exercise-10.67">Exercise 10.67</a></li>
<li><a href="#org64d46ec">Exercise 10.68 (Fault-tolerant Toffoli gate construction)</a></li>
<li><a href="#orgf405179">Exercise 10.69</a></li>
<li><a href="#org6eac808">Exercise 10.70</a></li>
<li><a href="#orgcd1850f">Exercise 10.71</a></li>
<li><a href="#org16d854f"><span class="todo WIP">WIP</span> Exercise 10.72 (Fault-tolerant Toffoli ancilla state construction)</a></li>
<li><a href="#exercise-10.73">Exercise 10.73 (Fault-tolerant encoded state construction)</a></li>
<li><a href="#org2e09cdf">Exercise 10.74</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga5e608c" class="outline-2">
<h2 id="orga5e608c">Setup</h2>
<div class="outline-text-2" id="text-orga5e608c">
</div>
<div id="outline-container-orgb6ae7d1" class="outline-3">
<h3 id="orgb6ae7d1">Imports</h3>
<div class="outline-text-3" id="text-orgb6ae7d1">
<div class="org-src-container">
<pre class="src src-sage" id="org37a355a"><span class="org-keyword">from</span> utils_sage <span class="org-keyword">import</span> ket, kron, trace, Id, X, Y, Z, Id2, CCX
<span class="org-keyword">from</span> chapter_8_sage <span class="org-keyword">import</span> make_operation
</pre>
</div>

<p>
Python:
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgb60d5f8"><span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> product

<span class="org-keyword">from</span> qiskit.quantum_info <span class="org-keyword">import</span> Pauli, Clifford
<span class="org-keyword">from</span> qiskit.circuit <span class="org-keyword">import</span> QuantumCircuit, Gate, ControlledGate
<span class="org-keyword">from</span> qiskit.circuit.library <span class="org-keyword">import</span> CXGate
</pre>
</div>
</div>
</div>
<div id="outline-container-chapter-10-utility-code" class="outline-3">
<h3 id="chapter-10-utility-code">Utility code</h3>
<div class="outline-text-3" id="text-chapter-10-utility-code">
<div class="org-src-container">
<pre class="src src-sage" id="org9bf5a79"><span class="org-variable-name">g</span> <span class="org-operator">=</span> SR.var(<span class="org-string">"g"</span>, domain<span class="org-operator">=</span><span class="org-string">"positive"</span>)
<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> <span class="org-operator">=</span> SR.var(<span class="org-string">"a b"</span>, domain<span class="org-operator">=</span><span class="org-string">"complex"</span>)
assume(g <span class="org-operator">&lt;=</span> 1)
</pre>
</div>

<p>
The Pauli gates on two and three qubits:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org4d2c059"><span class="org-keyword">def</span> <span class="org-function-name">make_multi</span>(gate, num_qubits):
    <span class="org-doc">"""Given a single qubit gate G, make all G_j for j=1..num_qubits."""</span>
    <span class="org-variable-name">gs</span> <span class="org-operator">=</span> [Id]<span class="org-operator">*</span>num_qubits
    <span class="org-keyword">return</span> <span class="org-builtin">tuple</span>([kron(<span class="org-operator">*</span>(gs[:i]<span class="org-operator">+</span>[gate]<span class="org-operator">+</span>gs[i<span class="org-operator">+</span>1:])) <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_qubits)])

<span class="org-variable-name">II</span> <span class="org-operator">=</span> Id2
<span class="org-variable-name">ZI</span>, <span class="org-variable-name">IZ</span> <span class="org-operator">=</span> make_multi(Z, 2)
<span class="org-variable-name">XI</span>, <span class="org-variable-name">IX</span> <span class="org-operator">=</span> make_multi(X, 2)
<span class="org-variable-name">YI</span>, <span class="org-variable-name">IY</span> <span class="org-operator">=</span> make_multi(Y, 2)

<span class="org-variable-name">ZII</span>, <span class="org-variable-name">IZI</span>, <span class="org-variable-name">IIZ</span> <span class="org-operator">=</span> make_multi(Z, 3)
<span class="org-variable-name">XII</span>, <span class="org-variable-name">IXI</span>, <span class="org-variable-name">IIX</span> <span class="org-operator">=</span> make_multi(X, 3)
<span class="org-variable-name">YII</span>, <span class="org-variable-name">IYI</span>, <span class="org-variable-name">IIY</span> <span class="org-operator">=</span> make_multi(Y, 3)
</pre>
</div>

<p>
The following functions return the string representations of generators of various codes
we encounter in the book
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org713e536"><span class="org-keyword">def</span> <span class="org-function-name">generators_5qubit_code_repr</span>():
    <span class="org-keyword">return</span> [
        <span class="org-string">"XZZXI"</span>,
        <span class="org-string">"IXZZX"</span>,
        <span class="org-string">"XIXZZ"</span>,
        <span class="org-string">"ZXIXZ"</span>,
    ]

<span class="org-keyword">def</span> <span class="org-function-name">generators_steane_code_repr</span>():
    <span class="org-keyword">return</span> [
        <span class="org-string">"IIIXXXX"</span>,
        <span class="org-string">"IXXIIXX"</span>,
        <span class="org-string">"XIXIXIX"</span>,
        <span class="org-string">"IIIZZZZ"</span>,
        <span class="org-string">"IZZIIZZ"</span>,
        <span class="org-string">"ZIZIZIZ"</span>,
    ]

<span class="org-keyword">def</span> <span class="org-function-name">generators_steane_code_standard_repr</span>():
    <span class="org-keyword">return</span> [
        <span class="org-string">"XIIIXXX"</span>,
        <span class="org-string">"IXIXIXX"</span>,
        <span class="org-string">"IIXXXXI"</span>,
        <span class="org-string">"ZIZZIIZ"</span>,
        <span class="org-string">"IZZIZIZ"</span>,
        <span class="org-string">"ZZZIIZI"</span>,
    ]

<span class="org-keyword">def</span> <span class="org-function-name">generators_shor_code_repr</span>():
    <span class="org-keyword">return</span> [
        <span class="org-string">"ZZIIIIIII"</span>,
        <span class="org-string">"IZZIIIIII"</span>,
        <span class="org-string">"IIIZZIIII"</span>,
        <span class="org-string">"IIIIZZIII"</span>,
        <span class="org-string">"IIIIIIZZI"</span>,
        <span class="org-string">"IIIIIIIZZ"</span>,
        <span class="org-string">"XXXXXXIII"</span>,
        <span class="org-string">"IIIXXXXXX"</span>,
    ]
</pre>
</div>

<p>
The following code computes the check matrix from the string representation:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org4c3153c"><span class="org-keyword">def</span> <span class="org-function-name">generators_to_check_matrix</span>(generators: <span class="org-builtin">list</span>[<span class="org-builtin">str</span>]):
    <span class="org-doc">"""Taking a list of string representations of the generators for some code this</span>
<span class="org-doc">    returns the corresponding check matrix."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">xbit</span>(pauli: <span class="org-builtin">str</span>):
        <span class="org-keyword">if</span> pauli <span class="org-operator">==</span> <span class="org-string">"X"</span> <span class="org-keyword">or</span> pauli <span class="org-operator">==</span> <span class="org-string">"Y"</span>:
            <span class="org-keyword">return</span> 1
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 0

    <span class="org-keyword">def</span> <span class="org-function-name">zbit</span>(pauli: <span class="org-builtin">str</span>):
        <span class="org-keyword">if</span> pauli <span class="org-operator">==</span> <span class="org-string">"Z"</span> <span class="org-keyword">or</span> pauli <span class="org-operator">==</span> <span class="org-string">"Y"</span>:
            <span class="org-keyword">return</span> 1
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 0

    <span class="org-variable-name">check_matrix</span> <span class="org-operator">=</span> []

    <span class="org-keyword">for</span> g <span class="org-keyword">in</span> generators:
        <span class="org-variable-name">gj</span> <span class="org-operator">=</span> [xbit(p) <span class="org-keyword">for</span> p <span class="org-keyword">in</span> g]
        <span class="org-variable-name">gj</span> <span class="org-operator">+=</span> [zbit(p) <span class="org-keyword">for</span> p <span class="org-keyword">in</span> g]

        check_matrix.append(gj)

    <span class="org-keyword">return</span> matrix(GF(2), check_matrix)
</pre>
</div>

<p>
The following utility function helps us in performing elementary row and column operations
on check matrices (see <a href="#exercise-10.57">exercise 10.57</a> on how to use it).
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgf49ece5"><span class="org-keyword">def</span> <span class="org-function-name">transform_check_matrix</span>(check_matrix: matrix, trafos: <span class="org-builtin">list</span>):
    <span class="org-doc">"""Apply a list of row/column transformations to a check matrix."""</span>
    <span class="org-variable-name">cm</span> <span class="org-operator">=</span> check_matrix
    <span class="org-variable-name">_</span>, <span class="org-variable-name">nn</span> <span class="org-operator">=</span> cm.dimensions()
    <span class="org-keyword">assert</span> nn <span class="org-operator">%</span> 2 <span class="org-operator">==</span> 0, <span class="org-string">"Expected even column dimension"</span>
    <span class="org-variable-name">n</span> <span class="org-operator">=</span> nn <span class="org-operator">/</span> 2

    <span class="org-keyword">for</span> t <span class="org-keyword">in</span> trafos:
        <span class="org-keyword">if</span> t[0] <span class="org-operator">==</span> <span class="org-string">"swap rows"</span>:
            <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> <span class="org-operator">=</span> t[1:]
            <span class="org-keyword">assert</span> i <span class="org-operator">&lt;</span> n <span class="org-keyword">and</span> j <span class="org-operator">&lt;</span> n, f<span class="org-string">"Expected i, j &lt; </span>{n}<span class="org-string">"</span>
            <span class="org-variable-name">cm</span> <span class="org-operator">=</span> cm.with_swapped_rows(i, j)
        <span class="org-keyword">elif</span> t[0] <span class="org-operator">==</span> <span class="org-string">"swap qubits"</span>:
            <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> <span class="org-operator">=</span> t[1:]
            <span class="org-keyword">assert</span> i <span class="org-operator">&lt;</span> n <span class="org-keyword">and</span> j <span class="org-operator">&lt;</span> n, f<span class="org-string">"Expected i, j &lt; </span>{n}<span class="org-string">"</span>
            <span class="org-variable-name">cm</span> <span class="org-operator">=</span> cm.with_swapped_columns(i, j)
            <span class="org-variable-name">cm</span> <span class="org-operator">=</span> cm.with_swapped_columns(n<span class="org-operator">+</span>i, n<span class="org-operator">+</span>j)
        <span class="org-keyword">elif</span> t[0] <span class="org-operator">==</span> <span class="org-string">"add row"</span>:
            <span class="org-variable-name">source</span>, <span class="org-variable-name">target</span> <span class="org-operator">=</span> t[1:]
            <span class="org-variable-name">cm</span> <span class="org-operator">=</span> cm.with_added_multiple_of_row(target, source, 1)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Unknown check matrix operation '</span>{t[0]}<span class="org-string">'"</span>)

    <span class="org-keyword">return</span> cm
</pre>
</div>

<p>
The following circuit can be used to construct the syndrome measuring circuits in qiskit
as shown in e.g. Figure 10.16:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">make_syndrome_circuit</span>(generators: <span class="org-builtin">list</span>[Pauli], with_barrier<span class="org-operator">=</span><span class="org-constant">False</span>):
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(generators) <span class="org-operator">!=</span> 0, <span class="org-string">"Need at least one Pauli operator"</span>

    <span class="org-variable-name">l</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(generators)
    <span class="org-variable-name">n</span> <span class="org-operator">=</span> generators[0].num_qubits
    <span class="org-variable-name">k</span> <span class="org-operator">=</span> n<span class="org-operator">-</span>l

    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>([g.num_qubits <span class="org-operator">==</span> n <span class="org-keyword">for</span> g <span class="org-keyword">in</span> generators]), \
        <span class="org-string">"Generators have to be of same size"</span>
    <span class="org-keyword">assert</span> k <span class="org-operator">&gt;=</span> 1, <span class="org-string">"Too many generators"</span>

    <span class="org-variable-name">qr_aux</span> <span class="org-operator">=</span> QuantumRegister(l, name<span class="org-operator">=</span><span class="org-string">"|0&gt;"</span>)
    <span class="org-variable-name">qr_phys</span> <span class="org-operator">=</span> QuantumRegister(n, name<span class="org-operator">=</span><span class="org-string">"q"</span>)

    <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(qr_aux, qr_phys)

    <span class="org-keyword">def</span> <span class="org-function-name">barrier</span>():
        <span class="org-keyword">if</span> with_barrier:
            qc.barrier()

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(l):
        qc.h(i)

    barrier()

    <span class="org-keyword">for</span> i, g <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(generators):
        <span class="org-variable-name">G</span> <span class="org-operator">=</span> g.to_instruction().control()
        qc.append(G, [i] <span class="org-operator">+</span> <span class="org-builtin">list</span>(<span class="org-builtin">range</span>(l, l<span class="org-operator">+</span>n)))
        barrier()

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(l):
        qc.h(i)

    <span class="org-keyword">return</span> qc
</pre>
</div>

<p>
For convenience the generators of some codes in the qiskit framework:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">generators_5qubit_code</span>():
    <span class="org-keyword">return</span> [
        Pauli(<span class="org-string">"XZZXI"</span>),
        Pauli(<span class="org-string">"IXZZX"</span>),
        Pauli(<span class="org-string">"XIXZZ"</span>),
        Pauli(<span class="org-string">"ZXIXZ"</span>),
    ]

<span class="org-keyword">def</span> <span class="org-function-name">generators_shor_code</span>():
    <span class="org-keyword">return</span> [
        Pauli(<span class="org-string">"ZZIIIIIII"</span>),
        Pauli(<span class="org-string">"IZZIIIIII"</span>),
        Pauli(<span class="org-string">"IIIZZIIII"</span>),
        Pauli(<span class="org-string">"IIIIZZIII"</span>),
        Pauli(<span class="org-string">"IIIIIIZZI"</span>),
        Pauli(<span class="org-string">"IIIIIIIZZ"</span>),
        Pauli(<span class="org-string">"XXXXXXIII"</span>),
        Pauli(<span class="org-string">"IIIXXXXXX"</span>),
    ]

<span class="org-keyword">def</span> <span class="org-function-name">generators_steane_code_standard</span>():
    <span class="org-comment-delimiter"># </span><span class="org-comment">standard form!</span>
    <span class="org-keyword">return</span> [
        Pauli(<span class="org-string">"XIIIXXX"</span>),
        Pauli(<span class="org-string">"IXIXIXX"</span>),
        Pauli(<span class="org-string">"IIXXXXI"</span>),
        Pauli(<span class="org-string">"ZIZZIIZ"</span>),
        Pauli(<span class="org-string">"IZZIZIZ"</span>),
        Pauli(<span class="org-string">"ZZZIIZI"</span>),
    ]
</pre>
</div>
</div>
</div>

<div id="outline-container-org8474e84" class="outline-3">
<h3 id="org8474e84">Notation</h3>
<div class="outline-text-3" id="text-org8474e84">
<p>
Below we use \(\BB=\mathrm{GF}(2)=\ZZ_2\) to denote the field of two elements. This models a
<i>bit</i>.
</p>
</div>
</div>

<div id="outline-container-orge8cf4d6" class="outline-3">
<h3 id="orge8cf4d6">Stabilizer codes</h3>
<div class="outline-text-3" id="text-orge8cf4d6">
<p>
The purpose of this section is to complement chapter 10.5. From the book I am missing some
concrete statement on how <i>exactly</i> stabilizer codes are characterized. I try to do this
in the <a href="#org12ffa94">fundamental theorem</a> of stabilizer codes below.
</p>

<p>
Let \(G_n\) be the Pauli group. As in the book let \(V_S=\{v|\forall\?g\in\?S:gv=v\}\) for a
subgroup \(S\) of \(G_n\). Note that any element of \(G_n\) can be represented as
</p>

<p>
<a id="org6fa30f7"></a>
\[
  g = \alpha \bigotimes_{j=1}^n N_j ,
\]
</p>

<p>
where \(\alpha\in\langle\ii\rangle=\{1,-1,\ii,-\ii\}\) and \(N_j\in\{I,X,Y,Z\}\). An easy to
prove but important observation is that
</p>

<dl class="org-dl">
<dt>Lemma</dt><dd>For all \(g,h\in\?G_n\) we have \(gh=\pm\?hg\). That is, if two elements of the
Pauli group do not commute then \(gh=-hg\).
<dl class="org-dl">
<dt>Proof</dt><dd>This directly follows from the commutator relations of the Pauli matrices:
\(MN=-NM\) for \(M,N\in\{X,Y,Z\}\) if \(M\neq\?N\), together with the <a href="#org6fa30f7">representation</a> of
\(g\in\?G_n\) given above. QED.</dd>
</dl></dd>
</dl>

<p>
Define a group homomorphism \(r:G_n\to\BB^{2n}\) by the following table
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">\(N_j\)</th>
<th scope="col" class="org-left">\(r(g)_j\)</th>
<th scope="col" class="org-left">\(r(g)_{n+j}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(I\)</td>
<td class="org-left">\(0\)</td>
<td class="org-left">\(0\)</td>
</tr>

<tr>
<td class="org-left">\(X\)</td>
<td class="org-left">\(1\)</td>
<td class="org-left">\(0\)</td>
</tr>

<tr>
<td class="org-left">\(Y\)</td>
<td class="org-left">\(1\)</td>
<td class="org-left">\(1\)</td>
</tr>

<tr>
<td class="org-left">\(Z\)</td>
<td class="org-left">\(0\)</td>
<td class="org-left">\(1\)</td>
</tr>
</tbody>
</table>

<p>
By group homomorphism we mean that \(r(gg')=r(g)+r(g')\) and \(r(g\inv)=-r(g)\) (note that
\(-r(g)=r(g)\) as we have \(\BB\) as the base field).
</p>

<p>
Let \(g_1,\ldots,g_l\in\?G_n\) and let \(S=\langle\?g_1,\ldots,g_l\rangle\). Early on in chapter 10.5 we have seen that
</p>

<p>
<a id="orge8602eb"></a>
</p>
<dl class="org-dl">
<dt>Lemma</dt><dd>If \(V_S\) is non-trivial then \(-I\notin\?S\) and all the \(g_j\) commute.
<dl class="org-dl">
<dt>Proof</dt><dd>See chapter 10.5.1 for the simple proof.</dd>
<dt>Remark</dt><dd>In Proposition 10.5 in the book the reverse direction is proved and moreover
it is shown that \(\dim(V_S)=2^k\) if \(l=n-k\).</dd>
</dl></dd>
</dl>

<p>
In the following we want to better understand the condition from the Lemma. Therefore let
us define the corresponding <b>check matrix</b> \(G\in\BB^{l\times2n}\) by
</p>

<p>
\[
  G_{ij} = r(g_i)_j
\]
</p>

<p>
<a id="orgfb3c93b"></a>
</p>
<dl class="org-dl">
<dt>Theorem</dt><dd><p>
Let \(\Lambda=X\otimes\?I_n\) and let
</p>

<p>
\[
  \beta = r(g)\Lambda r(h)^T \; (\in \BB) .
  \]
</p>

<p>
Then \(gh=(-1)^\beta\?hg\) for all \(g,h\in\?G_n\). In particular \(g\) and \(h\) commute iff
\(\beta=0\).
</p>
<dl class="org-dl">
<dt>Proof</dt><dd>See <a href="#exercise-10.33">exercise 10.33</a>.</dd>
</dl></dd>
</dl>

<p>
As a corollary we get a nice way to check whether \(S\) is abelian or not:
</p>

<p>
<a id="orgf1074bc"></a>
</p>
<dl class="org-dl">
<dt>Theorem</dt><dd>The \(g_1,\ldots,g_l\) commute iff \(G\Lambda\?G^T=0\in\BB^{l\times\?l}\).</dd>
</dl>

<p>
It is left to find a nice way to check whether \(-I\notin\?S\) and how to characterize
independent generators. This is the purpose of the following series of theorems.
</p>

<p>
<a id="org89f44cf"></a>
</p>
<dl class="org-dl">
<dt>Theorem</dt><dd><p>
The following assertions are equivalent
</p>
<ol class="org-ol">
<li>\(-I\notin\?S\) .</li>
<li>\(r\) is injective .</li>
</ol>

<dl class="org-dl">
<dt>Proof</dt><dd><dl class="org-dl">
<dt>(1) → (2)</dt><dd>Note that \(r\) is injective if \(r(g)=0\) has only one solution
(\(g=I\)). Clearly \(r(g)=0\) iff \(N_j=I\) for all \(j\). Hence \(g=\pm\?I\) or
\(g=\pm\ii\?I\). By (1) only \(g=I\) is possible.</dd>
<dt>(2) → (1)</dt><dd>This follows from \(r(-I)=0=r(I)\). Hence \(r\) cannot be injective
whenever \(-I\in\?S\).</dd>
</dl>
<p>
QED.
</p></dd>
</dl></dd>
</dl>

<p>
<a id="org2e38d91"></a>
</p>
<dl class="org-dl">
<dt>Theorem</dt><dd><p>
Assume that \(-I\notin\?S\). The following assertions are equivalent:
</p>
<ol class="org-ol">
<li>The \(g_1,\ldots,g_l\) are independent.</li>
<li>\(\rank{G}=l\).</li>
</ol>

<p>
The implication <b>(2) → (1)</b> holds even without assuming \(-I\notin\?S\).
</p>
<dl class="org-dl">
<dt>Proof</dt><dd><dl class="org-dl">
<dt>(1) → (2)</dt><dd>This follows from the fact that an injective group homomorphism maps
independent sets to independent sets. By a <a href="#org89f44cf">previous theorem</a> \(r\) is injective. Hence
the rows of \(G\) are independent as elements of the group \(\BB^{2n}\). But this means
they are independent as elements of the vector space \(\BB^{2n}\).</dd>
<dt>(2) → (1)</dt><dd>From (2) we deduce that the \(r(g_j)\) are independent. But this implies
that the \(g_j\) must be independent. This holds even without the assumption that \(r\)
is injective.</dd>
</dl>
<p>
QED.
</p></dd>
</dl></dd>
</dl>

<p>
<a id="org0c4f151"></a>
</p>
<dl class="org-dl">
<dt>Theorem</dt><dd><p>
Assume that \(\rank{G}=l\). The following assertions are equivalent
</p>
<ol class="org-ol">
<li>\(-I\notin\?S\),</li>
<li>\(\alpha_j=\pm1\) for all \(j\),</li>
</ol>

<p>
<a href="#org6fa30f7">where</a> \(g_j=\alpha_j\bigotimes_jN_j\).
</p>
<dl class="org-dl">
<dt>Proof</dt><dd><dl class="org-dl">
<dt>(1) → (2)</dt><dd>Since \(g_j=\alpha_j^2I=\pm\?I\) we see that \(-I\notin\?S\) implies
\(\alpha_j\neq\pm\ii\) for all \(j\).</dd>

<dt>(2) → (1)</dt><dd><p>
Assume to the contrary that \(-I\in\?S\). There is a non-zero \(x\in\ZZ^l\)
such that \(-I=\prod_jg_j^{x_j}\) (we may assume that \(x_j\in\{0,1,2,3\}\)). Hence
</p>

<p>
\[
      0 = r(-I) = \sum_{j=1}^n x_j r(g_j) = x G .
      \]
</p>

<p>
Since \(\rank{G}=l\) (as matrix over \(\BB\)) we have that \(x_j\in\{0,2\}\) for all
\(j\). But \(g_j^2=\alpha_j^2I\) and hence \(\alpha_j=\pm\ii\) for at least one \(j\) -
contradicting (2).
</p></dd>
</dl>
<p>
QED.
</p></dd>
</dl></dd>
</dl>

<p>
We are in a position to state and prove the main theorem of this section:
</p>

<p>
<a id="org12ffa94"></a>
</p>
<dl class="org-dl">
<dt>Fundamental theorem on stabilizer codes</dt><dd><p>
The non-trivial stabilizer codes are given by
all check matrices \(G\in\BB^{l\times2n}\) (for any \(n\) and \(l\leq\?n-1\)), corresponding
to a set of generators \(g_1,\ldots,g_l\in\?G_n\), which satisfy
</p>
<ol class="org-ol">
<li>\(\alpha_j=\pm1\) (c.f. <a href="#org6fa30f7">representation</a> of \(g_j\)),</li>
<li>\(\rank{G}=l\) ,</li>
<li>\(G\Lambda\?G^T=0\in\BB^{l\times\?l}\) .</li>
</ol>

<p>
In that case the \(g_j\) commute, are independent (in the group theoretical sense) and the
dimension of the code is \(2^{n-l}\).
</p>

<p>
Moreover, two stabilizer codes \(C\) and \(C'\) which have the same check matrix \(G\) (and
hence only differ in the signs \(\alpha_j\)) are equivalent in the sense that there exists
a Pauli operator \(g\in\?G_n\) such that \(C'=gC\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Because of the statement about equivalent stabilizer codes one might set
\(\alpha_j=1\) for simplicity. Under this convention the check matrix describes the
stabilizer code completely.</dd>

<dt>Proof</dt><dd><p>
Let \(V_S\) be a non-trivial stabilizer code. Let \(g_1,\ldots,g_l\) be a an
independent set of generators. By proposition 10.5 (or the <a href="#orge8602eb">Lemma</a> above) we have
\(-I\notin\?S\) and all \(g_j\) commute. By independence of \(g_j\) and \(-I\notin\?S\) we
<a href="#org2e38d91">deduce</a> that \(\rank{G}=l\). From this and again using \(-I\notin\?S\) we <a href="#org0c4f151">deduce</a> that
\(\alpha_j=\pm1\) for all \(j\). Finally, the fact that the generators commute is
<a href="#orgf1074bc">equivalent</a> to \(G\Lambda\?G^T=0\). This shows one part of the claim.
</p>

<p>
Let us now assume the conditions 1 to 3. From (1) and (2) we <a href="#org0c4f151">deduce</a> that
\(-I\notin\?S\). (3) is <a href="#orgf1074bc">equivalent</a> to all \(g_j\) commuting. By proposition 10.5 this
implies that \(V_S\) is non-trivial.
</p>

<p>
The claim about the dimension of the code is contained in proposition 10.5.
</p>

<p>
Finally let us show that two stabilizer codes which differ only in \(\alpha\) are
equivalent in the sense stated. For concreteness let \(C\) be the code with all
\(\alpha_j=1\) and let \(C'\) be another code with the same check matrix and signs
\(\alpha_j=\chi_j=\pm1\). The claim actually follows from the proof of proposition
10.5. In fact, if \(P^{(0,\ldots,0)}_S\) is the projector of \(C\) then clearly
\(P^{\chi}_S\) is the projector of \(C'\). The proof showed that there exists a
\(g_{\chi}\in\?G_n\) such that
\(g_{\chi}P^{(0,\ldots,0)}_Sg_{\chi}^\dagger=P^{\chi}_S\). QED.
</p></dd>
</dl></dd>
</dl>
</div>
</div>

<div id="outline-container-chapter-10-css-as-stabilizer" class="outline-3">
<h3 id="chapter-10-css-as-stabilizer">CSS codes in the stabilizer formalism</h3>
<div class="outline-text-3" id="text-chapter-10-css-as-stabilizer">
<p>
There is a subtle error on page 456 which explains how the parity check matrices of a CSS
code map to the generators in the stabilizer formalism.
</p>

<p>
They say that the \(g_j\) containing the \(X\) correspond to the check matrix of \(C_1\) and
that the \(g_j\) containing the \(Z\) correspond to the check matrix of \(C_2^\top\). Actually
it is the other way round. This doesn't affect the example (Steane code) because the
parity check matrices are identical for \(C_1\) and \(C_2^\top\). But it might be
confusing. Hence I take the opportunity to lay out the translation for the general case.
</p>

<p>
Recall that a \([n,k_1-k_2]\) CSS code is constructed from two linear codes \(C_1\)
(\([n,k_1]\)) and \(C_2\) (\([n,k_2]\)) with \(C_2\subset\?C_1\). The code words are given by
</p>

<p>
\[
  \ket{x+C_2} = \frac{1}{\sqrt{\abs{C_2}}} \sum_{y\in C_2} \ket{x + y}
\]
</p>

<p>
where \(x+C_2\) is from the quotient space \(C_1/C_2\). Let \(A\in\BB^{(n-k_1)\times\?n}\) be
the parity check matrix of \(C_1\) and let \(B\in\BB^{k_2\times\?n}\) be the parity check
matrix of \(C_2^\top\). Let
</p>

<p>
<a id="orgc4f9b7b"></a>
</p>
\begin{align*}
  g_i &= \bigotimes_{j=1}^n X^{B_{ij}}, \text{ for } i=1..k_2, \\
  g_{k_2+i} &= \bigotimes_{j=1}^n Z^{A_{ij}}, \text{ for } i=1..(n-k_1). \\
\end{align*}

<p>
<a id="org03b346c"></a>
</p>
<dl class="org-dl">
<dt>Theorem</dt><dd><a href="#orgc4f9b7b">These</a> \(n-(k_1-k_2)\) Pauli operators are the stabilizer for the CSS code of
\(C_1\) over \(C_2\).
<dl class="org-dl">
<dt>Proof</dt><dd>We provide a proof in the <a href="#exercise-10.32-solution">solution</a> of exercise 10.32.</dd>
</dl></dd>
</dl>

<p>
The check matrix of the CSS code is given by the following block matrix
</p>

<p>
\[
  \begin{bmatrix} B & 0 \\ 0 & A \end{bmatrix} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-orgd95b2d1" class="outline-2">
<h2 id="orgd95b2d1">Exercises</h2>
<div class="outline-text-2" id="text-orgd95b2d1">
</div>
<div id="outline-container-org2695255" class="outline-3">
<h3 id="org2695255">Exercise 10.1</h3>
<div class="outline-text-3" id="text-org2695255">
<p>
Verify that the encoding circuit in Figure 10.2 works as claimed.
</p>

<pre class="example">

|psi&gt;: ──■────■──
       ┌─┴─┐  │
|0&gt;_0: ┤ X ├──┼──
       └───┘┌─┴─┐
|0&gt;_1: ─────┤ X ├
            └───┘
</pre>
</div>


<div id="outline-container-org975a4d8" class="outline-4">
<h4 id="org975a4d8">Solution</h4>
<div class="outline-text-4" id="text-org975a4d8">
<p>
This is really just observing that the circuit acts like this on the <i>relevant</i> basis
states
</p>

\begin{align*}
  \ket{000} &\mapsto \ket{000} , \\
  \ket{100} &\mapsto \ket{111} . \\
\end{align*}

<p>
The rest follows by linearity.
</p>
</div>
</div>
</div>

<div id="outline-container-org655d907" class="outline-3">
<h3 id="org655d907">Exercise 10.2</h3>
<div class="outline-text-3" id="text-org655d907">
<p>
The action of the bit flip channel can be described by the quantum operation
\(\calE(\rho)=(1-p)\rho+pX\rho\?X\). Show that this may be given an alternate operator-sum
representation, as \(\calE(\rho)=(1-2p)\rho+2pP_+\rho\?P_++2pP_-\rho\?P_-\) where \(P_+\) and
\(P_-\) are projectors onto the \(+1\) and \(-1\) eigenstates of \(X\),
\((\ket{0}+\ket{1})/\sqrt{2}\) and \((\ket{0}+\ket{1})/\sqrt{2}\) respectively.  This latter
representation can be understood as a model in which the qubit is left alone with
probability \(1-2p\), and is ‘measured’ by the environment in the \(\ket{+}\), \(\ket{-}\) basis
with probability \(2p\).
</p>
</div>

<div id="outline-container-org38929de" class="outline-4">
<h4 id="org38929de">Proof</h4>
<div class="outline-text-4" id="text-org38929de">
<p>
Note that \(X=P_+-P_-\) and \(I=P_++P_-\). Hence
</p>

<p>
\[
  X\rho X = P_+\rho P_+ + P_-\rho P_- - (P_+\rho P_- + P_-\rho P_+)
  = 2(P_+\rho P_+ + P_-\rho P_-) - I\rho I .
\]
</p>

<p>
Hence
</p>

<p>
\[
  \calE(\rho) = (1 - 2p)\rho + 2p (P_+\rho P_+ + P_-\rho P_-) .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org97aaf0d" class="outline-3">
<h3 id="org97aaf0d">Exercise 10.3</h3>
<div class="outline-text-3" id="text-org97aaf0d">
<p>
Show by explicit calculation that measuring \(Z_1Z_2\) followed by \(Z_2Z_3\) is equivalent,
up to labeling of the measurement outcomes, to measuring the four projectors defined by
(10.5)–(10.8), in the sense that both procedures result in the same measurement statistics
and post-measurement states.
</p>
</div>

<div id="outline-container-org0b04ee8" class="outline-4">
<h4 id="org0b04ee8">Proof</h4>
<div class="outline-text-4" id="text-org0b04ee8">
<p>
Let us define the following projectors
</p>

\begin{align*}
  P_{ijk} &= \proj{i}\otimes\proj{j}\otimes\proj{k} , \\
  P_{ijx} &= \proj{i}\otimes\proj{j}\otimes I , \\
  P_{xij} &= I\otimes \proj{i}\otimes\proj{j} .
\end{align*}

<p>
That is, the \(x\) has a special meaning and just stands for the place where the identity
acts. Define \(P_{ixx}\) etc analogously. Note that e.g. \(P_{ixx}P_{xjx}=P_{ijx}\). Since
\(Z_1=P_{0xx}-P_{1xx}\), \(Z_2=P_{x0x}-P_{x1x}\), \(Z_3=P_{xx0}-P_{xx1}\) we have the following
spectral decomposition of the observables we are interested in:
</p>

\begin{align*}
  Z_1Z_2 &= P_{00x} + P_{11x} - P_{01x} - P_{10x} , \\
  Z_2Z_3 &= P_{x00} + P_{x11} - P_{x01} - P_{x10} .
\end{align*}

<p>
Let \(P_j\) for \(j=0..3\) be the projectors from (10.5) to (10.8). If we measure for example
\(+1\) for \(Z_1Z_2\) and \(+1\) for \(Z_2Z_3\) this corresponds to the projection (note: the
order of the projections is not important due to commutativity)
</p>

<p>
\[
  (+1, +1):\; (P_{00x} + P_{11x})(P_{x00} + P_{x11}) = P_{000} + P_{111} = P_0 .
\]
</p>

<p>
In the same way the other three measurements can be mapped to the \(P_j\) too:
</p>

\begin{align*}
  &(+1, -1):\; (P_{00x} + P_{11x})(P_{x01} + P_{x10}) = P_{001} + P_{110} = P_3 , \\
  &(-1, +1):\; (P_{01x} + P_{10x})(P_{x00} + P_{x11}) = P_{100} + P_{011} = P_1 , \\
  &(-1, -1):\; (P_{01x} + P_{10x})(P_{x01} + P_{x10}) = P_{101} + P_{010} = P_2 .
\end{align*}

<p>
Hence the projectors are the same, just re-labeled. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org15eed7c" class="outline-3">
<h3 id="org15eed7c">Exercise 10.4</h3>
<div class="outline-text-3" id="text-org15eed7c">
<p>
Consider the three qubit bit flip code. Suppose we had performed the error syndrome
measurement by measuring the eight orthogonal projectors corresponding to projections onto
the eight computational basis states.
</p>

<ol class="org-ol">
<li>Write out the projectors corresponding to this measurement, and explain how the
measurement result can be used to diagnose the error syndrome: either no bits flipped or
bit number \(j\) flipped, where \(j\) is in the range one to three.</li>
<li>Show that the recovery procedure works only for computational basis states.</li>
<li>What is the minimum fidelity for the error-correction procedure?</li>
</ol>
</div>

<div id="outline-container-org2adb61a" class="outline-4">
<h4 id="org2adb61a">Solution for part 1</h4>
<div class="outline-text-4" id="text-org2adb61a">
<p>
The projectors are just \(P_j=\proj{j}\) for \(j=0..7\) (note that the binary representations
for the numbers from \(0\) to \(7\) are \(000\), \(001\), \(010\), \(011\), \(100\), \(101\), \(110\),
\(111\)). A corresponding observable distinguishing each projector would be
\(A=\sum_jj\proj{j}\).
</p>

<p>
Recall that the encoded state is \(\ket{\psi}=a\ket{000}+b\ket{111}\). Let \(k=0\), \(k=1\),
\(k=2\), \(k=3\) denote <i>no error</i>, <i>error in qubit 1, 2, 3</i>, respectively. Let \(M_k\) be the
set of possible measurements for the given value of \(k\). We have
</p>

<p>
<a id="org2fcc8f4"></a>
</p>
\begin{align*}
  M_0 &= \{0, 7\} , \\
  M_1 &= \{1, 6\} , \\
  M_2 &= \{2, 5\} , \\
  M_3 &= \{4, 3\} .
\end{align*}

<p>
Moreover, measuring \(0,1,2,4\) happens with probability \(\abs{a}^2\) and measuring \(7,6,5,3\)
happens with probability \(\abs{b}^2\) (conditioned on a fixed value for \(j\)). Since the
four sets are disjoint we can infer the error (the value of \(k\)) from the measurement
(e.g. measuring \(1\) or \(6\) implies that the error was \(k=1\) (with certainty if only one of
the three errors "is allowed" to happen)).
</p>
</div>
</div>

<div id="outline-container-org4ea2e88" class="outline-4">
<h4 id="org4ea2e88">Solution for part 2</h4>
<div class="outline-text-4" id="text-org4ea2e88">
<p>
If we measure \(j\) and infer the error \(k\) <a href="#org2fcc8f4">according to the sets</a> \(M_k\) we would correct it
by applying \(X_k\) to the state. In other words, the following quantum operation \(\calR\)
performs the syndrome measurement followed by the recovery:
</p>

\begin{align*}
  E_0 &= P_0, \\ E_1 &= X_1P_1, \\ E_2 &= X_2P_2, \\ E_3 &= X_3P_3, \\
  E_4 &= X_3P_4, \\ E_5 &= X_2P_5, \\ E_6 &= X_1P_6, \\ E_7 &= P_7 .
\end{align*}

<p>
Note that \(\calR\) is indeed trace-preserving (\(\sum_jE_j^\dagger\?E_j)=I\)). Recall
\(\ket{\psi}=a\ket{000}+b\ket{111}\). Then (the <i>no error</i> case)
</p>

<p>
\[
  \calR(\ket{\psi}) = \abs{a}^2 \proj{000} + \abs{b}^2 \proj{111} .
\]
</p>

<p>
The same formula holds for \(\ket{\psi}\) replaced by \(X_k\ket{\psi}\) (\(k=1..3\)). Hence, for
the following noise channel
</p>

<p>
\[
  \calE(\rho) = (1-p)\rho + \sum_{k=1}^3 p_k X_k \rho X_k
\]
</p>

<p>
where \(\sum_kp_k=p\) (this implies trace-preservation, but we could more generally assume
\(\ldots\leq\?p\), meaning that with certain probability "something else" happens), which
stands for having at most one bit-flip (with probability \(p_k\) at position \(k\)), we have
</p>

<p>
\[
  \calR\circ\calE(\ket{\psi}) = \abs{a}^2 \proj{000} + \abs{b}^2 \proj{111} .
\]
</p>

<p>
(If \(\calE\) was not trace-preserving the RHS would have a factor \(1-p+\sum_jp_j\).) Hence
the bit-flip error gets indeed corrected, but unwanted side effects happen too. The final
state after recovery is either \(\ket{000}\) (probability \(\abs{a}^2\)) or \(\ket{111}\)
(probability \(\abs{b}^2\)). That is the state collapses to a basis state. This is only
correct if \(\ket{\psi}\) was already in a basis state (\(a=0\) or \(b=0\)) - which is the claim
of part 2.
</p>
</div>
</div>

<div id="outline-container-orgc821372" class="outline-4">
<h4 id="orgc821372">Solution for part 3</h4>
<div class="outline-text-4" id="text-orgc821372">
<p>
Let us consider two cases:
</p>

<ol class="org-ol">
<li>We do not get to know the results of the syndrome measurement.</li>
<li>We get to know the results of the syndrome measurement.</li>
</ol>

<p>
In case 1 the whole error correction procedure is given by \(\calR\) from the solution of
part 2. Let \(\rho=\calR\circ\calE(\ket{\psi})\). Then
</p>

<p>
\[
  F(\ket{\psi},\rho) = \sqrt{\bra{\psi}\rho\ket{\psi}} = \sqrt{\abs{a}^4 + \abs{b}^4} .
\]
</p>

<p>
Since \(\abs{a}^2+\abs{b}^2=1\) the minimum occurs at \(\abs{a}^2=\abs{b}^2=1/2\). Hence
\(F\geq1/\sqrt{2}\) in that case.
</p>

<p>
In case 2 the post-correction state \(\rho\) is either \(\ket{000}\) (probability \(\abs{a}^2\))
or \(\ket{111}\) (probability \(\abs{b}^2\)). Hence
</p>

<p>
\[
  F(\ket{\psi},\rho) \in \left\{\sqrt{\braket{\psi}{i_L}\braket{i_L}{\psi}} \; \middle| \; i\in\{0,1\}\right\}
  = \{\abs{a}, \abs{b}\} ,
\]
</p>

<p>
where the first alternative occurs with probability \(\abs{a}^2\) and the second one with
\(\abs{b}^2\).
</p>

<p>
In both cases the minimial fidelity does not depend on the specifics of the noise model
and in particular is always bad if \(\abs{a}\) and \(\abs{b}\) are bounded away from \(0\) (or
equivalently, from \(1\)).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
The minimum fidelity of case 1 is the weighted root square mean of the two
possible fidelities of case 2. The weights are \(\abs{a}^2\) and \(\abs{b}^2\). See e.g.
<a href="https://en.wikipedia.org/wiki/Generalized_mean">generalized mean</a> on wikipedia for more infos. To make this more apparent consider
\(\sigma=p\proj{0}+(1-p)\proj{1}\) (and \(\ket{\psi}=a\ket{0}+b\ket{1}\)):
</p>

<p>
\[
  F(\ket{\psi},\sigma) = \sqrt{\bra{\psi}\sigma\ket{\psi}} = \sqrt{p\abs{a}^2+(1-p)\abs{b}^2} .
  \]
</p>

<p>
Here \(p\) and \(1-p\) are the weights.
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org4491027" class="outline-3">
<h3 id="org4491027">Exercise 10.5</h3>
<div class="outline-text-3" id="text-org4491027">
<p>
Show that the syndrome measurement for detecting phase flip errors in the Shor code
corresponds to measuring the observables \(A=X_1X_2X_3X_4X_5X_6\) and
\(B=X_4X_5X_6X_7X_8X_9\).
</p>
</div>

<div id="outline-container-exercise-10.5-solution" class="outline-4">
<h4 id="exercise-10.5-solution">Proof</h4>
<div class="outline-text-4" id="text-exercise-10.5-solution">
<p>
Let us denote
</p>

\begin{align*}
  \ket{\pi} &= \frac{1}{\sqrt{2}} (\ket{000} + \ket{111}) , \\
  \ket{\mu} &= \frac{1}{\sqrt{2}} (\ket{000} - \ket{111}) .
\end{align*}

<p>
With this notation the Shor code is given by
</p>

\begin{align*}
  \ket{0_L} &= \ket{\pi\pi\pi} , \\
  \ket{1_L} &= \ket{\mu\mu\mu} , \\
\end{align*}

<p>
Hence we have the following encoding:
</p>

<p>
\[
  \ket{\psi} = \ket{\psi_0} = a\ket{0_L} + b\ket{1_L} = a\ket{\pi\pi\pi} + b\ket{\mu\mu\mu} .
\]
</p>

<p>
In this notation a phase flip error is represented naturally. For example a phase flip in
one of the three qubits in the first block of \(\ket{\psi}\) is given by
</p>

<p>
\[
  \ket{\psi_1} = a\ket{\mu\pi\pi} + b\ket{\pi\mu\mu} .
\]
</p>

<p>
It doesn't matter in which of the three qubits, it always leads to the same state. The
other two errors (phase flip in the second or third block) are given by
</p>

\begin{align*}
  \ket{\psi_2} &= a\ket{\pi\mu\pi} + b\ket{\mu\pi\mu} , \\
  \ket{\psi_3} &= a\ket{\pi\pi\mu} + b\ket{\mu\mu\pi} .
\end{align*}

<p>
Now observe that
</p>

\begin{align*}
  X_1X_2X_3 \ket{\pi} &= + \ket{\pi} , \\
  X_1X_2X_3 \ket{\mu} &= - \ket{\mu} .
\end{align*}

<p>
Hence e.g. measuring a state \(\ket{ijk}\) (\(i,j,k\in\{\pi,\mu\}\)) with respect to \(A\)
detects if \(i=j\) (measurement result: \(+1\)) or \(i\neq\?j\) (measurement result:
\(+1\)). Because of their special structure this translates to \(\ket{\psi_k}\). For the four
errors (first one is <i>no error</i>) we get the following measurement results (each with
certainty):
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(k\) (\(\ket{\psi_k}\))</th>
<th scope="col" class="org-right">\(A\)</th>
<th scope="col" class="org-right">\(B\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">+1</td>
<td class="org-right">+1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">-1</td>
<td class="org-right">+1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">-1</td>
<td class="org-right">-1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">+1</td>
<td class="org-right">-1</td>
</tr>
</tbody>
</table>

<p>
Hence we can infer the syndrome \(k\) (which error occured) from the measurement - as
desired. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org540c24d" class="outline-3">
<h3 id="org540c24d">Exercise 10.6</h3>
<div class="outline-text-3" id="text-org540c24d">
<p>
Show that recovery from a phase flip on any of the first three qubits may be accomplished
by applying the operator \(Z_1Z_2Z_3\).
</p>
</div>

<div id="outline-container-org070fddb" class="outline-4">
<h4 id="org070fddb">Proof</h4>
<div class="outline-text-4" id="text-org070fddb">
<p>
Let us reuse the notation from the <a href="#exercise-10.5-solution">solution</a> of exercise 10.5. Clearly
</p>

<p>
\[
  Z_1Z_2Z_3 \ket{\pi} = \ket{\mu} \text{ and } Z_1Z_2Z_3 \ket{\mu} = \ket{\pi} .
\]
</p>

<p>
An error in the first three qubits means that the corresponding state is
\(\ket{\psi_1}\). By the above we have:
</p>

<p>
\[
  Z_1Z_2Z_3 \ket{\psi_1} = \ket{\psi} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb276f36" class="outline-3">
<h3 id="orgb276f36">Exercise 10.7</h3>
<div class="outline-text-3" id="text-orgb276f36">
<p>
Consider the three qubit bit flip code of Section 10.1.1, with corresponding projector
\(P=\proj{000}+\proj{111}\). The noise process this code protects against has operation
elements
</p>

<p>
\[
  \left\{ \sqrt{(1-p)^3}I, \sqrt{p(1-p)^2}X_1, \sqrt{p(1-p)^2}X_2, \sqrt{p(1-p)^2}X_3 \right\} ,
\]
</p>

<p>
where \(p\) is the probability that a bit flips. Note that this quantum operation \(\calE\) is
not trace-preserving, since we have omitted operation elements corresponding to bit flips
on two and three qubits. Verify the quantum error-correction conditions for this code and
noise process.
</p>
</div>

<div id="outline-container-org81e26fa" class="outline-4">
<h4 id="org81e26fa">Solution</h4>
<div class="outline-text-4" id="text-org81e26fa">
<p>
Clearly \(PX_iX_jP=\delta_{ij}P\). Hence
</p>

\begin{align*}
  P E_0^\dagger E_0 P &= (1-p)^3 P , \\
  P E_i^\dagger E_i P &= p(1-p)^2 P \text{ for } i=1..3 , \\
  P E_i^\dagger E_j P &= 0 \text{ for } i\neq j .
\end{align*}

<p>
Hence the conditions are satisfied and there exists an error correction procedure \(\calR\)
for this noise.
</p>
</div>
</div>

<div id="outline-container-org87dd3c8" class="outline-4">
<h4 id="org87dd3c8">Bonus: Calculating the recovery procedure</h4>
<div class="outline-text-4" id="text-org87dd3c8">
<p>
By the previous calculation and Theorem 10.1 there exists a trace-preserving quantum
operation \(\calR\) such that
</p>

<p>
\[
  \calR \circ \calE (P\rho P) = [(1-p)^3 + 3p(1-p)^2] \, P \rho P .
\]
</p>

<p>
The concrete form of the proportionality factor follows from (10.25) as it equals
\(\sum_kd_{kk}\). Since this is a trace this formula would even be true if \((d_{ij})\) wasn't
already diagonal.
</p>

<p>
To compute the Kraus matrices \(R_k\) of \(\calR\) we need the \(E_k\) such that the \((d_{ij})\)
are diagonal. This is already the case
</p>

<p>
\[
  d = \diag((1-p)^3, p(1-p)^2, p(1-p)^2, p(1-p)^2) .
\]
</p>

<p>
From the proof of Theorem 10.1 we know that
</p>

<p>
\[
  R_k = U_k^\dagger P_k
\]
</p>

<p>
where \(P_k=U_kPU_k^\dagger\) and \(E_kP=\sqrt{d_{kk}}U_kP\) is a polar decomposition. The
\(P_k\) are the projectors onto \(E_kC\) (\(C\) being the code space onto which \(P\)
projects). The diagonality of \((d_{ij})\) implies that \(P_iP_j=\delta_{ij}P_i\) (meaning
that the error subspaces are orthogonal to each other).
</p>

<p>
Clearly we can set \(U_0=I\) (it is only uniquely defined on the image of \(P\)). For \(k=1\) we
have
</p>

<p>
\[
  E_1 P = \sqrt{p(1-p)^2} X_1 P .
\]
</p>

<p>
This is already a polar decomposition (the Pauli operators are unitary). Hence we can just
set \(U_1=X_1\) and analogously \(U_k=X_k\) for \(k=1..3\). Hence
</p>

\begin{align*}
  P_0 &= \proj{000} + \proj{111} , \\
  P_1 &= \proj{100} + \proj{011} , \\
  P_2 &= \proj{010} + \proj{101} , \\
  P_3 &= \proj{001} + \proj{110} .
\end{align*}

<p>
Note that this corresponds to the already in (10.5-10.8) introduced syndrome measurement
operators. The Kraus matrices of \(\calR\) are
</p>

<p>
\[
  R_k = U_k^\dagger P_k = \begin{cases} IP = P & \text{for } k = 0 , \\
    X_k X_kPX_k = PX_k & \text{for } k \in \{1,2,3\} . \end{cases}
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org63ff6a4" class="outline-3">
<h3 id="org63ff6a4">Exercise 10.8</h3>
<div class="outline-text-3" id="text-org63ff6a4">
<p>
Verify that the three qubit phase flip code \(\ket{0_L}=\ket{+++}\), \(\ket{1_L}=\ket{---}\)
satisfies the quantum error-correction conditions for the set of error operators
\(\{I,Z_1,Z_2,Z_3\}\).
</p>
</div>

<div id="outline-container-org2c02fe2" class="outline-4">
<h4 id="org2c02fe2">Solution 1</h4>
<div class="outline-text-4" id="text-org2c02fe2">
<p>
Let us reduce this to the bit flip code. To convert to the bit flip code we only have to
conjugate the projector of the code and the Kraus operators of the errors by
\(H^{\otimes3}\) (Hadamard).
</p>

<p>
\[
  \proj{000} + \proj{111} = H^{\otimes3} \proj{+++} + \proj{---} H^{\otimes3}
\]
</p>

<p>
and
</p>

<p>
\[
  X_k = H^{\otimes3} Z_k H^{\otimes3} .
\]
</p>

<p>
Let \(P\) be the projector of the phase flip code and let \(E_i\) be the mentioned errors it
corrects. Let \(Q\) and \(F_j\) be the same thing for the bit flip.
</p>

<p>
\[
  P E_i^\dagger E_j P = H^{\otimes3} Q F_i^\dagger F_j Q H^{\otimes3}
  = H^{\otimes3} \delta_{ij} Q H^{\otimes3}
  = \delta_{ij} P .
\]
</p>

<p>
In the second equality we used what we already know about the bit flip code.
</p>
</div>
</div>

<div id="outline-container-org01d658e" class="outline-4">
<h4 id="org01d658e">Solution 2</h4>
<div class="outline-text-4" id="text-org01d658e">
<p>
We can also verify this explicitly. Let \(P=P_{+++}+P_{---}\) be the projector onto the
code, where we use the notation \(P_{ijk}=\proj{ijk}\). Clearly
\(PE_i^\dagger\?E_iP=PIP=P\). Moreover
</p>

<p>
\[
  PZ_1P = (P_{+++} + P_{---})(P_{-++} + P_{+--}) = 0
\]
</p>

<p>
and
</p>

<p>
\[
  PZ_1Z_2P = (P_{+++} + P_{---})(P_{--+} + P_{++-}) = 0 .
\]
</p>

<p>
Similarly \(PIZ_jP=PZ_iZ_jP=0\) for \(i\neq\?j\). Hence \(PE_i^\dagger\?E_iP=\delta_{ij}\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgec35081" class="outline-3">
<h3 id="orgec35081">Exercise 10.9</h3>
<div class="outline-text-3" id="text-orgec35081">
<p>
Again, consider the three qubit phase flip code. Let \(P_i\) and \(Q_i\) be the projectors
onto the \(\ket{0}\) and \(\ket{1}\) states, respectively, of the \(i\)​th qubit. Prove that the
three qubit phase flip code protects against the error set \({I,P_1,Q_1,P_2,Q_2,P_3,Q_3}\).
</p>
</div>

<div id="outline-container-org9ed2cc3" class="outline-4">
<h4 id="org9ed2cc3">Solution</h4>
<div class="outline-text-4" id="text-org9ed2cc3">
<p>
Recall that the phase flip code corrects the errors \(I\), \(Z_1\), \(Z_2\), and \(Z_3\). By
theorem 10.2 linear combinations of these errors are corrected too. Note that we have
</p>

\begin{align*}
  P_k &= \frac{1}{2} (I + Z_k) , \\
  Q_k &= \frac{1}{2} (I - Z_k) .
\end{align*}

<p>
Hence those errors are corrected too.
</p>
</div>
</div>
</div>

<div id="outline-container-org3149f74" class="outline-3">
<h3 id="org3149f74">Exercise 10.10</h3>
<div class="outline-text-3" id="text-org3149f74">
<p>
Explicitly verify the quantum error-correction conditions for the Shor code, for the error
set containing \(I\) and the error operators \(X_j,Y_j,Z_j\) for \(j=1\) through \(9\).
</p>
</div>

<div id="outline-container-orga5e5c25" class="outline-4">
<h4 id="orga5e5c25">Solution</h4>
<div class="outline-text-4" id="text-orga5e5c25">
<p>
Let us denote
</p>

\begin{align*}
  \ket{\pi} &= \frac{1}{\sqrt{2}} (\ket{000} + \ket{111}) , \\
  \ket{\mu} &= \frac{1}{\sqrt{2}} (\ket{000} - \ket{111}) .
\end{align*}

<p>
The Shor code is given by he projector
</p>

<p>
\[
  P = \proj{\pi\pi\pi} + \proj{\mu\mu\mu} .
\]
</p>

<p>
It is not hard to see that the errors transform the code space into a set of mutually
orthogonal subspaces - with one exception. The effect of \(Z_j\) is the same if \(j\) stays
within one "block" (there are three block \(\{1,2,3\}\), \(\{4,5,6\}\), and
\(\{7,8,9\}\)). Hence:
</p>

<p>
\[
  PE_i^\dagger E_j P = \begin{cases}
    P & \text{if } i=j \text{ or } E_i,E_j \text{ both Z on same block} , \\
    0 & \text{else} .
  \end{cases}
\]
</p>
</div>
</div>
</div>

<div id="outline-container-orgfc2ae3f" class="outline-3">
<h3 id="orgfc2ae3f">Exercise 10.11</h3>
<div class="outline-text-3" id="text-orgfc2ae3f">
<p>
Construct operation elements for a single qubit quantum operation \(\calE\) that upon input
of any state \(\rho\) replaces it with the completely randomized state \(I/2\). It is amazing
that even such noise models as this may be corrected by codes such as the Shor code!
</p>
</div>

<div id="outline-container-org9dcf15f" class="outline-4">
<h4 id="org9dcf15f">Solution</h4>
<div class="outline-text-4" id="text-org9dcf15f">
<p>
We already know that the quantum operation
</p>

<p>
\[
  \calE(\rho) = \frac{1}{2} I
\]
</p>

<p>
is the depolarizing channel with \(p=1\). By (8.102) this is equal to
</p>

<p>
\[
  \calE(\rho) = \frac{1}{4} (I\rho I + X\rho X + Y\rho Y + Z\rho Z) .
\]
</p>

<p>
Hence the relevant operation elements are
</p>

<p>
\[
  \left\{\frac{1}{2}I, \frac{1}{2}X, \frac{1}{2}Y, \frac{1}{2}Z \right\} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-orgef8400a" class="outline-3">
<h3 id="orgef8400a">Exercise 10.12</h3>
<div class="outline-text-3" id="text-orgef8400a">
<p>
Show that the fidelity between the state \(\ket{0}\) and \(\calE(\proj{0})\) is \(\sqrt{1-2p/3}\)
and use this to argue that the minimum fidelity for the depolarizing channel is
\(\sqrt{1-2p/3}\).
</p>
</div>

<div id="outline-container-org3e72c46" class="outline-4">
<h4 id="org3e72c46">Solution 1</h4>
<div class="outline-text-4" id="text-org3e72c46">
<p>
Let us follow the hint of the book.
</p>

<p>
\[
  F(\ket{0}, \calE(\proj{0}))
  = \sqrt{(1-p) + \frac{p}{3}(\bra{0}X\ket{0}^2 + \bra{0}Y\ket{0}^2 + \bra{0}Z\ket{0}^2)}
  = \sqrt{(1-p) + \frac{p}{3}}
  = \sqrt{1-\frac{2p}{3}} .
\]
</p>

<p>
Let \(\ket{\psi}\) be an arbitrary state and \(U\) be a unitary operator such that
\(\ket{\psi}=U\ket{0}\). Then
</p>

<p>
\[
  F(\ket{\psi}, \calE(\proj{\psi})) = F(U\ket{0}, U\calE(\proj{0})U^\dagger)
  = F(\ket{0}, \calE(\proj{0})) = \sqrt{1-\frac{2p}{3}} .
\]
</p>

<p>
In the second equality we used that the fidelity is invariant under unitary transformations.
</p>
</div>
</div>

<div id="outline-container-org9b438d2" class="outline-4">
<h4 id="org9b438d2">Solution 2</h4>
<div class="outline-text-4" id="text-org9b438d2">
<p>
We could also prove the claim by using an alternative formula for the depolarizing channel:
</p>

<p>
\[
  \calE(\rho) = \frac{2p}{3} I + \left(1 - \frac{4p}{3}\right) \rho .
\]
</p>

<p>
(compare equations (8.100) and (8.102).) Hence
</p>

<p>
\[
  F(\ket{\psi}, \calE(\proj{\psi})) = \sqrt{\frac{2p}{3} + \left(1 - \frac{4p}{3}\right)}
  = \sqrt{1-\frac{2p}{3}} .
\]
</p>
</div>
</div>

<div id="outline-container-orgd0401eb" class="outline-4">
<h4 id="orgd0401eb">Solution 3</h4>
<div class="outline-text-4" id="text-orgd0401eb">
<p>
Yet another approach first calculates
</p>

<p>
\[
  F(\ket{\psi}, \calE(\proj{\psi}))
  = \sqrt{(1-p) + \frac{p}{3}(\bra{\psi}X\ket{\psi}^2 + \bra{\psi}Y\ket{\psi}^2 + \bra{\psi}Z\ket{\psi}^2)} .
\]
</p>

<p>
Recall the representation \(\proj{\psi}=2\inv(I+\vec{r}\cdot\vec{\sigma})\) of a qubit in
the bloch sphere (\(\abs{\vec{r}}=1\)). One can show that
</p>

<p>
\[
  \bra{\psi}Z\ket{\psi} = r_z
\]
</p>

<p>
and analogous formulas for \(r_x\) and \(r_y\). Hence
</p>

<p>
\[
  F(\ket{\psi}, \calE(\proj{\psi})) = \sqrt{(1-p) + \frac{p}{3}\abs{\vec{r}}^2} = \sqrt{1-\frac{2p}{3}} .
\]
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
To see e.g.
</p>

<p>
\[
  \bra{\psi}Z\ket{\psi} = r_z
  \]
</p>

<p>
observe that
</p>

<p>
\[
  \bra{\psi}Z\ket{\psi} = \trace{\proj{\psi}Z} = r_z .
  \]
</p>

<p>
In the last equality we used that the Pauli matrices (including \(I\)) are an orthogonal
set with respect to the Hilbert-Schmidt scalar product (with norm \(\sqrt{2}\) for each
base vector). The other two formulas for \(r_x\) and \(r_y\) follow along the same lines.
</p>

<p>
If you want to see the last equality directly, observe that (using \(S=\sqrt{Z}\))
</p>

<p>
\[
  \trace{\proj{\psi}Z} = \trace{S\proj{\psi}S}
  \]
</p>

<p>
and use \(SIS=Z\), \(SXS=\ii\?X\), \(SYS=\ii\?Y\), \(SZS=I\) (only the last term has a non-zero
trace).
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org7f3f392" class="outline-3">
<h3 id="org7f3f392">Exercise 10.13</h3>
<div class="outline-text-3" id="text-org7f3f392">
<p>
Show that the minimum fidelity \(F(\ket{\psi},\calE(\proj{\psi}))\) when \(\calE\) is the
amplitude damping channel with parameter \(\gamma\), is \(\sqrt{1-\gamma}\).
</p>
</div>

<div id="outline-container-orgf781491" class="outline-4">
<h4 id="orgf781491">Proof</h4>
<div class="outline-text-4" id="text-orgf781491">
<p>
Let us use sage to get an algebraic expression for \(F\). First define amplitude damping
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org7ae2cc4"><span class="org-variable-name">E0</span> <span class="org-operator">=</span> matrix.diagonal([1, sqrt(1<span class="org-operator">-</span>g)])
<span class="org-variable-name">E1</span> <span class="org-operator">=</span> matrix([[0, sqrt(g)], [0, 0]])
<span class="org-variable-name">AD</span> <span class="org-operator">=</span> make_operation([E0, E1])
</pre>
</div>

<p>
Now we can use this to compute \(F\):
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">psi</span> <span class="org-operator">=</span> a<span class="org-operator">*</span>ket(<span class="org-string">'0'</span>) <span class="org-operator">+</span> b<span class="org-operator">*</span>ket(<span class="org-string">'1'</span>)
<span class="org-variable-name">psi_mat</span> <span class="org-operator">=</span> matrix(psi).T
<span class="org-variable-name">rho</span> <span class="org-operator">=</span> AD(psi_mat<span class="org-operator">*</span>psi_mat.H).simplify_full()
(psi.conjugate() <span class="org-operator">*</span> rho <span class="org-operator">*</span> psi).simplify_full()
</pre>
</div>

<pre class="example">
2*a*b*sqrt(-g + 1)*conjugate(a)*conjugate(b) + a^2*conjugate(a)^2 + b^2*conjugate(b)^2 + (a*b*conjugate(a)*conjugate(b) - b^2*conjugate(b)^2)*g
</pre>


<p>
This looks a bit ugly so let us rewrite this:
</p>

<p>
\[
  F = \abs{a}^4 + \abs{b}^4 + \gamma(\abs{a}^2 \abs{b}^2 - \abs{b}^4) + 2\sqrt{1-\gamma}\, \abs{a}^2\abs{b}^2 .
\]
</p>

<p>
Substituting \(x=\abs{a}^2\) and \(y=\abs{b}^2\) this can be written as:
</p>

<p>
\[
  F = \sqrt{f(x,y)} = \sqrt{x^2 + y^2 + \gamma (xy - y^2) + 2\sqrt{1-\gamma} \, xy} ,
\]
</p>

<p>
under the constraint \(x+y=1\) and \(x,y\geq0\). Thus we have to solve a constrained
minimization problem. There are two possibilities. The first one is that the minimum
occurs at the boundaries of the feasible region. Therefore let us calculate
</p>

\begin{align*}
  f(1,0) &= 1 , \\
  f(0,1) &= 1 - \gamma .
\end{align*}

<p>
The second possibility is that the minimum occurs in the inside of the feasible region. In
that case we might try to find it by the method of Lagrange multipliers:
</p>

\begin{align*}
  \partial_x f(x, y) &= 2x + (\gamma + 2\sqrt{1-\gamma}) y = \lambda \cdot 1 , \\
  \partial_y f(x, y) &= 2(1-\gamma)y + (\gamma + 2\sqrt{1-\gamma}) x = \lambda \cdot 1 .
\end{align*}

<p>
This looks a bit complicated so let us change the strategy a bit by defining a
parameterization of the feasible region
</p>

<p>
\[
  g(s) = f(s,1-s) .
\]
</p>

<p>
Abbreviating \(\alpha=\gamma+2\sqrt{1-\gamma}\) we see that
</p>

\begin{align*}
  g'(s) &= \partial_x f(s,1-s) - \partial_y f(s,1-s) \\
  &= (\alpha + 2\gamma - 2) - 2(\gamma + \alpha - 2) s \\
  &=: c_0 - c_1 s .
\end{align*}

<p>
Observe that \(\alpha+\gamma\geq2\). Hence \(c_0,c_1\geq0\) which implies that there is a
\(s_0\geq0\) such that \(g\) is increasing for \(s\leq\?s_0\) and decreasing afterwards (note
also that \(s_0\) could be larger than \(1\)). Hence a local extremum can only be a local
maximum and the minimum is indeed obtained at the boundary:
</p>

<p>
\[
  f(0, 1) = g(0) = 1 - \gamma .
\]
</p>

<p>
Hence \(F_{\min}=\sqrt{1-\gamma}\) . QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org32930e3" class="outline-3">
<h3 id="org32930e3">Exercise 10.14</h3>
<div class="outline-text-3" id="text-org32930e3">
<p>
Write an expression for a generator matrix encoding \(k\) bits using \(r\) repetitions for
each bit. This is an \([rk,k]\) linear code, and should have an \(rk\times\?k\) generator
matrix.
</p>
</div>

<div id="outline-container-exercise-10.14-solution" class="outline-4">
<h4 id="exercise-10.14-solution">Solution</h4>
<div class="outline-text-4" id="text-exercise-10.14-solution">
<p>
Let \(\mathbb{1}_r\in\?\BB^r\) be the vector containing just ones. A generator for this code
is given by the tensor product
</p>

<p>
\[
  G = I_k \otimes \mathbb{1}_r .
\]
</p>

<p>
This naturally reproduces the special cases \(r=3\), \(k\in\{1,2\}\) from the book.
</p>
</div>
</div>
</div>

<div id="outline-container-orga1c45ef" class="outline-3">
<h3 id="orga1c45ef">Exercise 10.15</h3>
<div class="outline-text-3" id="text-orga1c45ef">
<p>
Show that adding one column of \(G\) to another results in a generator matrix generating the
same code.
</p>
</div>

<div id="outline-container-org5c33902" class="outline-4">
<h4 id="org5c33902">Proof</h4>
<div class="outline-text-4" id="text-org5c33902">
<p>
Let \((e_j)\) be the standard basis vectors in \(\BB^k\). The code generated by \(G\) is just
the image \(C=G\BB^k\) of \(G\) which in turn is given by all linear combinations of
\((Ge_j)\). Let \(G'\) be the generator found by adding column \(k\) to column \(l\neq\?k\).
</p>

<p>
We have to show that \(C=G'\BB^k\). For this in turn it suffices to show that \((G'e_j)\)
spans \(C\). First of all observe that
</p>

<p>
\[
  Ge_j = G'e_j \text{ for } j \neq l .
\]
</p>

<p>
Hence it suffices to show that \(\{Ge_k,Ge_l\}\) spans the same space as
\(\{G'e_k,G'e_l\}\). Observe that
</p>

\begin{align*}
  G' e_l &= Ge_k + Ge_l , \\
  G e_l &= G'e_k + G'e_l .
\end{align*}

<p>
This shows the claim. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org650743c" class="outline-3">
<h3 id="org650743c">Exercise 10.16</h3>
<div class="outline-text-3" id="text-org650743c">
<p>
Show that adding one row of the parity check matrix to another does not change the
code. Using Gaussian elimination and swapping of bits it is therefore possible to assume
that the parity check matrix has the standard form \([A|I_{n-k}]\), where \(A\) is an
\((n-k)\times\?k\) matrix.
</p>
</div>

<div id="outline-container-org8c395c7" class="outline-4">
<h4 id="org8c395c7">Proof</h4>
<div class="outline-text-4" id="text-org8c395c7">
<p>
Recall that a code \(C\), in terms of a parity check matrix \(H\), is defined as
</p>

<p>
\[
  y \in C \Leftrightarrow \forall i: \sum_j H_{ij} y_j = 0 .
\]
</p>

<p>
Let \(H'\) be a matrix obtained from \(H\) by adding row \(k\) to row \(l\). Let \(C'\) be the code
defined by \(H'\). We have to show \(C'=C\). Let \(y\in\?C\). Then we have
</p>

<p>
\[
  \forall i\neq l: \sum_j H'_{ij} y_j = 0 .
\]
</p>

<p>
because for those \(i\) we have \(H'_{ij}=H_{ij}\). Moreover
</p>

<p>
\[
  \sum_j H'_{lj} y_j = \sum_j H_{kj} y_j + \sum_j H_{lj} y_j =  0 ,
\]
</p>

<p>
by definition of \(H'\). Hence \(y\in\?C'\). Since \(y\in\?C\) was arbitrary this shows
\(C\subseteq\?C'\). By symmetry we also have \(C'\subseteq\?C\). In fact, \(H\) can be obtained
from \(H'\) by adding row \(k\) to line \(l\) so the same reasoning applies to the reverse
inclusion. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org431b41d" class="outline-3">
<h3 id="org431b41d">Exercise 10.17</h3>
<div class="outline-text-3" id="text-org431b41d">
<p>
Find a parity check matrix for the \([6,2]\) repetition code defined by the generator matrix in
(10.54).
</p>

\begin{bmatrix}
1 & 0 \\
1 & 0 \\
1 & 0 \\
0 & 1 \\
0 & 1 \\
0 & 1 \\
\end{bmatrix}
</div>

<div id="outline-container-orga5c54fb" class="outline-4">
<h4 id="orga5c54fb">Solution</h4>
<div class="outline-text-4" id="text-orga5c54fb">
<p>
Let \(G_1\) and \(H_1\) be the generator and parity check matrix for \(k=1\) bits (see equations
(10.53) and (10.58)). We have
</p>

<p>
\[
  G_2 = I_2 \otimes G_1 .
\]
</p>

<p>
(C.f. the <a href="#exercise-10.14-solution">solution</a> of exercise 10.14.) This suggests to define
</p>

<p>
\[
  H_2 = I_2 \otimes H_1 = \begin{bmatrix}
    1 & 1 & 0 & 0 & 0 & 0 \\
    0 & 1 & 1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 1 & 1 & 0 \\
    0 & 0 & 0 & 0 & 1 & 1
  \?\end{bmatrix} .
\]
</p>

<p>
This clearly does the job. It makes sense to compare this to <a href="#exercise-10.18">exercise 10.18</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.18" class="outline-3">
<h3 id="exercise-10.18">Exercise 10.18</h3>
<div class="outline-text-3" id="text-exercise-10.18">
<p>
Show that the parity check matrix \(H\) and generator matrix \(G\) for the same linear code
satisfy \(HG=0\).
</p>
</div>

<div id="outline-container-org27e8ef4" class="outline-4">
<h4 id="org27e8ef4">Proof</h4>
<div class="outline-text-4" id="text-org27e8ef4">
<p>
Recall that a code \(C\) is just the image of the generator \(C=G\BB^k\). On the other hand it
can be defined as the kernel of the parity check matrix: \(C=\{y|Hy=0\}\). Since every code
word has the form \(y=Gx\) we see that \(HGx=0\) for every \(x\). Hence the claim follows. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org6a84211" class="outline-3">
<h3 id="org6a84211">Exercise 10.19</h3>
<div class="outline-text-3" id="text-org6a84211">
<p>
Suppose an \([n,k]\) linear code \(C\) has a parity check matrix of the form \(H=[A|I_{n-k}]\),
for some \((n-k)\times\?k\) matrix \(A\). Show that the corresponding generator matrix is
</p>

<p>
\[
  G = \left[ \begin{array}{c} I_k \\ \hline -A \end{array} \right]
\]
</p>

<p>
(Note that \(-A=A\) since we are working modulo 2; however, this equation also holds for
linear codes over more general ﬁelds than \(\ZZ_2\).)
</p>
</div>

<div id="outline-container-org895a904" class="outline-4">
<h4 id="org895a904">Solution</h4>
<div class="outline-text-4" id="text-org895a904">
<p>
Clearly \(G\) has rank \(k\). Hence its images has the same dimension as the kernel of \(H\)
(which is \(k\)). We only have to verify that \(HG=0\) (c.f. <a href="#exercise-10.18">exercise 10.18</a>). But this is
easy:
</p>

<p>
\[
  HG = A I_k - I_{n-k} A = A - A = 0 .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.20" class="outline-3">
<h3 id="exercise-10.20">Exercise 10.20</h3>
<div class="outline-text-3" id="text-exercise-10.20">
<p>
Let \(H\) be a parity check matrix such that any \(d-1\) columns are linearly independent, but
there exists a set of \(d\) linearly dependent columns. Show that the code defined by \(H\)
has distance \(d\).
</p>
</div>

<div id="outline-container-orgdc32350" class="outline-4">
<h4 id="orgdc32350">Proof</h4>
<div class="outline-text-4" id="text-orgdc32350">
<p>
Let us divide the proof into two parts. In part one we assume that \(H\) has \(d\) linearly
<i>dependent</i> columns. In part two we assume that every \(d-1\) columns are linearly
<i>independent</i>.
</p>

<dl class="org-dl">
<dt>Part 1</dt><dd><p>
Assume that \(H\) has \(d\) linearly <i>dependent</i> columns \(c_1,\ldots,c_d\). We want
to show that there exists a \(y\in\?C\) (i.e. \(y\in\BB^n\) such that \(Hy=0\)) with
\(\wt{y}\leq\?d\).
</p>

<p>
Linear dependence means that there exist coefficients \(\alpha_i\in\BB\) such that
</p>

<p>
\[
  0 = \sum_i \alpha_i c_i .
  \]
</p>

<p>
Without loss of generality we may assume that all \(\alpha_i\) are equal to \(1\). Otherwise
there would exist a subset of \(d'\?<\?d\) columns such that this is fulfilled.
</p>

<p>
Let \(J=\{i_1,\ldots,i_d\}\) be the indices of these columns in \(H\). Let \(y\in\BB^n\) be
such that \(y_i=1\) if \(i\in\?J\) and \(y_i=0\) otherwise. By construction we have \(\wt{y}=d\)
and \(Hy=0\). This shows the claim of part 1.
</p></dd>
<dt>Part 2</dt><dd><p>
Assume that every \(d-1\) columns are linearly <i>independent</i>. We have to show
that \(Hy=0\) implies \(\wt{y}\geq\?d\).
</p>

<p>
The assumption implies that every for every \(y\) with \(\wt{y}\leq\?d-1\) we have
\(Hy\neq0\). But this is equivalent to the claim.
</p></dd>
</dl>

<p>
Taking parts 1 and 2 together we see that \(d(C)=d\) is equivalent to: Any \(d-1\) columns of
\(H\) are linearly independent but there exist \(d\) columns which are linearly
dependent. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org47ad261" class="outline-3">
<h3 id="org47ad261">Exercise 10.21 (Singleton bound)</h3>
<div class="outline-text-3" id="text-org47ad261">
<p>
Show that an \([n,k,d]\) code must satisfy \(n-k\geq\?d-1\).
</p>
</div>

<div id="outline-container-org7791a1e" class="outline-4">
<h4 id="org7791a1e">Proof</h4>
<div class="outline-text-4" id="text-org7791a1e">
<p>
This follows directly from <a href="#exercise-10.20">exercise 10.20</a>. In fact, the parity check matrix
\(H\in\BB^{(n-k)\times\?n}\) of the code must have full rank \(n-k\) in order for the code
space to be \(k\)​-dimensional (otherwise it would be bigger and there could be no bijection
between the code words and the elements of \(\BB^k\)).
</p>

<p>
On the other hand, from \(d(C)=d\), using exercise 10.20, we see that the rank of \(H\) must
be at least \(d-1\). Hence \(n-k\geq\?d-1\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgab97920" class="outline-3">
<h3 id="orgab97920">Exercise 10.22</h3>
<div class="outline-text-3" id="text-orgab97920">
<p>
Show that all Hamming codes have distance \(3\), and thus can correct an error on a single
bit. The Hamming codes are therefore \([2^r-1,2^r-r-1,3]\) codes.
</p>
</div>

<div id="outline-container-org259fbff" class="outline-4">
<h4 id="org259fbff">Proof</h4>
<div class="outline-text-4" id="text-org259fbff">
<p>
The parity check matrix of the Hamming code is made of matrices with columns \(h_j\) being
the binary representation of \(j\) for \(j\in\{1,\ldots,2^r-1\}\). Hence
</p>

<p>
\[
  h_1 + h_2 = h_3 ,
\]
</p>

<p>
implying that the first three columns are linearly dependent. On the other hand any two
columns are linearly independent since
</p>

<p>
\[
  h_i + h_j = 0
\]
</p>

<p>
implies \(i=j\). Now the claim follows from <a href="#exercise-10.20">exercise 10.20</a>. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org45d6190" class="outline-3">
<h3 id="org45d6190">Exercise 10.23</h3>
<div class="outline-text-3" id="text-org45d6190">
<p>
Prove the Gilbert–Varshamov bound: Let \(\varepsilon\?>0\) and \(0\?<\delta\?<\?1/2\). There
exists an \([n,k,d]\) code such that
</p>

<p>
\[
  R \geq 1 - H(\delta) - \varepsilon ,
\]
</p>

<p>
where \(R=k/n\) is the <i>rate</i> of the code, \(\delta\leq(d-1)/n\), and
\(H(x)=-x\log_2(x)-(1-x)\log_2(x)\). In other words, for a given relative distance
\(\delta\?<\?1/2\) there is always a corresponding code whose transmission rate is not too
bad.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><ul class="org-ul">
<li>For \(\varepsilon=0\) this is equivalent to the orginial exercise. The proof <i>suggests</i>
that it is necessary to have \(\varepsilon\?>\?0\). Moreover the <a href="https://en.wikipedia.org/wiki/Gilbert%E2%80%93Varshamov_bound_for_linear_codes">wikipedia</a> version of
the theorem also has it. Hence I believe this is just an error in the exercise.</li>
<li>Another reason why I reformulated the statement is the following: In the original
statement I originally imagined \(t\) to be fixed. But then if you only consider large
\(n\) this isn't really useful since a code with very many bits has also a large "attack
surface" for errors. So it is more natural to consider a relative quantity instead.</li>
<li>The authors write "The proof of the Gilbert–Varshamov bound is quite simple &#x2026;". I do
not share this assessment. Maybe my solution is more complicated than it should
be. But in my opinion most exercises in part III of the book (so far) are much easier.</li>
</ul></dd>
</dl>
</div>

<div id="outline-container-orgf1dd982" class="outline-4">
<h4 id="orgf1dd982">Proof</h4>
<div class="outline-text-4" id="text-orgf1dd982">
<p>
In this proof we use the so called <a href="https://en.wikipedia.org/wiki/Probabilistic_method">probabilistic method</a> which seems to be the standard way
to prove this bound (see e.g. <a href="https://en.wikipedia.org/wiki/Gilbert%E2%80%93Varshamov_bound_for_linear_codes">wikipedia</a> for the general case of linear codes over finite
fields).
</p>

<p>
Let \(n\geq\?k\) to be fixed later. The main idea is to consider a uniform probability
distribution over \(\BB^{n\times\?k}\) and draw random generators \(G\) from it (let us
denote the generated code by \(C\)). The idea is to show that there is a non-zero
probability that the drawn generator generates a code with the desired properties.
</p>

<p>
Note one subtle thing here: the generator must be injective in order to generate a
\(k\)​-dimensional code. Therefore consider the following lemma.
</p>

<dl class="org-dl">
<dt>Lemma</dt><dd>For all \(n\geq\?k\) let \(P(n,k)\) be the probability that a uniformly at random
drawn matrix \(G\in\BB^{n\times\?k}\) has rank \(k\). There exists a constant \(P_\infty\?>\?0\)
(which does not depend on \(n\) or \(k\)) such that \(P(n,k)\geq\?P_\infty\).
<dl class="org-dl">
<dt>Proof</dt><dd><p>
Clearly \(P(n,k)\geq\?P(k,k)\). So we only have to consider the case \(n=k\). For
\(l\leq\?k\) let \(P_l\) be the probability that a random matrix from \(\BB^{l\times\?k}\)
has rank \(l\). Clearly
</p>

<p>
\[ P_1 = (2^k - 1) / 2^k = 1 - 2^{-k} \]
</p>

<p>
because there is only one vector (the zero vector) which leads to a single rowed
rank-zero matrix. Observe that
</p>

<p>
\[ P_{l+1} = P_l \cdot (2^k - 2^l) /2^k . \]
</p>

<p>
This is because in order to have \(l+1\) independent rows you first need \(l\) independent
rows and the last row has to be outside the \(l\)​-dimensional subspace (with \(2^l\)
elements) of the first \(l\) rows. Hence
</p>

<p>
\[ P(k,k) = P_k = \prod_{j=1}^{k} (1 - 2^{-j}) \geq \prod_{j=1}^{\infty} (1 - 2^{-j}) =: P_\infty > 0 . \]
</p>

<p>
QED.
</p></dd>
</dl></dd>
</dl>

<p>
Our goal is to prove that for sufficiently large \(n\) (considering also non-injective \(G\))
</p>

<p>
<a id="org014071b"></a>
\[
  \prob{d(C)\geq d} > P_\infty
\]
</p>

<p>
because then
</p>

<p>
\[
  \prob{d(C)\geq d \text{ and } \rank{G}=k} \geq  \prob{d(C)\geq d} - P_\infty > 0 .
\]
</p>

<p>
which proves the claim. Let us estimate the probability that the distance of the code is
<i>not</i> at least \(d\). In order to show the above <a href="#org014071b">bound</a> it suffices to show that the
following can be made arbitrary small (for large \(n\)):
</p>

<p>
<a id="org3317727"></a>
\[
  \prob{d(C)\leq d-1} \leq \sum_{x\in\BB^k\backslash\{0\}} \prob{\wt{Gx} \leq d-1} = \frac{V_d}{2^{n-k}} .
\]
</p>

<p>
The first inequality follows from the fact that the event \(d(C)\leq\?d-1\) is equivalent to
the event that at least one of the code words has distance at most \(d-1\) (also use the
sub-additivity of probabilities). For the equality on the right let us first note that for
each \(x\) the code word \(Gx\) is uniformly distributed (each column of \(G\) is uniformly
distrubuted and so is each sum of columns). Hence \(\prob{\wt{Gx}\leq\?d-1}=V_d/2^n\) where
</p>

<p>
\[
  V_d = \sum_{i=0}^{d-1} \binom{n}{i}
\]
</p>

<p>
is the number of potential code words with weight at most \(d-1\).
</p>

<dl class="org-dl">
<dt>Lemma</dt><dd>\(V_d\leq2^{H(\delta)n}\) if \(\delta\leq1/2\), where \(\delta=(d-1)/n\).
<dl class="org-dl">
<dt>Remark</dt><dd>A reverse inequality is is also true: \(V_d\geq2^{H(\delta)n+o(n)}\). This can
be seen from Stirlings formula. Actually I knew this reverse inequality already since
I solved exercise 6.14, see e.g. <a href="chapter_6.html#orgfb905fb">here</a> to get an idea for the proof. This is the reason
I found it natural to connect \(V_d\) to the entropy. I was a bit surprised to find out
that the \(V_d\leq\ldots\) inequality has such a clean form (no Landau notation).</dd>
<dt>Proof</dt><dd><p>
The claim follows from this:
</p>

<p>
\[
      \sum_{i=0}^{d-1} \binom{n}{i} 2^{-H(\delta)n}
      = \sum_{i=0}^{d-1} \binom{n}{i} \delta^{d-1} (1-\delta)^{n-d+1}
      \leq \sum_{i=0}^{d-1} \binom{n}{i} \delta^j (1-\delta)^{j-d}
      = (\delta + (1 - \delta))^n
      = 1 .
    \]
</p>

<p>
For the inequality in the middle it is important to have \(\delta\leq1/2\). The last
equality is just the binomial formula. QED.
</p></dd>
</dl></dd>
</dl>

<p>
Using the lemma in <a href="#org3317727">the estimate</a> for the probability that \(d(C)\leq\?d-1\) we get
</p>

<p>
\[
  P := \prob{d(C)\leq d-1} \leq \left[\frac{2^{H(\delta)+O(n\inv)}}{2^{1-R}}\right]^n
  = \left[\frac{2^{R+o(1)}}{2^{1-H(\delta)}}\right]^n .
\]
</p>

<p>
Here we choose \(d\) minimal so that \(\delta\leq(d-1)/n\) holds. Hence \(\delta=(d-1+O(1))/n\)
which explains the \(O(n\inv)\) in the inequalities above.
</p>

<p>
Let us suppose we can choose \(R\) such that
</p>

\begin{align*}
  R &\geq 1 - H(\delta) - \varepsilon , \\
  R + o(1) &\leq 1 - H(\delta) - \varepsilon/2 , \\
\end{align*}

<p>
Then we would have \(P\leq2^{-\varepsilon\?n/2}\) which is arbitrary small if \(n\) is large
enough - which proves the <a href="#org014071b">desired bound</a>. But since \(R=k/n\) this is indeed possible if we
choose \(n\) large enough and \(k\) appropriately. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org3dd9e2c" class="outline-3">
<h3 id="org3dd9e2c">Exercise 10.24</h3>
<div class="outline-text-3" id="text-org3dd9e2c">
<p>
Show that a code with generator matrix \(G\) is weakly self-dual if and only if \(G^TG=0\).
</p>
</div>

<div id="outline-container-orge840ae9" class="outline-4">
<h4 id="orge840ae9">Proof</h4>
<div class="outline-text-4" id="text-orge840ae9">
<p>
Weakly self dual means \(C\subseteq\?C^{\bot}\). Hence
</p>

<p>
\[
  H^{\bot} G = 0 ,
\]
</p>

<p>
where \(G\) is the generator of \(C\) and \(H^\bot\) the parity check matrix of \(C^\bot\). But
a parity check matrix of \(C^\bot\) is \(H^\bot=G^T\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org0bd0704" class="outline-3">
<h3 id="org0bd0704">Exercise 10.25</h3>
<div class="outline-text-3" id="text-org0bd0704">
<p>
Let \(C\) be a linear code. Show that if \(x\in\?C^\bot\) then
\(\sum_{y\in\?C}(-1)^{x\cdot\?y}=\abs{C}\), while if \(x\notin\?C^\bot\) then
\(\sum_{y\in\?C}(-1)^{x\cdot\?y}=0\).
</p>
</div>

<div id="outline-container-orge59c43e" class="outline-4">
<h4 id="orge59c43e">Proof</h4>
<div class="outline-text-4" id="text-orge59c43e">
<p>
By definition of dual codes we have \(x\cdot\?y=0\) if \(x\in\?C^\bot\) and \(y\in\?C\). Hence,
in that case
</p>

<p>
\[
  \sum_{y\in\?C}(-1)^{x\cdot y} = \sum_{y\in\?C} 1 = \abs{C}
\]
</p>

<p>
Assume now that \(x\in\?C^\bot\). Hence there exists a \(\tilde{y}\in\?C\) such that
\(x\cdot\?\tilde{y}=1\). Let us decompose \(C=C'\oplus\?\tilde{y}\BB\). Hence
</p>

<p>
\[
  \sum_{y\in C}(-1)^{x\cdot y}
  = \sum_{y'\in C'} \sum_{\alpha=0}^1 (-1)^{y'\cdot x + \alpha\tilde{y}\cdot x}
  = \sum_{y'\in C'} 0
  = 0 .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgddc0e7d" class="outline-3">
<h3 id="orgddc0e7d">Exercise 10.26</h3>
<div class="outline-text-3" id="text-orgddc0e7d">
<p>
Suppose \(H\) is a parity check matrix. Explain how to compute the transformation
\(\ket{x}\ket{0}\mapsto\ket{x}\ket{Hx}\) using a circuit composed entirely of <code>CNOT</code> gates.
</p>
</div>

<div id="outline-container-org5a92897" class="outline-4">
<h4 id="org5a92897">Solution</h4>
<div class="outline-text-4" id="text-org5a92897">
<p>
Let us explain it on the specific example of the \([3,1]\) repetition code:
</p>

<p>
\[
  H = \begin{bmatrix} 1 & 1 & 0 \\ 0 & 1 & 1 \end{bmatrix} .
\]
</p>

<p>
A corresponding circuit would be
</p>

<pre class="example" id="org3d5bf42">

a_0: ──■─────────────────
       │
a_1: ──┼────■────■───────
       │    │    │
a_2: ──┼────┼────┼────■──
     ┌─┴─┐┌─┴─┐  │    │
b_0: ┤ X ├┤ X ├──┼────┼──
     └───┘└───┘┌─┴─┐┌─┴─┐
b_1: ──────────┤ X ├┤ X ├
               └───┘└───┘
</pre>

<p>
The idea is that for each \((i,j)\) with \(H_{ij}=1\) we have a <code>CNOT</code> with control at target
\(b_i\) and control \(a_j\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgdec3914" class="outline-3">
<h3 id="orgdec3914">Exercise 10.27</h3>
<div class="outline-text-3" id="text-orgdec3914">
<p>
Show that the codes defined by
</p>

<p>
\[
  \ket{x+C_2} = \frac{1}{\sqrt{\abs{C_2}}} \sum_{y\in\?C_2} (-1)^{u\cdot y} \ket{x+y+v}
\]
</p>

<p>
and parameterized by \(u\) and \(v\) are equivalent to \(\mathrm{CSS}(C_1,C_2)\) in the sense
that they have the same error-correcting properties. These codes, which we’ll refer to as
\(\mathrm{CSS}_{u,v}(C_1,C_2)\), will be useful later in our study of quantum key
distribution, in Section 12.6.5.
</p>
</div>

<div id="outline-container-orgc9a399d" class="outline-4">
<h4 id="orgc9a399d">Sketch of a solution</h4>
<div class="outline-text-4" id="text-orgc9a399d">
<p>
By using \(X\), \(Z\), and Hadamard gates one can unitarily transform the code into the
following form
</p>

<p>
\[
  \ket{x+C_2} = \frac{1}{\sqrt{\abs{C_2}}} \sum_{y\in\?C_2} (-1)^{u\cdot x} \ket{x+y}
  = (-1)^{u\cdot x} \frac{1}{\sqrt{\abs{C_2}}} \sum_{y\in\?C_2} \ket{x+y} .
\]
</p>

<p>
Basically we introduce errors \(e_1=v\) and \(e_2=u\) on purpose to accomplish that. Now it is
not hard to verify that the factor \((-1)^{u\cdot\?x}\) does not interfere with the analysis
from the book.
</p>
</div>
</div>
</div>

<div id="outline-container-org3f62e9b" class="outline-3">
<h3 id="org3f62e9b">Exercise 10.28</h3>
<div class="outline-text-3" id="text-org3f62e9b">
<p>
Verify that the transpose of the matrix in (10.77) is the generator of the \([7,4,3]\)
Hamming code.
</p>
</div>

<div id="outline-container-orge6eb931" class="outline-4">
<h4 id="orge6eb931">Solution</h4>
<div class="outline-text-4" id="text-orge6eb931">
<p>
The claim follows essentially from the following calculation:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-comment-delimiter"># </span><span class="org-comment">Standard parity check matrix for the [7,3] Hamming code:</span>
<span class="org-variable-name">H</span> <span class="org-operator">=</span> matrix(GF(2), [
    [0, 0, 0, 1, 1, 1, 1],
    [0, 1, 1, 0, 0, 1, 1],
    [1, 0, 1, 0, 1, 0, 1],
])

<span class="org-comment-delimiter"># </span><span class="org-comment">We want to check that this is indeed a generator:</span>
<span class="org-variable-name">G</span> <span class="org-operator">=</span> matrix(GF(2), [
    [1, 0, 0, 0, 0, 1, 1],
    [0, 1, 0, 0, 1, 0, 1],
    [0, 0, 1, 0, 1, 1, 0],
    [0, 0, 0, 1, 1, 1, 1],
]).T

<span class="org-keyword">assert</span> H<span class="org-operator">*</span>G <span class="org-operator">==</span> matrix.zero(3, 4)
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
One important thing to note is that \(G\) has full rank (obviously). Hence \(HG=0\) is
sufficient to prove \(G\) to be a generator of the \([7,4]\) Hamming code.
</p>
</div>
</div>
</div>

<div id="outline-container-org1ad2418" class="outline-3">
<h3 id="org1ad2418">Exercise 10.29</h3>
<div class="outline-text-3" id="text-org1ad2418">
<p>
Show that an arbitrary linear combination of any two elements of \(V_S\) is also in
\(V_S\). Therefore, \(V_S\) is a subspace of the \(n\) qubit state space. Show that \(V_S\) is the
intersection of the subspaces fixed by each operator in \(S\) (that is, the eigenvalue one
eigenspaces of elements of \(S\)).
</p>
</div>

<div id="outline-container-orgc9e79c0" class="outline-4">
<h4 id="orgc9e79c0">Solution</h4>
<div class="outline-text-4" id="text-orgc9e79c0">
<p>
We have
</p>

\begin{align*}
  V_S &= \{v | \forall g\in S: gv = v\} \\
  &= \bigcap_{g\in S} \{v | gv = v\} \\
  &= \bigcap_{g\in S} \ker(g-I) .
\end{align*}

<p>
Since the kernel of a linear operator is a linear subspace and since the intersection of
linear subscpaces is again linear the claim follows.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdedc9b8" class="outline-3">
<h3 id="orgdedc9b8">Exercise 10.30</h3>
<div class="outline-text-3" id="text-orgdedc9b8">
<p>
Show that \(-I\notin\?S\) implies \(\pm\ii\?I\notin\?S\).
</p>
</div>

<div id="outline-container-org0fa29cb" class="outline-4">
<h4 id="org0fa29cb">Proof</h4>
<div class="outline-text-4" id="text-org0fa29cb">
<p>
Recall the elementary logical rule that \(\neg\?a\Rightarrow\neg\?b\) is equivalent to
\(a\Leftarrow\?b\). Hence, we have to prove that \(\pm\ii\?I\in\?S\) implies \(-I\in\?S\). But
this is obvious! QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd1d2008" class="outline-3">
<h3 id="orgd1d2008">Exercise 10.31</h3>
<div class="outline-text-3" id="text-orgd1d2008">
<p>
Suppose \(S\) is a subgroup of \(G_n\) generated by elements \(g_1,\ldots,g_l\). Show that all
the elements of \(S\) commute if and only if \(g_i\) and \(g_j\) commute for each pair \(i\), \(j\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The claim remains true if we replace \(G_n\) by any group. This follows from the
proof below.</dd>
</dl>
</div>

<div id="outline-container-org508dfdb" class="outline-4">
<h4 id="org508dfdb">Proof</h4>
<div class="outline-text-4" id="text-org508dfdb">
<p>
One direction of the implication is obvious. Therefore let us just prove the other
direction.
</p>

<p>
Assume that all \(g_i\) and \(g_j\) commute. One can show that every \(g\in\?S\) can be
represented (not necessarily uniquely) as
</p>

<p>
\[
  g = \prod_{j=1}^l g_j^{x_j}
\]
</p>

<p>
where \(x_j\in\ZZ\), and that inversion and products are represented as follows
</p>

\begin{align*}
  g\inv &= \prod_{j=1}^l g_j^{-x_j} \\
  g\cdot h &= \prod_{j=1}^l g_j^{x_j+y_j}
\end{align*}

<p>
where \(h=\prod_{j=1}^lg_j^{y_j}\). More precisely: if we already know that \(g\) and \(h\) have
such a representation then from commutativity the representations for \(g\inv\) and \(gh\)
easily follow. Now observe that the set \(S'\) of \(g\) which can be represented like this
must be contained in \(S\) (because the \((g_j)\) generate \(S\)). But we have just seen that
making products and inverses doesn't take us outside of \(S'\). Hence \(S'=S\) as claimed.
</p>

<p>
But now it is obvious that \(S\) is abelian because the standard representations of \(gh\) and
\(hg\) are the same. QED.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Above we used the fact that if \(g_i\) and \(g_j\) commute then also \(g_i^x\) and
\(g_j^y\) commute for any \(x,y\in\ZZ\). This is clear for non-negative \(x\), \(y\). The
general case follows from the fact that \(g_j\) and \(g_i\inv\) commute. In fact, let
\(a=g_j\inv\?g_i\) and \(b=g_ig_j\inv\). Since \(g_i\) and \(g_j\) commute we have
\(g_ja=g_jb\). But this implies \(a=b\).</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-exercise-10.32" class="outline-3">
<h3 id="exercise-10.32">Exercise 10.32</h3>
<div class="outline-text-3" id="text-exercise-10.32">
<p>
Verify that the generators in Figure 10.6 stabilize the codewords for the Steane code, as
described in Section 10.4.2.
</p>
</div>

<div id="outline-container-exercise-10.32-solution" class="outline-4">
<h4 id="exercise-10.32-solution">Solution</h4>
<div class="outline-text-4" id="text-exercise-10.32-solution">
<p>
Note that there is a <a href="#chapter-10-css-as-stabilizer">subtle error</a> in the paragraph right before the exercise. Moreover I
think it makes sense to prove a more <a href="#org03b346c">general theorem</a> given in the intro section of this
site. So let us do this.
</p>

<p>
An element of the CSS code looks like this
</p>

<p>
\[
  \ket{x+C_2} = \frac{1}{\sqrt{\abs{C_2}}} \sum_{y\in C_2} \ket{x + y} ,
\]
</p>

<p>
where \(x\in\?C_1\). Recall that \(C_2\subseteq\?C_1\). Hence all the \(x+y\) above also belong
to \(C_1\). Hence \(A(x+y)=0\). Hence for all \(i=1..(n-k_1)\) we have
</p>

\begin{align*}
  g_{k_2+i}\ket{x+C_2} &= \frac{1}{\sqrt{\abs{C_2}}} \sum_{y\in C_2} \bigotimes_{j=1}^n Z^{A_{ij}} \ket{x + y} \\
  &= \frac{1}{\sqrt{\abs{C_2}}} \sum_{y\in C_2} \underbrace{(-1)^{A_i\cdot(x+y)}}_{= 1} \ket{x + y} \\
  &= \ket{x+C_2} .
\end{align*}

<p>
(I write \(A_i\) for the \(i\)​-th row of \(A\).) Hence the \(g_{k_2+1}\) stabilize the code. To
prove the same statement for \(g_i\) with \(i=1..k_2\) we switch to the X-basis by applying
the Hadamard transform to the state. Note that this transform changes the \(X\) in the
definition of the \(g_i\) to \(Z\). As in section 10.4.2 we see that
</p>

<p>
\[
  H^{\otimes n} \ket{x+C_2} = \sqrt{\frac{\abs{C_2}}{2^n}} \sum_{z\in C_2^\top} (-1)^{x\cdot z} \ket{z} .
\]
</p>

<p>
Hence we see in a similar way as in the first part that
</p>

\begin{align*}
  H^{\otimes n} g_{i}\ket{x+C_2}
  &= H^{\otimes n} g_{i} H^{\otimes n}H^{\otimes n} \ket{x+C_2} \\
  &= \sqrt{\frac{\abs{C_2}}{2^n}} \sum_{z\in C_2^\top} (-1)^{x\cdot z} \bigotimes_{j=1}^n Z^{B_{ij}} \ket{z} \\
  &= \sqrt{\frac{\abs{C_2}}{2^n}} \sum_{z\in C_2^\top} (-1)^{x\cdot z} \underbrace{(-1)^{B_i\cdot z}}_{= 1} \ket{z} \\
  &= H^{\otimes n} \ket{x+C_2} .
\end{align*}

<p>
By dividing away the Hadamard transform we see that the \(g_i\) for \(i=1..k_2\) stabilize the
CSS code too. This already shows the claim of the exercise.
</p>

<p>
In order to finish the proof of the theorem we need to show that the given generators do
not stabilize an even larger space than the desired CSS code. But this is basically a
dimensionality argument. By design the CSS code has dimension \(2^{k}\) where
\(k=k_1-k_2\). On the other hand under certain conditions a stabilizer code with \(n-k\)
generators has the same dimension. Said conditions are that \(-I\notin\?S\) and that the
generators commute (Proposition 10.5). The latter is clear from the form of the
generators. The former follows from the fact that the parity check matrices have full
rank. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.33" class="outline-3">
<h3 id="exercise-10.33">Exercise 10.33</h3>
<div class="outline-text-3" id="text-exercise-10.33">
<p>
Show that \(g\) and \(g'\) commute if and only if \(r(g)\Lambda\?r(g')^T=0\). (In the check
matrix representation, arithmetic is done modulo two.)
</p>
</div>

<div id="outline-container-org00ffbf2" class="outline-4">
<h4 id="org00ffbf2">Solution</h4>
<div class="outline-text-4" id="text-org00ffbf2">
<p>
Let \(\beta=r(g)\Lambda\?r(g')^T\) (which is an element of \(\BB\)). We will show that
</p>

<p>
\[
  gg' = (-1)^\beta g'g ,
\]
</p>

<p>
which implies the claim of the exercise. Let us write
</p>

\begin{align*}
  g &= \alpha \bigotimes_{j=1}^n N_j , \\
  g' &= \alpha' \bigotimes_{j=1}^n N'_j ,
\end{align*}

<p>
where \(N_j,N'_j\in\{I,X,Y,Z\}\), and \(\alpha,\alpha'\in\{1,-1,\ii,-\ii\}\). Without loss of
generality we may assume \(\alpha=\alpha'=1\). Moreover let us split \(r=r_x\oplus\?r_z\)
where \(r_x\) is responsible for the first \(n\) bits and \(r_z\) for the last \(n\) bits. We have
</p>

<p>
\[
  \beta = r_x(g) \cdot r_z(g') + r_z(g) \cdot r_x(g')
  = \sum_{j=1}^n \underbrace{r_x(N_j) \cdot r_z(N'_j) + r_z(N_j) \cdot r_x(N'_j)}_{=:\beta_j} .
\]
</p>

<p>
It is not hard to verify that \(N_jN'_j=(-1)^{\beta_j}N'_jN_j\). Hence
\(gg'=(-1)^{\sum_j\beta_j}g'g\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org2139687" class="outline-3">
<h3 id="org2139687">Exercise 10.34</h3>
<div class="outline-text-3" id="text-org2139687">
<p>
Let \(S=\langle\?g_1,\ldots,g_l\rangle\). Show that \(-I\) is not an element of \(S\) if and
only if \(g_j^2=I\) for all \(j\), and \(g_j\neq-I\) for all \(j\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The implication \(-I\notin\?S\Rightarrow\ldots\) is just <a href="#exercise-10.35">exercise 10.35</a>. The
other direction is actually wrong.</dd>
</dl>
</div>

<div id="outline-container-org2a798d7" class="outline-4">
<h4 id="org2a798d7">Counterexamples</h4>
<div class="outline-text-4" id="text-org2a798d7">
<p>
The claim of the exercise is wrong. To see this consider the following counterexample. Let
</p>

<p>
\[
  g_1 = X, \; g_2 = Z .
\]
</p>

<p>
Clearly \(g_j^2=I\) for all \(j\), and \(g_j\neq-I\) for all \(j\). On the other hand
\(XZXZ=-ZZ=-I\) and hence \(-I\in\?S\). One might wonder if the claim becomes true if one
assumes that the \(g_j\) commute (and are independent). But this is also not true as the
following counterexample shows:
</p>

<p>
\[
  g_1 = Z, \; g_2 = -Z .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.35" class="outline-3">
<h3 id="exercise-10.35">Exercise 10.35</h3>
<div class="outline-text-3" id="text-exercise-10.35">
<p>
Let \(S\) be a subgroup of \(G_n\) such that \(-I\) is not an element of \(S\). Show that \(g^2=I\)
for all \(g\in\?S\), and thus \(g^\dagger=g\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The original exercise contained the additional implication that \(g\in\?-I\) for
all \(g\in\?S\) but this is a slightly too trivial conclusion if you already assume that
\(-I\notin\?S\) - in my opinion.</dd>
</dl>
</div>

<div id="outline-container-org82f13b6" class="outline-4">
<h4 id="org82f13b6">Proof</h4>
<div class="outline-text-4" id="text-org82f13b6">
<p>
Recall that any \(g\in\?G_n\) has the form
</p>

\begin{align*}
  g &= \alpha \bigotimes_{j=1}^n N_j ,
\end{align*}

<p>
where \(N_j\in\{I,X,Y,Z\}\), and \(\alpha\in\{1,-1,\ii,-\ii\}\). Hence
\(g^2=\alpha^2I=\pm\?I\). By \(-I\notin\?S\) we must have \(g^2=I\) as desired. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org790eb4b" class="outline-3">
<h3 id="org790eb4b">Exercise 10.36</h3>
<div class="outline-text-3" id="text-org790eb4b">
<p>
Let \(U\) be the <code>CNOT</code> gate. Explicitly verify that \(UX_1U^\dagger=X_1X_2\),
\(UX_2U^\dagger=X_2\), \(UZ_1U^\dagger=Z_1\), and \(UZ_2U^\dagger=Z_1Z_2\). These and other
useful conjugation relations for the Hadamard, phase, and Pauli gates are summarized in
Figure 10.7.
</p>
</div>

<div id="outline-container-exercise-10.36-solution" class="outline-4">
<h4 id="exercise-10.36-solution">Solution</h4>
<div class="outline-text-4" id="text-exercise-10.36-solution">
<p>
This is a simple and slightly tedious exercise. Hence let us do some fun version of this
exercise: let qiskit solve it! Therefore let us define the following auxiliary function:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">print_ex1036</span>(pauli_strings: <span class="org-builtin">list</span>[<span class="org-builtin">str</span>]):
    <span class="org-doc">"""Given a list of Pauli strings (e.g. ["XI", "IX"]) print how CX acts on them."""</span>
    <span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(2)
    qc.cx(1, 0)  <span class="org-comment-delimiter"># </span><span class="org-comment">swapping control and target compensates for different qubit order</span>
    <span class="org-variable-name">U</span> <span class="org-operator">=</span> Clifford(qc)

    <span class="org-builtin">print</span>(<span class="org-string">"Applying CX acts as"</span>)
    <span class="org-keyword">for</span> pstring <span class="org-keyword">in</span> pauli_strings:
        <span class="org-variable-name">p0</span> <span class="org-operator">=</span> Pauli(pstring)
        <span class="org-variable-name">p1</span> <span class="org-operator">=</span> p0.evolve(U, frame<span class="org-operator">=</span><span class="org-string">"s"</span>)
        <span class="org-builtin">print</span>(f<span class="org-string">"</span>{p0}<span class="org-string"> -&gt; </span>{p1}<span class="org-string">"</span>)
</pre>
</div>

<p>
It prints the solution to this exercise. We also included <code>YI</code> and <code>IY</code> for later reference.
</p>

<div class="org-src-container">
<pre class="src src-python">print_ex1036([<span class="org-string">"XI"</span>, <span class="org-string">"IX"</span>, <span class="org-string">"ZI"</span>, <span class="org-string">"IZ"</span>, <span class="org-string">"YI"</span>, <span class="org-string">"IY"</span>])
</pre>
</div>

<pre class="example">
Applying CX acts as
XI -&gt; XX
IX -&gt; IX
ZI -&gt; ZI
IZ -&gt; ZZ
YI -&gt; YX
IY -&gt; ZY
</pre>


<p>
In case you wonder whether <code class="src src-python">p0.evolve</code> swallows the phase: it does not, as can
be seen from here:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">qc</span> <span class="org-operator">=</span> QuantumCircuit(1)
qc.x(0)
<span class="org-variable-name">U</span> <span class="org-operator">=</span> Clifford(qc)
Pauli(<span class="org-string">"Y"</span>).evolve(U)
</pre>
</div>

<pre class="example">
-Y
</pre>


<p>
As you can see it shows the minus sign and we can correctly infer \(XYX=-Y\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgdb4583b" class="outline-3">
<h3 id="orgdb4583b">Exercise 10.37</h3>
<div class="outline-text-3" id="text-orgdb4583b">
<p>
What is \(UY_1U^\dagger\) (for \(U\) being <code>CNOT</code>)?
</p>
</div>

<div id="outline-container-org46c8428" class="outline-4">
<h4 id="org46c8428">Solution</h4>
<div class="outline-text-4" id="text-org46c8428">
<p>
Knowing the transformation for \(Z_1\) and \(X_1\) suffices to calculate this (also note that
\(U^\dagger=U\)):
</p>

<p>
\[
  UY_1U = -\ii UZ_1X_1U = -\ii UZ_1UUX_1U = -\ii Z_1X_1X_2 = Y_1X_2 .
\]
</p>

<p>
Note also that this coincides with the output in the <a href="#exercise-10.36-solution">solution</a> of exercise 10.36.
</p>
</div>
</div>
</div>

<div id="outline-container-org0cb0aa2" class="outline-3">
<h3 id="org0cb0aa2">Exercise 10.38</h3>
<div class="outline-text-3" id="text-org0cb0aa2">
<p>
Suppose \(U\) and \(V\) are unitary operators on two qubits which transform \(Z_1\), \(Z_2\),
\(X_1\), and \(X_2\) by conjugation in the same way. Show this implies that \(U=V\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Clearly, <i>equality</i> has to be understood in the sense "equal up to global
phase". For example \(\ii\?I\) and \(I\) act the same way under conjugation.</dd>
</dl>
</div>

<div id="outline-container-exercise-10.38-solution" class="outline-4">
<h4 id="exercise-10.38-solution">Proof</h4>
<div class="outline-text-4" id="text-exercise-10.38-solution">
<p>
Let us generalize the exercise by considering \(n\) qubits and assuming that \(U\) and \(V\) act
in the same way on \(Z_j\) and \(X_j\) for all \(j=1..n\). Since these Paulis already generate
the whole Pauli group \(G_n\) we have
</p>

<p>
\[
  \forall g\in G_n: \; UgU^\dagger = VgV^\dagger .
\]
</p>

<p>
Let us note that we can easily deduce that this even holds for all
\(g\in\CC^{2^n\times\?2^n}\). The reason is that the \(4^n\) possible Pauli operators (without
phase) form a basis for this matrix space (they are orthogonal with respect to the
Hilbert-Schmidt inner product). But we do not need this. Instead consider \(J=V^\dagger\?U\)
and observe that
</p>

<p>
\[
  \forall g\in G_n: \; JgJ^\dagger = g = IgI .
\]
</p>

<p>
We have to show that \(J=e^{\ii\varphi}I\) for some \(\varphi\). Note that a stabilizer for
the one dimensional space \(\CC\ket{k}\) generated by a standard basis element \(\ket{k}\) is
given by \(\langle(-1)^{k_j}Z_j\;|\;j=1..n\rangle\) (where \(k_1\ldots\?k_n\) is the binary
expansion of \(k\)). Hence \(J\) has to map \(\CC\ket{k}\) to itself (as \(I\) does). In other
words
</p>

<p>
\[
  J = \sum_{k=1}^n e^{\ii\varphi_k} \proj{k} .
\]
</p>

<p>
For a binary vector \(v\in\BB^n\) let \(X^v=\bigotimes_{j=1}^nX^{v_j}\). Observe that (here
\(v+k\) is performed in \(\BB^n\))
</p>

\begin{align*}
  J X^v J^\dagger &=
    \left( \sum_k e^{\ii\varphi_k} \proj{k} \right)
    \left( \sum_k e^{-\ii\varphi_k} \ket{v+k}\bra{k} \right) \\
  &=
    \left( \sum_k e^{\ii\varphi_k} \proj{k} \right)
    \left( \sum_k e^{-\ii\varphi_{v+k}} \ket{k}\bra{v+k} \right) \\
  &= \sum_k e^{\ii(\varphi_k-\varphi_{v+k})} \ket{k}\bra{v+k} .
\end{align*}

<p>
Comparing this with \(IX^vI\) we see that \(\varphi_k-\varphi_{v+k}=0\) for all \(k\) and
\(v\). In other words, all the \(\varphi_k\) are the same. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.39" class="outline-3">
<h3 id="exercise-10.39">Exercise 10.39</h3>
<div class="outline-text-3" id="text-exercise-10.39">
<p>
Verify (10.91):
</p>

<p>
\[ SXS^\dagger = Y; \quad SZS^\dagger = Z \]
</p>
</div>

<div id="outline-container-org16b619d" class="outline-4">
<h4 id="org16b619d">Proof</h4>
<div class="outline-text-4" id="text-org16b619d">
<p>
The equality \(SZS^\dagger=Z\) follows from the fact that \(S=\sqrt{Z}\) is a function of \(Z\)
(in the sense of the functional calculus for hermitian operators) and hence commutes with
\(Z\).
</p>

<p>
The equality \(SXS^\dagger=Y\) most easily follows from the <a href="chapter_4.html#org2f66b28">bloch sphere interpretation</a>. In
fact, \(S=\ii\?R_z(\pi/2)\) is a rotation by 90° around the z-axis. This rotation maps the
x-axis to the y-axis.
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgea4223a" class="outline-3">
<h3 id="orgea4223a">Exercise 10.40</h3>
<div class="outline-text-3" id="text-orgea4223a">
<p>
Provide an inductive proof of Theorem 10.6 as follows.
</p>

<ol class="org-ol">
<li>Prove that the Hadamard and phase gates can be used to perform any normalizer operation
on a single qubit.</li>
<li>Suppose \(U\) an \(n+1\) qubit gate in \(N(G_{n+1})\) such that \(UZ_1U^\dagger=X_1\otimes\?g\)
and \(UX_1U^\dagger=Z_1\otimes\?g'\) for some \(g,g\in\?G_n\). Define \(U'\) on \(n\) qubits by
\(U'=\sqrt{2}\bra{0}U(\ket{0}\otimes\ket{\psi})\). Use the inductive hypothesis to show
that the construction for U in Figure 10.9 may be implemented using \(O(n^2)\) Hadamard,
phase and <code>CNOT</code> gates.</li>
<li>Show that any gate \(U\in\?N(G_{n+1})\) may be implemented using \(O(n^2)\) Hadamard, phase
and <code>CNOT</code> gates.</li>
</ol>

<pre class="example">
                 ┌───┐
 n+1: ────────■──┤ H ├──■───
      ┌────┐┌─┴─┐└───┘┌─┴──┐
1..n: ┤ U' ├┤ g ├─────┤ g' ├
      └────┘└───┘     └────┘
</pre>
</div>

<div id="outline-container-orgd4debd4" class="outline-4">
<h4 id="orgd4debd4">Proof of (1)</h4>
<div class="outline-text-4" id="text-orgd4debd4">
<p>
A single qubit normalizer gate is a gate \(U\) which satisfies
</p>

<p>
\[
  UZU^\dagger , UXU^\dagger \in \{\pm X, \pm Y, \pm Z\} .
\]
</p>

<p>
We can restrict our attention to the action of \(U\) on \(Z\) and \(X\) because the action on
the other Pauli gates are either trivial (for \(I\)) or can be inferred like in this
example: \(UYU^\dagger=-\ii\?UZU^\dagger\?UXU^\dagger\) (because \(Y=-\ii\?ZX\) or more
generally \(\langle\?Z,X\rangle=G_1\)). In case you wonder why I do not allow e.g.
\(UZU^\dagger=\pm\?I\) or \(UZU^\dagger=\pm\ii\?Z\): This is not possible because conjugation
preserves eigenvalues.
</p>

<p>
A convenient way to go on is to switch into the Bloch sphere picture. In that sense \(U\)
can be identified (neglecting global phase) with a rotation (in three dimensional real
space) which maps \(\hat{z}\) and \(\hat{x}\) to two (orthogonal) axes (including their
negatives). In other words \(\hat{z}\) and \(\hat{x}\) are mapped to
\(\{\pm\hat{x},\pm\hat{y},\pm\hat{z}\}\) where every combination is possible if
orthogonality is satisfied (e.g. mapping <i>both</i> \(\hat{z}\) and \(\hat{x}\) to \(\hat{z}\) is
not possible). In the following we identify the Pauli matrices \(X,Y,Z\) with their
corresponding axes \(\hat{x},\hat{y},\hat{z}\).
</p>

<p>
Note that the Bloch sphere interpretation shows that \(U\) is already uniquely defined by
its action on \(Z\) and \(X\) (for a rotation the action on the third axis is fixed by
orthogonality and orientation-preservation). Compare this to the <a href="#exercise-10.38-solution">solution</a> of exercise
10.38 which also shows this.
</p>

<p>
Let us show that rotations by (multiples of) 90° around any coordinate axis can be used to
compose \(U\). Let \(\calR\) denote the group of all such rotations. Clearly there is a
\(V\in\calR\) which satisfies
</p>

<p>
\[
  V Z V^\dagger = U Z U^\dagger .
\]
</p>

<p>
In case we already have \(VXV^\dagger=UXU^\dagger\) we are done (\(V=U\), hence
\(U\in\calR\)). Otherwise we know that \(UXU^\dagger\) and \(VXV^\dagger\) are both orthogonal
(in the bloch sphere) to \(VZV^\dagger\). Hence there is a \(W\in\calR\) with rotation axis
\(VZV^\dagger\) such that \(WVXV^\dagger\?W^\dagger=UXU^\dagger\). Since \(W\) leaves
\(VZV^\dagger\) invariant we have \(W=U\) and thus \(U\in\calR\).
</p>

<p>
It remains to show that \(\calR=\langle\?H,S\rangle\). Note that
\(S=\sqrt{Z}=\ii\?R_z(\pi/2)\) is a rotation by 90° around \(Z\). Hence \(S\in\calR\). Moreover
\(H=(X+Z)/\sqrt{2}\) is a rotation by 180° around the axis \((X+Z)/\sqrt{2}\). We know that
\(HZH=X\) and \(HXH=Z\). Hence \(H\) is a normalizer and thus \(H\in\calR\). But let us give an
explicit formula in terms of elements of \(\calR\) (you can use the procedure used to show
\(U\in\calR\) to find it)
</p>

<p>
\[
  H = R_x(\pi) R_y(\pi/2) \in \calR .
\]
</p>

<p>
Hence \(\langle\?H,S\rangle\subseteq\calR\). For the other directions note that the 90°
rotations around the three axes \(Z\), \(X\), and \(Y\) are:
</p>

<p>
\[
  \sqrt{Z} = S, \quad \sqrt{X} = HSH, \quad \sqrt{Y} = S\sqrt{X}S^\dagger = SHSHS^3 .
\]
</p>

<p>
To see all this also note that \(Y=SXS^\dagger\) and \(S^\dagger=S^3\). Hence
\(\calR\subseteq\langle\?H,S\rangle\).
</p>
</div>
</div>

<div id="outline-container-org9dc847b" class="outline-4">
<h4 id="org9dc847b">Proof of (2)</h4>
<div class="outline-text-4" id="text-org9dc847b">
<p>
Let us first calculate a matrix representation of the <a href="#orgca6f2da">circuit</a> given in the exercise:
</p>

\begin{align*}
  & (\proj{0}\otimes I + \proj{1}\otimes g) \cdot H\otimes I \cdot
    (\proj{0}\otimes I + \proj{1}\otimes g') \cdot I\otimes U' \\
  =\; & (\proj{0}\otimes I + \proj{1}\otimes g) \cdot
    (\ket{+}\bra{0}\otimes I + \ket{-}\bra{1}\otimes g') \cdot I\otimes U' \\
  =\; & \frac{1}{\sqrt{2}} (\proj{0}\otimes I + \ket{0}\bra{1}\otimes g' +
        \ket{1}\bra{0}\otimes g - \proj{1}\otimes gg') I \otimes U' .
\end{align*}

<p>
Hence the circuit implements the following unitary operator
</p>

<p>
\[
  \tilde{U} = \frac{1}{\sqrt{2}} \begin{bmatrix} U' & g'U' \\ gU' & -gg'U' \end{bmatrix} .
\]
</p>

<p>
We have to show that \(U=\tilde{U}\). Let us note that \(g\) and \(g'\) commute because \(Z_1\)
and \(X_1\) already anti-commute.
</p>

<p>
Now let us investigate \(U\). Let us write it in block form where each block \(U_{ij}\)
represents \(n\) qubits:
</p>

<p>
\[
  U = \begin{bmatrix} U_{00} & U_{01} \\ U_{10} & U_{11} \end{bmatrix} .
\]
</p>

<p>
Note that this already implies \(U_{00}=U'/\sqrt{2}\) (by definition of \(U'\)). Unitarity of
\(U\) (\(UU^\dagger=I\)) implies for \(k\in\{0,1\}\):
</p>

<p>
\[
  \sum_{k=0}^1 U_{ik}U_{jk}^\dagger = \delta_{ij} I_n .
\]
</p>

<p>
Consider
</p>

<p>
\[
  X_1\otimes\?g = UZ_1U^\dagger
  = \sum_{ij}\sum_k (-1)^k \ket{i}\bra{j} \otimes U_{ik} U_{jk}^\dagger .
\]
</p>

<p>
It is not hard to see that this and the unitarity relation imply
</p>

<p>
\[
  \sqrt{2}U_{ij} \text{ is unitary},
\]
</p>

<p>
and
</p>

<p>
\[
  U_{0k}U_{1k}^\dagger = \frac{1}{2} (-1)^k g = U_{1k}U_{0k}^\dagger .
\]
</p>

<p>
In particular \(U'=\sqrt{2}U_{00}\) is unitary. Moreover, those findings further imply
</p>

<p>
<a id="org5d355ca"></a>
</p>
\begin{align*}
  U_{10} &= gU_{00} = \frac{1}{\sqrt{2}} g U' , \\
  U_{11} &= -g U_{01} .
\end{align*}

<p>
Next consider
</p>

<p>
\[
  Z_1\otimes g' = UX_1U^\dagger = \sum_{ij}\sum_k \ket{i}\bra{j} \otimes U_{ik}U_{j\overline{k}}^\dagger ,
\]
</p>

<p>
where \(\overline{k}=k+1\) (in \(\BB\)). From this we deduce
</p>

\begin{align*}
  U_{10}U_{01}^\dagger + U_{11}U_{00}^\dagger &= 0 , \\
  U_{10}U_{11}^\dagger + U_{11}U_{10}^\dagger &= -g' .
\end{align*}

<p>
The first of these two relations can be used with the <a href="#org5d355ca">formulas</a> for \(U_{10}\) and \(U_{11}\)
to deduce \(U_{00}U_{11}^\dagger=gU_{11}U_{00}^\dagger\?g\). This can be used in the second
relation and again with said formulas (to replace \(U_{10}\)) to obtain
</p>

<p>
\[
  U_{11} = -gg' U_{00} = \frac{-1}{\sqrt{2}} gg' U' .
\]
</p>

<p>
From this we also deduce \(U_{01}=-gU_{11}=g'U'/\sqrt{2}\). Hence we proved
\(U=\tilde{U}\). It remains to count the number of gates to implement the circuit given for
\(\tilde{U}=U\). By the induction hypothesis we need \(O(n^2)\) gates (<code>CNOT</code>, \(S\), \(H\)) to
implement \(U'\) (it is clearly a normalizer because \(U\) is one and we will show that the
rest in the circuit is also a normalizer). The controlled Pauli gates \(C(g)\) and \(C(g')\)
can be implemented by at most \(n\) gates of the form \(C(N)\) where
\(N\in\{\pm\,X,\pm\,Y,\pm\,Z\}\) (each of which are normalizer gates and can be implemented
by at most five of our base gates).
</p>

<p>
To summarize: If \(s_n=O(n^2)\) is the maximal number of gates (\(S\), \(H\), <code>CNOT</code>) needed to
implement an \(n\)​-qubit normalizer gate, then the circuit \(U\) can be implemented in at most
</p>

<p>
\[
  s_n + 10n + 1 = O(n^2)
\]
</p>

<p>
many gates.
</p>
</div>
</div>

<div id="outline-container-orga1f20cd" class="outline-4">
<h4 id="orga1f20cd">Proof of (3)</h4>
<div class="outline-text-4" id="text-orga1f20cd">
<p>
Let \(U\) be any \(n+1\)​-qubit normalizer gate. Then we have
</p>

\begin{align*}
  U Z_1 U^\dagger &= M \otimes g , \\
  U X_1 U^\dagger &= N \otimes g' ,
\end{align*}

<p>
where we assume that \(M,N\in\{\pm\,I,\pm\,X,\pm\,Y,\pm\,Z\}\) and \(g\) and \(g'\) are a
product of such operators (even without sign to make them unique). There are two cases:
</p>

<dl class="org-dl">
<dt>Case 1</dt><dd>\(M,N\in\{\pm\,X,\pm\,Y,\pm\,Z\}\) are <i>both</i> "proper" Pauli operators (none of
them is plus/minus the identity).</dd>
<dt>Case 2</dt><dd>\(M=\pm\,I\) or \(N=\pm\,I\).</dd>
</dl>

<p>
Consider <b>case 1</b>. By the proof of part (1) we can apply \(O(1)\) many single qubit
operations to implement a circuit \(V\) which does \(VMV^\dagger=X\) and
\(VNV^\dagger=Z\). Hence \(VU\) satisfies the assumptions of part (2) and this case can be
reduced to part (2).
</p>

<p>
Consider <b>case 2</b>. Recall that swap gates can be implemented by three <code>CNOT</code> gates. Try to
find a qubit \(j\) so that both \(M\otimes\?g\) and \(N\otimes\?g'\) have a proper Pauli at
position \(j\). If this is possible we can just swap qubits \(1\) and \(j\) to reduce to
case 1. Otherwise we can at least assume that e.g. \(M\neq\pm\?I\) by a swap argument. Hence
we have the following situation
</p>

\begin{align*}
  U Z_1 U^\dagger &= M \otimes I \otimes \ldots , \\
  U X_1 U^\dagger &= I \otimes K \otimes \ldots ,
\end{align*}

<p>
where again by a swap argument \(K\neq\pm\?I\) can be assumed. Without loss of generality we
can even assume that \(M=X\) and \(K=Z\):
</p>


\begin{align*}
  U Z_1 U^\dagger &= X \otimes I \otimes \ldots , \\
  U X_1 U^\dagger &= I \otimes Z \otimes \ldots .
\end{align*}

<p>
In fact, this follows from part (1) by applying single qubit operations to the first and
second qubit. Note that applying a single <code>CNOT</code> gate (with control at \(1\) and target at
\(2\)) the RHS can be replaced by
</p>

\begin{align*}
  & X \otimes X \otimes \ldots , \\
  & Z \otimes Z \otimes \ldots .
\end{align*}

<p>
which leaves us in the situation of case 1. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb0f089f" class="outline-3">
<h3 id="orgb0f089f">Exercise 10.41</h3>
<div class="outline-text-3" id="text-orgb0f089f">
<p>
Verify Equations (10.92) through (10.95):
</p>
</div>

<div id="outline-container-org8f003e8" class="outline-4">
<h4 id="org8f003e8">Solution</h4>
<div class="outline-text-4" id="text-org8f003e8">
<p>
The equations
</p>

<p>
\[
  TZT^\dagger = Z; \quad TXT^\dagger = \frac{X+Y}{\sqrt{2}}
\]
</p>

<p>
can be seen in exact the same way as the corresponding equations in <a href="#exercise-10.39">exercise 10.39</a>. The
first one follows most easily from commutativity, using \(T=\sqrt[4]{Z}\). The second one
from the fact that \(T\) is a 45° rotation around the z-axis which maps the x-axis to
\((\hat{x}+\hat{y})/\sqrt{2}\).
</p>

<p>
The relations \(UNU^\dagger=N\) for \(N=Z_1,Z_2,X_3\) follow from commutativity (the Toffoli
gate is a sum of tensor products of the eigen-projectors of \(Z_1\), \(Z_2\) with \(X_3\)
because a controlled gate like \(C(V)\) is just \(\proj{0}\otimes\?I+\proj{1}\otimes\?V\)).
</p>

<p>
For the remaining three formulas let us use sage to verify them:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">U</span> <span class="org-operator">=</span> CCX
<span class="org-keyword">assert</span> U <span class="org-operator">==</span> U.H, <span class="org-string">"CCX is symmetric!"</span>

<span class="org-keyword">assert</span> U <span class="org-operator">*</span> XII <span class="org-operator">*</span> U <span class="org-operator">==</span> kron(X, II <span class="org-operator">+</span> ZI <span class="org-operator">+</span> IX <span class="org-operator">-</span> kron(Z,X)) <span class="org-operator">/</span> 2
<span class="org-keyword">assert</span> U <span class="org-operator">*</span> IXI <span class="org-operator">*</span> U <span class="org-operator">==</span> (IXI <span class="org-operator">+</span> IXI<span class="org-operator">*</span>ZII <span class="org-operator">+</span> IXI<span class="org-operator">*</span>IIX <span class="org-operator">-</span> kron(Z,X,X)) <span class="org-operator">/</span> 2
<span class="org-keyword">assert</span> U <span class="org-operator">*</span> IIZ <span class="org-operator">*</span> U <span class="org-operator">==</span> kron(II <span class="org-operator">+</span> ZI <span class="org-operator">+</span> IZ <span class="org-operator">-</span> kron(Z,Z), Z) <span class="org-operator">/</span> 2
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
To find these formulas one could use that the Pauli matrices (without phase) form an
orthogonal basis of \(\CC^{2^n\times2^n}\) with respect to the Hilbert-Schmidt scalar
product. Also note that the norm of each Pauli operator is \(2^{n/2}\). Hence to compute
e.g. the coefficients of \(UX_1U^\dagger\) one could do the following:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">A</span> <span class="org-operator">=</span> U <span class="org-operator">*</span> XII <span class="org-operator">*</span> U
<span class="org-keyword">assert</span> A <span class="org-operator">==</span> A.H, <span class="org-string">"Nice to have, to avoid typing A.H all the time."</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">For example: coefficients of XII and IXI of A are:</span>
<span class="org-keyword">assert</span> trace(A <span class="org-operator">*</span> XII) <span class="org-operator">/</span> 8 <span class="org-operator">==</span> 1<span class="org-operator">/</span>2
<span class="org-keyword">assert</span> trace(A <span class="org-operator">*</span> IXI) <span class="org-operator">/</span> 8 <span class="org-operator">==</span> 0
<span class="org-comment-delimiter"># </span><span class="org-comment">... and so on.</span>
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc7b506" class="outline-3">
<h3 id="orgdc7b506">Exercise 10.42</h3>
<div class="outline-text-3" id="text-orgdc7b506">
<p>
Use the stabilizer formalism to verify that the circuit of Figure 1.13 on page 27
teleports qubits, as claimed. Note that the stabilizer formalism restricts the class of
states being teleported, so in some sense this is not a complete description of
teleportation, nevertheless it does allow an understanding of the dynamics of
teleportation.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Unfortunately I do not see how this exercise improves my understanding of
teleportation. It seems to be a very complicated way to verify that the circuit actually
teleports qubits. On the other hand it is a nice exercise to understand the (certainly
very useful) stabilizer formalism.</dd>
</dl>
</div>

<div id="outline-container-org817312c" class="outline-4">
<h4 id="org817312c">Solution</h4>
<div class="outline-text-4" id="text-org817312c">
<p>
The circuit can be divided into three major steps:
</p>
<ul class="org-ul">
<li>Unitary evolution up until the measurements,</li>
<li>Measuring the first two qubits in the Z-basis,</li>
<li>Performing conditioned operations on the third qubit.</li>
</ul>

<p>
I split up the solution according to the three stages. Additionally I add a section on a
specific example to get some feeling for how things work out.
</p>
</div>

<div id="outline-container-org3721198" class="outline-5">
<h5 id="org3721198">Unitary evolution</h5>
<div class="outline-text-5" id="text-org3721198">
<p>
Let \(\ket{\psi}\) be the single qubit state to be teleported. The whole system is in the
state \(\ket{\psi,0,0}\) initially (the circuit displayed in Figure 1.12 produces
\(\ket{\psi,\beta_{00}}\) which feeds into the circuit in Figure 13.).
</p>

<p>
Let \(N\in\{\pm\?X,\pm\?Y,\pm\?Z\}\) be the stabilizer of \(\ket{\psi}\). Of course this
restricts \(\ket{\psi}\) to be an eigenstate of one of the Paulis (six possibilities up to
global phase), but this is just the restriction of the stabilizer formalism already
mentioned in the statement of the exercise. The stabilizer of the whole system is
\(\langle\?N_1,Z_2,Z_3\rangle\) (where \(N_1=N\otimes\?I\otimes\?I\)).
</p>

<p>
Let us abbreviate \(V=\cx_{12}\) and calculate the evolution by the stabilizer formalism:
</p>

\begin{align*}
  & \langle N_1, Z_2, Z_3 \rangle & (\text{initial state } \ket{\psi,0,0}) \\
  H_2 :\; & \langle N_1, X_2, Z_3 \rangle  \\
  \cx_{23} :\; & \langle N_1, X_2X_3, Z_2Z_3 \rangle & (\ket{\psi,\beta_{00}}) \\
  \cx_{12} :\; & \langle VN_1V, X_2X_3, Z_1Z_2Z_3 \rangle \\
  H_1 :\; & \langle H_1VN_1VH_1, X_2X_3, X_1Z_2Z_3 \rangle & (\text{right before measurement}).
\end{align*}

<p>
In the following let us denote by \(g_1\), \(g_2\), \(g_3\) the three generators from the last
step:
</p>

<p>
\[
  g_1 = HVN_1VH, \quad g_2 = X_2X_3, \quad g_3 = X_1Z_2Z_3 .
\]
</p>
</div>
</div>

<div id="outline-container-orgdfa4c1f" class="outline-5">
<h5 id="orgdfa4c1f">Intermezzo: A specific example</h5>
<div class="outline-text-5" id="text-orgdfa4c1f">
<p>
Let us look at the specific example \(N=+X\), i.e. \(\ket{\psi}=\ket{+}\) (up to global
phase). Here we have
</p>

<p>
\[
  g_1 = H_1V N_1 VH_1 = Z_1X_2 .
\]
</p>

<p>
We have to measure \(Z_1\) and \(Z_2\). Lets do \(Z_1\) first. Clearly it anti-commutes with
\(g_3\) and commutes with the others. This is precisely one of the two standard situations
described in section 10.5.3 which outlines how measurements are performed in the
stabilizer formalism. If we measure \((-1)^{m_1}\) for \(m_1\in\BB\) the post-measurment state
is
</p>

<p>
\[
  S' = \langle Z_1X_2, X_2X_3, (-1)^{m_1}Z_1 \rangle .
\]
</p>

<p>
Next we measure \(Z_2\). Note that \(Z_2\) anti-commutes with two of the generators from the
preciding equation. We can fix this by multiplying the second one to the first one:
</p>

<p>
\[
  S' = \langle Z_1X_3, X_2X_3, (-1)^{m_1}Z_1 \rangle .
\]
</p>

<p>
Now \(Z_2\) only anti-commutes with the second generator. If we measure \((-1)^{m_2}\) for
\(m_2\in\BB\) the post-measurment state is
</p>

<p>
\[
  S'' = \langle Z_1X_3, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle
  = \langle (-1)^{m_1} X_3, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle .
\]
</p>

<p>
For the second equality we multiplied the third generator to the first one to get rid of
the \(Z_1\). Let us note two things here: the second and the third generator do not affect
the third qubit and just say that the first two qubits are in the state
\(\ket{m_1,m_2}\). On the other hand \((-1)^{m_1}X_3\) only refers to the third qubit and says
that it is in the state \(H\ket{m_1}\in\{\ket{+},\ket{-}\}\). For teleportation to be
succesful we thus have to get rid of the sign bit \(m_1\). This is what the conditioned
operations accomplish.
</p>

\begin{align*}
  & S'' = \langle (-1)^{m_1}X_3, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle \\
  X_3^{m_2} :\; & \langle (-1)^{m_1} X_3, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle \\
  Z_3^{m_1} :\; & \langle X_3, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle .
\end{align*}

<p>
Note that the last state is indeed \(\ket{m_1,m_2,\psi}\) as desired. Thus we have verified
the teleportation property for the particular state stabilized by \(N=+X\).
</p>
</div>
</div>

<div id="outline-container-org080f32e" class="outline-5">
<h5 id="org080f32e">Measuring \(Z_1\) and \(Z_2\)</h5>
<div class="outline-text-5" id="text-org080f32e">
<p>
More generally any (for the stabilizer formalism) possible single qubit state is
stabilized by some \(N=(-1)^s\ii^{ab}X^aZ^b\in\{\pm\?X,\pm\?Y,\pm\?Z\}\) where
\(s,a,b\in\BB\). Hence the state right before measurement is
</p>

\begin{align*}
  S &= \langle H_1V (-1)^s \ii^{ab} X_1^aZ_1^b VH_1, X_2X_3, X_1Z_2Z_3 \rangle \\
  &= \langle H_1 (-1)^s \ii^{ab} X_1^aX_2^aZ_1^b H_1, X_2X_3, X_1Z_2Z_3 \rangle \\
  &= \langle (-1)^s \ii^{ab} Z_1^aX_2^aX_1^b, X_2X_3, X_1Z_2Z_3 \rangle \\
  &= \langle (-1)^{s+ab} \ii^{ab} X_1^bX_2^aZ_1^a, X_2X_3, X_1Z_2Z_3 \rangle .
\end{align*}

<p>
In the last equality I brought the product in the standard form so that all \(X\) precede
all \(Z\). Doing so I had to move \(X_1^b\) past \(Z_1^a\), which introduces an additional sign
factor \(-1\) in case \(a=b=1\).
</p>

<p>
Let us measure \(Z_1\) now. Note that it anti-commutes with the first generator iff \(b=1\),
and always anti-commutes with the third generator. To fix this multiply the first
generator by the third one raised to the power \(b\) to obtain (note that this cancels the
\((-1)^{ab}\) if we rearrange the Paulis in the "X first" order):
</p>

\begin{align*}
  S = \langle (-1)^{s} \ii^{ab} X_2^aZ_1^aZ_2^bZ_3^b, X_2X_3, X_1Z_2Z_3 \rangle .
\end{align*}

<p>
Now \(Z_1\) only anti-commutes with the third generator. After measuring \((-1)^{m_1}\) for
\(m_1\in\BB\) the post-measurment state is
</p>

\begin{align*}
  S' = \langle (-1)^{s} \ii^{ab} X_2^aZ_1^aZ_2^bZ_3^b, X_2X_3, (-1)^{m_1}Z_1 \rangle .
\end{align*}

<p>
Now let us measure \(Z_2\). Observe that \(Z_2\) anti-commutes with the first generator iff
\(a=1\) and always with the second generator. To fix this let us multipy the first generator
by the second raised to the power \(a\):
</p>

\begin{align*}
  S' = \langle (-1)^{s} \ii^{ab} X_3^aZ_1^aZ_2^bZ_3^b, X_2X_3, (-1)^{m_1}Z_1 \rangle .
\end{align*}

<p>
Now \(Z_2\) only anti-commutes with the second generator. Hence, aber measuring \((-1)^{m_2}\)
for \(m_2\in\BB\) the post-measurment state is
</p>

\begin{align*}
  S'' &= \langle (-1)^{s} \ii^{ab} X_3^aZ_1^aZ_2^bZ_3^b, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle \\
  &= \langle (-1)^{s+m_1a+m_2b} \ii^{ab} X_3^aZ_3^b, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle .
\end{align*}

<p>
In the second equality I multiplied the first generator by the second and third raised to
the power \(a\).
</p>
</div>
</div>

<div id="outline-container-org22d6cec" class="outline-5">
<h5 id="org22d6cec">Apply \(Z_3^{m_1}X_3^{m_2}\)</h5>
<div class="outline-text-5" id="text-org22d6cec">
<p>
Let us finally apply the conditioned operations:
</p>

\begin{align*}
  & S'' = \langle (-1)^{s+m_1a+m_2b} \ii^{ab} X_3^aZ_3^b, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle \\
  X_3^{m_2} :\; & \langle (-1)^{s+m_1a} \ii^{ab} X_3^aZ_3^b, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle \\
  Z_3^{m_1} :\; & \langle (-1)^{s} \ii^{ab} X_3^aZ_3^b, (-1)^{m_2}Z_2, (-1)^{m_1}Z_1 \rangle .
\end{align*}

<p>
The final result is the stabilizer of the state \(\ket{m_1,m_2,\psi}\) as desired.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcf27ad7" class="outline-3">
<h3 id="orgcf27ad7">Exercise 10.43</h3>
<div class="outline-text-3" id="text-orgcf27ad7">
<p>
Show that \(S\subseteq\?N(S)\) for any subgroup \(S\) of \(G_n\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>One can replace \(G_n\) by and group \(G\) and the statement is still true.</dd>
</dl>
</div>

<div id="outline-container-orge031ca6" class="outline-4">
<h4 id="orge031ca6">Proof</h4>
<div class="outline-text-4" id="text-orge031ca6">
<p>
Recall that the normalizer of a subgroup \(S\) of a group \(G\) is
</p>

<p>
\[
  N(S) = \left\{ g\in G\; | \; \forall s\in S: gsg\inv \in g \right\} .
\]
</p>

<p>
By the group property, if \(g\in\?S\) then also \(gsg\inv\in\?S\). Hence
\(S\subseteq\?N(S)\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.44" class="outline-3">
<h3 id="exercise-10.44">Exercise 10.44</h3>
<div class="outline-text-3" id="text-exercise-10.44">
<p>
Show that \(N(S)=Z(S)\) for any subgroup \(S\) of \(G_n\) not containing \(-I\).
</p>
</div>

<div id="outline-container-org2a199de" class="outline-4">
<h4 id="org2a199de">Proof</h4>
<div class="outline-text-4" id="text-org2a199de">
<p>
Obviously we have \(Z(S)\subseteq\?N(S)\) (for any subgroup \(S\) of any group). Hence we only
have to show the other inclusion and this is where we need the fact that we are in the
Pauli group and \(-I\notin\?S\).
</p>

<p>
Let \(g\in\?N(S)\).
</p>

<p>
Recall that for \(g,h\in\?G_n\) we have \(gh=\pm\?hg\), that is, two elements of the Pauli
group either commute or anti-commute. In particular
</p>

<p>
\[
  \forall s \in S: gsg^\dagger = \pm s .
\]
</p>

<p>
We have to show that always the \(+\) sign holds. Assume to the contrary that there is a
\(s\in\?S\) such that \(gsg^\dagger=-s\). Using \(g\in\?N(S)\) we deduce \(-s\in\?S\). Note that
\(s^2=I\) by <a href="#exercise-10.35">exercise 10.35</a>. Hence \(S\owns\?s\cdot(-s)=-I\) - contradiction! QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org2f461db" class="outline-3">
<h3 id="org2f461db">Exercise 10.45 (Correcting located errors)</h3>
<div class="outline-text-3" id="text-org2f461db">
<p>
Suppose \(C(S)\) is an \([n,k,d]\) stabilizer code. Suppose \(k\) qubits are encoded in \(n\)
qubits using this code, which is then subjected to noise. Fortunately, however, we are
told that only \(d-1\) of the qubits are affected by the noise, and moreover, we are told
precisely which \(d-1\) qubits have been affected. Show that it is possible to correct the
effects of such located errors.
</p>
</div>

<div id="outline-container-org7bad4a2" class="outline-4">
<h4 id="org7bad4a2">Proof</h4>
<div class="outline-text-4" id="text-org7bad4a2">
<p>
Let us first consider the case that we know that the errors only happen in the first \(d-1\)
qubits. The set of all such errors is the linear span of the following set of base errors:
</p>

<p>
\[
  \calE = \left\{\bigotimes_{j=1}^{d-1} N_j \otimes I^{\otimes(n-d+1)} \; \middle| \; N_j \in \{I,X,Y,Z\} \right\} .
\]
</p>

<p>
To see this recall that the Pauli operators are an orthogonal basis with respect to the
Hilbert-Schmidt inner product. By theorem 10.2 a recovery procedure \(\calR\) which corrects
all errors in \(\calE\) also corrects all errors in the linear span and hence all errors
affecting the first \(d-1\) qubits.
</p>

<p>
Clearly the weight of \(E^\dagger\?F\) is at most \(d-1\) for every \(E,F\in\calE\). Since
\(C(S)\) has distance \(d\) this means that \(E^\dagger\?F\notin\?N(S)\backslash\?S\). By
theorem 10.8 there exists a recovery procedure \(\calR\) which corrects all errors in
\(\calE\).
</p>

<p>
More generally consider errors at arbitrary positions. Let \(\varepsilon\in\BB^n\) encode at
which positions an error occured (\(\varepsilon_j=1\) means that an error <i>might</i> have
happened at position \(j\) and \(\varepsilon=0\) means that <i>definitively</i> no error occured at
position \(j\)). We consider only the \(\binom{n}{d-1}\) many \(\varepsilon\in\BB^n\) which have
weight \(d-1\) (they could have smaller weight but this doesn't change anything in the
arguments). The argument above obviously generalizes to: For every error for which we know
the corresponding error locations \(\varepsilon\) (with weight \(d-1\)) there is a recovery
procedure \(\calR_{\epsilon}\) (only depending on \(\varepsilon\)) which corrects this error.
</p>

<p>
To summarize, the general error correction procedure is:
</p>

<ul class="org-ul">
<li>Determine the location of the errors \(\varepsilon\in\BB^n\).</li>
<li>Apply \(\calR_{\varepsilon}\) to correct a possible error.</li>
</ul>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org84aec97" class="outline-3">
<h3 id="org84aec97">Exercise 10.46</h3>
<div class="outline-text-3" id="text-org84aec97">
<p>
Show that the stabilizer for the three qubit phase flip code is generated by \(X_1X_2\) and
\(X_2X_3\).
</p>
</div>

<div id="outline-container-org758e06e" class="outline-4">
<h4 id="org758e06e">Proof</h4>
<div class="outline-text-4" id="text-org758e06e">
<p>
We already know that \(Z_1Z_2\) and \(Z_2Z_3\) are generators of the stabilizer of the bit
flip code. Since "everything" about the phase flip code is just the Hadamard transform of
the bit flip code, the claim follows.
</p>

<p>
Alternatively you could first check that the code words
</p>

<p>
\[
  a\ket{+++} + b\ket{---}
\]
</p>

<p>
of the phase flip code are stabilized by \(X_1X_2\) and \(X_2X_3\) (which is easy to
see). From the beginning of chapter 10.5.1 (p. 455) we know that this implies that
\(S=\langle\?X_1X_2,X_2X_3\rangle\) commutes (which is clear) and does not contain
\(-I\). Hence using that \(X_1X_2\) and \(X_2X_3\) are independent proposition 10.5 implies that
the generated code \(V_S\) is two dimensional. We have already seen that \(V_S\) contains the
phase flip code, so it must be identical with it. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org20d1135" class="outline-3">
<h3 id="org20d1135">Exercise 10.47</h3>
<div class="outline-text-3" id="text-org20d1135">
<p>
Verify that the generators of Figure 10.11 generate the two codewords of Equation (10.13)
(Shor code).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">g1</td>
<td class="org-left"><code>ZZIIIIIII</code></td>
</tr>

<tr>
<td class="org-left">g2</td>
<td class="org-left"><code>IZZIIIIII</code></td>
</tr>

<tr>
<td class="org-left">g3</td>
<td class="org-left"><code>IIIZZIIII</code></td>
</tr>

<tr>
<td class="org-left">g4</td>
<td class="org-left"><code>IIIIZZIII</code></td>
</tr>

<tr>
<td class="org-left">g5</td>
<td class="org-left"><code>IIIIIIZZI</code></td>
</tr>

<tr>
<td class="org-left">g6</td>
<td class="org-left"><code>IIIIIIIZZ</code></td>
</tr>

<tr>
<td class="org-left">g7</td>
<td class="org-left"><code>XXXXXXIII</code></td>
</tr>

<tr>
<td class="org-left">g8</td>
<td class="org-left"><code>IIIXXXXXX</code></td>
</tr>

<tr>
<td class="org-left">Logical Z</td>
<td class="org-left"><code>XXXXXXXXX</code></td>
</tr>

<tr>
<td class="org-left">Logical X</td>
<td class="org-left"><code>ZZZZZZZZZ</code></td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgba3f69c" class="outline-4">
<h4 id="orgba3f69c">Solution</h4>
<div class="outline-text-4" id="text-orgba3f69c">
<p>
The Shor code encodes the two logical qubits as
</p>

<p>
\[
  \ket{k_L} = \bigotimes_{j=1}^3 \frac{1}{\sqrt{2}} (\ket{000} + (-1)^k \ket{111}),
  \quad (k\in\BB) .
\]
</p>

<p>
It is sufficient to check that the generators \(g_i\) stabilize the two base code words. In
fact, by the argument from the beginning of chapter 10.5.1 (p. 455) all \(g_i\) commute
(which is easy to see directly) and \(-I\notin\?S\). Since the \(g_i\) are clearly independent
a dimensionality argument based on proposition 10.5 then shows that \(S\) only stabilizes
the Shor code and not a larger code space.
</p>

<p>
Now let us check that the generators indeed stabilize the base code words. Observe that
the qubits of \(\ket{k_L}\) can be split into three identical blocks with three qubits
each. The generators \(g_i\) for \(i=1..6\) leave each single block invariant, hence they
stabilize \(\ket{k_L}\). Moreover \(g_7\) inverts the sign (the \((-1)^k\) term) of the first
two blocks, which in total has no effect either. Hence \(g_7\) stabilizes \(\ket{k_L}\). A
similar argument applies to \(g_8\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgde81c5d" class="outline-3">
<h3 id="orgde81c5d">Exercise 10.48</h3>
<div class="outline-text-3" id="text-orgde81c5d">
<p>
Show that the operations \(\bar{Z}=X_1X_2X_3X_4X_5X_6X_7X_8X_9\) and
\(\bar{X}=Z_1Z_2Z_3Z_4Z_5Z_6Z_7Z_8Z_9\) act as logical \(Z\) and \(X\) operations on a Shor-code
encoded qubit. That is, show that this \(\bar{Z}\) is independent of and commutes with the
generators of the Shor code, and that \(\bar{X}\) is independent of and commutes with the
generators of the Shor code, and anti-commutes with \(\bar{Z}\).
</p>
</div>

<div id="outline-container-orgf4afd63" class="outline-4">
<h4 id="orgf4afd63">Solution</h4>
<div class="outline-text-4" id="text-orgf4afd63">
<p>
That \(\bar{Z}\) and \(\bar{X}\) commute with the \(g_i\) should be clear from inspection. That
they anti-commute with each other is also clear.
</p>

<p>
Let \(\ket{k_L}\) for \(k\in\BB\) be the two base code words of the Shor code for the two
standard base states of the logical qubit.
</p>

<p>
In my opinion the easiest way to see that \(\bar{Z}\) is independent from the generators is
to observe that it stabilizes \(\ket{0_L}\) but not \(\ket{1_L}\) (eigenvalue \(-1\)). (If
\(\bar{Z}\) were dependent it would be an element of the generated subgroup \(S\) and hence
had to stabilize <i>both</i> code words.) The justification to call it "Z" comes from
\(\bar{Z}\ket{k_L}=(-1)^k\ket{k_L}\). A similar argument applies to \(\bar{X}\) which swaps
\(\ket{0_L}\) with \(\ket{1_L}\) (which justifies to call it "X"). QED.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Another possible definition of the Z and X operator would be
\(\bar{Z}=X_1X_2X_3\) and \(\bar{X}=Z_1Z_4Z_7\). Those two operators behave the same way on
the code space as the original operators.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org95edcfe" class="outline-3">
<h3 id="org95edcfe">Exercise 10.49</h3>
<div class="outline-text-3" id="text-org95edcfe">
<p>
Use Theorem 10.8 to verify that the five qubit code can protect against an arbitrary
single qubit error.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">g1</td>
<td class="org-left"><code>XZZXI</code></td>
</tr>

<tr>
<td class="org-left">g2</td>
<td class="org-left"><code>IXZZX</code></td>
</tr>

<tr>
<td class="org-left">g3</td>
<td class="org-left"><code>XIXZZ</code></td>
</tr>

<tr>
<td class="org-left">g4</td>
<td class="org-left"><code>ZXIXZ</code></td>
</tr>

<tr>
<td class="org-left">Logical Z</td>
<td class="org-left"><code>ZZZZZ</code></td>
</tr>

<tr>
<td class="org-left">Logical X</td>
<td class="org-left"><code>XXXXX</code></td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-exercise-10.49-solution" class="outline-4">
<h4 id="exercise-10.49-solution">Solution</h4>
<div class="outline-text-4" id="text-exercise-10.49-solution">
<p>
A basis for the set \(\calE\) of single qubit errors is given by all Pauli operators on five
qubits with weight (at most) one (e.g. <code>XIIII</code>, <code>IIZII</code>, etc.).
</p>

<p>
In principle we have to check that \(E^\dagger\?F\notin\?N(S)\backslash\?S\) for every
combination of of \(E,F\in\calE\). These are a lot of checks to perform. We can simplify the
task by using the following lemma:
</p>

<p>
<a id="org0b8919b"></a>
</p>
<dl class="org-dl">
<dt>Lemma</dt><dd><p>
For \(E,F\in\calE\) we have
</p>
<ol class="org-ol">
<li>\(E^\dagger\?F\in\?S\) is equivalent to \(E\cong\?F\), that is, they are identical if
restricted to the stabilized subspace \(V_S\).</li>
<li>\(E^\dagger\?F\in\?N(S)\) is equivalent to \(E\) and \(F\) having the same syndromes.</li>
</ol>

<dl class="org-dl">
<dt>Proof of (1)</dt><dd>By assumption we have \(s:=E^\dagger\?F\in\?S\). In other words
\(F=Es\). This implies \(F\ket{\psi}=E\ket{\psi}\) for each \(\ket{\psi}\in\?V_S\). QED.</dd>
<dt>Proof of (2)</dt><dd><p>
By <a href="#exercise-10.44">exercise 10.44</a> (\(Z(S)=N(S)\) in our situation) we have
</p>

<p>
\[ \forall g\in S: \; E^\dagger F g = g E^\dagger F . \]
</p>

<p>
Note that this is the same as
</p>

<p>
\[ \forall g\in S: \; F g F^\dagger = E g E^\dagger . \]
</p>

<p>
Let \(\beta(g,E)\) be the syndrome of \(E\) when the observable \(g\in\?S\) is
measured. Recall that this means \(EgE^\dagger=(-1)^{\beta(g,E)}g\). Using what we
mentioned at the beginning of the proof this yields the claim. QED.
</p></dd>
</dl></dd>
</dl>

<p>
We will show that the fifteen "proper" errors \(\calE\backslash\?I^{\otimes5}\) all have
different non-zero syndromes. Using the lemma we see that this is sufficient to prove that
the code corrects all single qubit errors. It would be OK if some errors have the same
syndrome as long as they act identically on the code space (\(E^\dagger\?F\in\?S\)), but
this does not happen for the five qubit code.
</p>

<p>
In order to show this, let us use qiskit:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org95ec1ad"><span class="org-keyword">def</span> <span class="org-function-name">compute_syndromes</span>(generators: <span class="org-builtin">list</span>[Pauli]):
    <span class="org-doc">"""Given the generators of a [n,k=1] code this computes the syndromes for</span>
<span class="org-doc">    each possible single qubit (Pauli) error."""</span>
    <span class="org-variable-name">n</span> <span class="org-operator">=</span> generators[0].num_qubits
    <span class="org-variable-name">paulis</span> <span class="org-operator">=</span> [<span class="org-string">"X"</span>, <span class="org-string">"Y"</span>, <span class="org-string">"Z"</span>]

    <span class="org-variable-name">errors</span> <span class="org-operator">=</span> [Pauli(<span class="org-string">"I"</span><span class="org-operator">*</span>i <span class="org-operator">+</span> p <span class="org-operator">+</span> <span class="org-string">"I"</span><span class="org-operator">*</span>(n<span class="org-operator">-</span>i<span class="org-operator">-</span>1))
              <span class="org-keyword">for</span> (i, p) <span class="org-keyword">in</span> product(<span class="org-builtin">range</span>(n), paulis)]

    <span class="org-variable-name">syndromes</span> <span class="org-operator">=</span> <span class="org-builtin">dict</span>()

    <span class="org-keyword">for</span> err <span class="org-keyword">in</span> errors:
        <span class="org-variable-name">syndrome</span> <span class="org-operator">=</span> <span class="org-string">""</span>
        <span class="org-keyword">for</span> i, gi <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(generators, 1):
            <span class="org-keyword">if</span> gi.anticommutes(err):
                <span class="org-variable-name">syndrome</span> <span class="org-operator">+=</span> <span class="org-string">"1"</span>
            <span class="org-keyword">else</span>:
                <span class="org-variable-name">syndrome</span> <span class="org-operator">+=</span> <span class="org-string">"0"</span>

        <span class="org-variable-name">syndromes</span>[err.to_label()] <span class="org-operator">=</span> syndrome

    <span class="org-keyword">return</span> syndromes
</pre>
</div>

<p>
This function can now be used to compute the syndromes of the five qubit code:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org25ab3a2"><span class="org-variable-name">g1</span> <span class="org-operator">=</span> Pauli(<span class="org-string">"XZZXI"</span>)
<span class="org-variable-name">g2</span> <span class="org-operator">=</span> Pauli(<span class="org-string">"IXZZX"</span>)
<span class="org-variable-name">g3</span> <span class="org-operator">=</span> Pauli(<span class="org-string">"XIXZZ"</span>)
<span class="org-variable-name">g4</span> <span class="org-operator">=</span> Pauli(<span class="org-string">"ZXIXZ"</span>)
<span class="org-variable-name">generators</span> <span class="org-operator">=</span> [g1, g2, g3, g4]

<span class="org-variable-name">syndromes</span> <span class="org-operator">=</span> compute_syndromes(generators)
<span class="org-keyword">assert</span> <span class="org-builtin">len</span>(syndromes) <span class="org-operator">==</span> 15, <span class="org-string">"For each of 5 positions and 3 Paulis one syndrome."</span>
<span class="org-keyword">assert</span> <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(syndromes.values())) <span class="org-operator">==</span> 15, <span class="org-string">"No duplicate syndromes!"</span>


<span class="org-keyword">for</span> error, syndrome <span class="org-keyword">in</span> <span class="org-builtin">sorted</span>(syndromes.items(), key<span class="org-operator">=</span>(<span class="org-keyword">lambda</span> x: x[1])):
    <span class="org-builtin">print</span>(f<span class="org-string">"</span>{syndrome}<span class="org-string">: </span>{error}<span class="org-string">"</span>)
</pre>
</div>

<pre class="example" id="org3163725">
0001: XIIII
0010: IIZII
0011: IIIIX
0100: IIIIZ
0101: IZIII
0110: IIIXI
0111: IIIIY
1000: IXIII
1001: IIIZI
1010: ZIIII
1011: YIIII
1100: IIXII
1101: IYIII
1110: IIYII
1111: IIIYI
</pre>
</div>
</div>
</div>

<div id="outline-container-org1c174f9" class="outline-3">
<h3 id="org1c174f9">Exercise 10.50</h3>
<div class="outline-text-3" id="text-org1c174f9">
<p>
Show that the five qubit code saturates the quantum Hamming bound, that is, it satisfies
the inequality of (10.51) with equality.
</p>
</div>

<div id="outline-container-org5c89437" class="outline-4">
<h4 id="org5c89437">Solution</h4>
<div class="outline-text-4" id="text-org5c89437">
<p>
The quantum hamming bound is
</p>

<p>
\[
  \sum_{j=0}^t \binom{n}{j} 3^j \leq 2^{n-k} .
\]
</p>

<p>
For the five qubit code we have \(n=5\), \(k=1\), and \(t=1\). Plugging this in yields:
</p>

<p>
\[
  1 + \binom{5}{1} 3^1 \leq 2^{5-1} ,
\]
</p>

<p>
which is clearly satisfied with equality.
</p>

<p>
Recall that the quantum hamming bound only applies to non-degenerate codes. The five qubit
is acutally non-degenerate (we have seen in the <a href="#exercise-10.49-solution">solution</a> of exercise 10.49 that the
syndromes of all base errors are different). For \(k=t=1\) the hamming bound says:
</p>

<p>
\[
  3n + 1 \leq 2^{n-1} ,
\]
</p>

<p>
which has \(n=5\) as the smallest solution. Hence this exercise shows that the hamming bound
is actually tight for \(k=t=1\) in the sense that there really is a non-degenerate code with
just \(n=5\) qubits.
</p>
</div>
</div>
</div>

<div id="outline-container-org00c7292" class="outline-3">
<h3 id="org00c7292">Exercise 10.51</h3>
<div class="outline-text-3" id="text-org00c7292">
<p>
Verify that the check matrix defined in (10.106) corresponds to the stabilizer of the CSS
code \(\mathrm{CSS}(C_1,C_2)\), and use Theorem 10.8 to show that arbitrary errors on up to
\(t\) qubits may be corrected by this code.
</p>
</div>

<div id="outline-container-org0b052dc" class="outline-4">
<h4 id="org0b052dc">Proof</h4>
<div class="outline-text-4" id="text-org0b052dc">
<p>
In the course of solving <a href="#exercise-10.32-solution">exercise 10.32</a> we have already seen that the check matrix looks
like described. It remains to show that if \(C_1\) and \(C_2^\top\) correct \(t\) (classical)
errors then the CSS code corrects \(t\) quantum errors.
</p>

<p>
Let \(H_1\) be the parity check matrix of \(C_1\) and let \(H_2\) be the parity check matrix of
\(C_2^\top\).
</p>

<p>
Let \(E,F\) be two phase-less Pauli errors (products of Pauli matrices, without additional
factor \(\pm1,\pm\ii\)) with weight less or equal to \(d\) such that \(d\leq\?t\). According to
theorem 10.8 we have to show that \(E^\dagger\?F\notin\?N(S)\backslash\?S\). Without loss of
generality we may assume that \(E\neq\?F\). We will even show that
\(E^\dagger\?F\notin\?N(S)\), in other words, the syndromes of \(E\) and \(F\) are different
(implying that a CSS code is non-degenerate, see the <a href="#org0b8919b">lemma</a> in my solution of exercise
10.49).
</p>

<p>
Let us abbreviate \(N=\bigotimes_{j=1}^nN_j=E^\dagger\?F\) and define \((x,z)\in\BB^{2n}\) to
be its encoding such that \((x_j,z_j)\) tells whether \(N_j\) is \(I\), \(X\), \(Y\), or \(Z\), in the
same way as the check matrix \(G\) encodes this information. Recall that \(Z(S)=N(S)\)
(<a href="#exercise-10.44">exercise 10.44</a>). Hence \(N\notin\?N(S)\) is the same as \(Ng_j=-g_jN\) for at least one
\(j\). On the other hand the latter is <a href="#orgfb3c93b">equivalent</a> to \(G_j\Lambda(x,z)^T=1\) (for some \(j\)),
where \(G_j\) is just the \(j\)​th row of \(G\) which encodes \(g_j\). This in turn is equivalent
to: \(H_1x\neq0\) or \(H_2z\neq0\).
</p>

<p>
On the other hand, since \(N\) has weight at most \(2d\) the weights of \(x\) and \(z\) are at
most \(2d\) too. Moreover at least one of \(x\) and \(z\) has to be non-zero (because we assumed
\(E\neq\?F\), or more precisely \(E^\dagger\?F\) not being a scalar multiple of the
identity). By assumption \(C_1\) and \(C_2^\top\) both correct \(t\) errors and \(2d\?<\?2t+1\),
hence \(H_1x\neq0\) or \(H_2z\neq0\) as desired. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgeac7242" class="outline-3">
<h3 id="orgeac7242">Exercise 10.52</h3>
<div class="outline-text-3" id="text-orgeac7242">
<p>
Verify by direct operation on the codewords that the operators of (10.107) act
appropriately, as logical \(Z\) and \(X\).
</p>
</div>

<div id="outline-container-orge0c752a" class="outline-4">
<h4 id="orge0c752a">Solution</h4>
<div class="outline-text-4" id="text-orge0c752a">
<p>
A characteristic of the code word \(\ket{0_L}\) is that each of its base-kets contains an
<i>even</i> number of \(1\). This implies \(\bar{Z}\ket{0_L}=\ket{0_L}\). Similarly \(\ket{1_L}\) has
only base kets with an odd number of ones, hence \(\bar{Z}\ket{1_L}=-\ket{1_L}\).
</p>

<p>
Moreover \(\ket{1_L}\) can be constructed from \(\ket{0_L}\) by just replacing each \(1\) by a
\(0\) and vice versa. But this is just what \(\bar{X}\) does. Hence
\(\bar{X}\ket{0_L}=\ket{1_L}\) and \(\bar{X}\ket{1_L}=\ket{0_L}\).
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.53" class="outline-3">
<h3 id="exercise-10.53">Exercise 10.53</h3>
<div class="outline-text-3" id="text-exercise-10.53">
<p>
Prove that the encoded \(Z\) operators are independent of one another.
</p>

<p>
<a id="orgd55dd7a"></a>
</p>
<dl class="org-dl">
<dt>Remark</dt><dd><ul class="org-ul">
<li>I think the wording is sub-optimal. Independence is a property of a subset of a
group. The above formulation <i>could</i> be interpreted as: every set of two \(Z\) operators
are independent. Why does this matter? To see the difference consider
\(\{Z_1Z_2,Z_1Z_3,Z_2Z_3\}\). The elements are pairwise independent, but
\(Z_1Z_3=(Z_1Z_2)(Z_2Z_3)\), hence they are not independent. The same phenomen happens
in other contexts where the term <i>independent</i> is used e.g.:
<ul class="org-ul">
<li>Independence of vectors in a vector space.</li>
<li>Inpependence of random variables in the sense of probability theory.</li>
</ul></li>
<li>In the light of the above remark I think it makes even sense to prove that the set
\(M=\{g_1,\ldots,g_{n-k},\bar{Z}_1,\ldots,\bar{Z}_k\}\) is independent. This is a more
satisfying exercise.</li>
</ul></dd>
</dl>
</div>

<div id="outline-container-org0463092" class="outline-4">
<h4 id="org0463092">Proof</h4>
<div class="outline-text-4" id="text-org0463092">
<p>
As suggested by the remark let us prove that
</p>

<p>
\[ M=\{g_1,\ldots,g_{n-k},\bar{Z}_1,\ldots,\bar{Z}_k\} \]
</p>

<p>
is independent. By assumptions (made in the main text) the elements of \(M\) commute and
\(-I\) is not part of the generated group \(S_Z=\langle\?M\rangle\). <a href="#org89f44cf">Hence</a>, the homomorphism
(of groups) \(r:S_Z\to\BB^{2n}\) is injective. This implies that independence is an
invariant property, that is:
</p>

<p>
\[
  M \text{ independent} \quad \Longleftrightarrow \quad r(M) := \{r(g) \;|\; g\in M\} \text{ independent.}
\]
</p>

<p>
Moreover <i>independence</i> in \(\BB^{2n}\) as a group is the same as <i>independence</i> in
\(\BB^{2n}\) as a vector space over \(\BB\). Hence, in order prove independence we can use
<i>linear</i> algebra methods. Let \(G\) be the check matrix (where the \(j\)​th row is \(r(g_j)\)) in
standard form and let
</p>

<p>
\[
  G_z = \begin{bmatrix} 0 & 0 & 0 & A_2^T & 0 & I \end{bmatrix} ,
\]
</p>

<p>
be the "check matrix" for the Z operators as given by the book (which actually defines the
Z operators by the isomorphism \(r\)). Note that the \(I\in\BB^{k\times\?k}\) in the sixth
block is responsible for \(G_z\) having (full) rank \(k\). In the same way the
\(I\in\BB^{r\times\?r}\) (first <i>block-column</i>) and \(I\in\BB^{(n-k-r)\times\?(n-k-r)}\)
(fifth <i>block-column</i>) are responsible for \(G\) having (full) rank \(n-k\). Hence
</p>

<p>
\[
  \?\begin{bmatrix} G \\ G_z \end{bmatrix}
\]
</p>

<p>
as full rank \(n-k=(n-k-r)+r\) because the three mentioned identities all live in different
<i>block-columns</i>. This shows the independece of \(r(M)\) and hence of \(M\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc5d2f05" class="outline-3">
<h3 id="orgc5d2f05">Exercise 10.54</h3>
<div class="outline-text-3" id="text-orgc5d2f05">
<p>
Prove that with the check matrix for the encoded \(X\) operators defined as above, the
encoded \(X\) operators are independent of one another and of the generators, commute with
the generators of the stabilizer, with each other, and \(\bar{X}_j\) commutes with all the
\(\bar{Z}_k\) except \(\bar{Z}_j\), with which it anti-commutes.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Similar remarks as in <a href="#exercise-10.53">exercise 10.53</a> apply here too.</dd>
</dl>
</div>

<div id="outline-container-org4725a59" class="outline-4">
<h4 id="org4725a59">Proof</h4>
<div class="outline-text-4" id="text-org4725a59">
<p>
Recall that within the linear algebra framework we have
</p>

<p>
\[
  \bar{X} = \left[ \begin{array}{ccc|ccc} 0 & E^T & I & C^T & 0 & 0 \end{array} \right] ,
\]
</p>

<p>
where each line corresponds to a \(\bar{X}_j\) according to the homomorphism
\(r\). From
</p>

<p>
\[
  G \Lambda \bar{X}^T = \begin{bmatrix} IC + CI \\ IE + EI \end{bmatrix} = 0 \in \BB^{(n-k)\otimes k} .
\]
</p>

<p>
we <a href="#orgfb3c93b">deduce</a> that all \(g_i\) commute with all \(\bar{X}_j\). That all \(\bar{X}_j\) commute with
each other is obvious from the structure of its matrix representation.
</p>

<p>
Independence of the set of generators and X operators (as a single set) <a href="#org2e38d91">follows</a> from
linear independence of their linear algebra representation. That the latter is true
follows from looking where the identity matrices are because those are responsible for
making \(G\) and \(\bar{X}\) into full-row-rank matrices. For the former we have identities in
columns 1 and 5, for the latter we have it at column 3.
</p>

<p>
Finally we have
</p>

<p>
\[
  \bar{Z} \Lambda \bar{X}^T = I\cdot I = I \in \BB^{k\times k} ,
\]
</p>

<p>
which precisely means that \(\bar{Z}_i\) and \(\bar{X}_j\) commute iff \(i\neq\?j\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org6d146e0" class="outline-3">
<h3 id="org6d146e0">Exercise 10.55</h3>
<div class="outline-text-3" id="text-org6d146e0">
<p>
Find the \(\bar{X}\) operator for the standard form of the Steane code.
</p>
</div>

<div id="outline-container-org9e6fd63" class="outline-4">
<h4 id="org9e6fd63">Solution</h4>
<div class="outline-text-4" id="text-org9e6fd63">
<p>
This is just plugging stuff in. In the linear algebra framework we have:
</p>

<p>
\[
  \bar{X} = \left[ \begin{array}{ccccccc|ccccccc}
  0 & 0 & 0 & 1 & 1 & 0 & 1 &
  0 & 0 & 0 & 0 & 0 & 0 & 0 \end{array} \right] \in \BB^{1\times14} .
\]
</p>

<p>
This corresponds to a single logical X operator which equals \(X_4X_5X_7\). As a bonus: in
the same way we get \(Z_1Z_2Z_7\) as the logical Z operator.
</p>
</div>
</div>
</div>

<div id="outline-container-org32fd85a" class="outline-3">
<h3 id="org32fd85a">Exercise 10.56</h3>
<div class="outline-text-3" id="text-org32fd85a">
<p>
Show that replacing an encoded \(X\) or \(Z\) operator by \(g\) times that operator, where \(g\)
is an element of the stabilizer, does not change the action of the operator on the code.
</p>
</div>

<div id="outline-container-org527df3f" class="outline-4">
<h4 id="org527df3f">Proof</h4>
<div class="outline-text-4" id="text-org527df3f">
<p>
Let \(N\) be one of the logical X or Z operators. Let \(g\in\?S\) and \(\ket{\psi}\in\?C\) an
element of the code. The generators let the code invariant, hence
\(g\ket{\psi}=\ket{\psi}\). On the other hand \(g\) commutes with \(N\) by construction of the
logical Pauli operators. Hence
</p>

<p>
\[
  gN \ket{\psi} = Ng \ket{\psi} = N \ket{\psi} ,
\]
</p>

<p>
which is precisely the claim. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.57" class="outline-3">
<h3 id="exercise-10.57">Exercise 10.57</h3>
<div class="outline-text-3" id="text-exercise-10.57">
<p>
Give the check matrices for the five and nine qubit codes in standard form.
</p>
</div>

<div id="outline-container-orge199463" class="outline-4">
<h4 id="orge199463">Solution</h4>
<div class="outline-text-4" id="text-orge199463">
<p>
Let us use the code prepared in one of the <a href="#chapter-10-utility-code">introductory sections</a> to this site. First
consider the 5 qubit code.
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org639b7f3"><span class="org-variable-name">cm</span> <span class="org-operator">=</span> generators_to_check_matrix(generators_5qubit_code_repr())
transform_check_matrix(cm, [
    <span class="org-comment-delimiter"># </span><span class="org-comment">n = 5, k = 1</span>
    [<span class="org-string">"add row"</span>, 0, 2],
    [<span class="org-string">"add row"</span>, 1, 3],
    [<span class="org-string">"add row"</span>, 3, 2],
    [<span class="org-string">"add row"</span>, 3, 0],
    <span class="org-comment-delimiter"># </span><span class="org-comment">Now we know r = 4, Hence the middle part is trivial!</span>
])
</pre>
</div>

<pre class="example">
[1 0 0 0 1 1 1 0 1 1]
[0 1 0 0 1 0 0 1 1 0]
[0 0 1 0 1 1 1 0 0 0]
[0 0 0 1 1 1 0 1 1 1]
</pre>


<p>
Hence the 5 qubit code is an example where the the place for the matrix \(A_1\) completely
vanishes (\(n-k-r=0\)). Next consider Shor's nine qubit code:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgaa91c26"><span class="org-variable-name">cm</span> <span class="org-operator">=</span> generators_to_check_matrix(generators_shor_code_repr())
transform_check_matrix(cm, [
    <span class="org-comment-delimiter"># </span><span class="org-comment">n = 9, k = 1, already see that r = 2</span>
    [<span class="org-string">"swap rows"</span>, 0, 6],
    [<span class="org-string">"swap rows"</span>, 1, 7],
    [<span class="org-string">"swap qubits"</span>, 1, 3],
    [<span class="org-string">"add row"</span>, 1, 0],
    <span class="org-comment-delimiter"># </span><span class="org-comment">X part is in standard form now. But by accident the Z part too!</span>
])
</pre>
</div>

<pre class="example">
[1 0 1 1 0 0 1 1 1 0 0 0 0 0 0 0 0 0]
[0 1 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1]
[0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0]
</pre>
</div>
</div>
</div>

<div id="outline-container-org1371cfc" class="outline-3">
<h3 id="org1371cfc">Exercise 10.58</h3>
<div class="outline-text-3" id="text-org1371cfc">
<p>
Verify that the circuits in Figures 10.13–10.15 work as described, and check the claimed
circuit equivalences.
</p>
</div>

<div id="outline-container-org3db6304" class="outline-4">
<h4 id="org3db6304">Solution</h4>
<div class="outline-text-4" id="text-org3db6304">
<p>
The action of of the circuit in Figure 10.13 is
</p>

\begin{align*}
  \ket{0,\psi} &\stackrel{H_1}{\mapsto} \frac{1}{\sqrt{2}} \left(\ket{0} + \ket{1}\right) \ket{\psi} \\
  &\stackrel{CM}{\mapsto}  \frac{1}{\sqrt{2}} \left(\ket{0}\ket{\psi} + \ket{1}M\ket{\psi} \right) \\
  &\stackrel{H_1}{\mapsto} \ket{0} Q_+\ket{\psi} + \ket{1} Q_-\ket{\psi} ,
\end{align*}

<p>
where \(Q_{\pm}=(I\pm\?M)/2\) are the projectors onto the eigenspaces of \(M\). This shows
that the circuits works as described (measures \(M\)).
</p>

<p>
The LHS in Figure 10.14 and 10.15 is just a special case (\(M=X\) or \(M=Z\)) of Figure
10.13. The RHS in each of Figure 10.14 and 10.15 follow from two simple properties:
</p>

<p>
\[
  \cz = H_2 \cx H_2
\]
</p>

<p>
on the one hand, and that for \(\cz\) the source and target play the same role (can be
swapped without changing the action of the gate).
</p>
</div>
</div>
</div>

<div id="outline-container-org9b28084" class="outline-3">
<h3 id="org9b28084">Exercise 10.59</h3>
<div class="outline-text-3" id="text-org9b28084">
<p>
Show that by using the identities of Figures 10.14 and 10.15, the syndrome circuit of
Figure 10.16 can be replaced with the circuit of Figure 10.17
</p>
</div>

<div id="outline-container-orgfaf7100" class="outline-4">
<h4 id="orgfaf7100">Solution</h4>
<div class="outline-text-4" id="text-orgfaf7100">
<p>
I do not know what to say more except that it is very easy to see. You just have to do
it. One thing to remark is maybe that the transformation behaves like a transposition of
matrices.
</p>
</div>
</div>
</div>

<div id="outline-container-org8f6b7a5" class="outline-3">
<h3 id="org8f6b7a5">Exercise 10.60</h3>
<div class="outline-text-3" id="text-org8f6b7a5">
<p>
Construct a syndrome measuring circuit analogous to that in Figure 10.16, but for the nine
and five qubit codes.
</p>
</div>

<div id="outline-container-org0db3c04" class="outline-4">
<h4 id="org0db3c04">Solution</h4>
<div class="outline-text-4" id="text-org0db3c04">
<p>
Using the utility code we can easily construct the circuits using qiskit.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">generators</span> <span class="org-operator">=</span> generators_5qubit_code()
<span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_syndrome_circuit(generators, with_barrier<span class="org-operator">=</span><span class="org-constant">False</span>)
qc.draw()
</pre>
</div>

<pre class="example" id="org3bbb6ae">
       ┌───┐                       ┌───┐
|0&gt;_0: ┤ H ├────────■──────────────┤ H ├─────────────────────────────────────────────
       ├───┤        │              └───┘            ┌───┐
|0&gt;_1: ┤ H ├────────┼────────────────■──────────────┤ H ├────────────────────────────
       ├───┤        │                │              └───┘            ┌───┐
|0&gt;_2: ┤ H ├────────┼────────────────┼────────────────■──────────────┤ H ├───────────
       ├───┤        │                │                │              └───┘      ┌───┐
|0&gt;_3: ┤ H ├────────┼────────────────┼────────────────┼────────────────■────────┤ H ├
       └───┘┌───────┴───────┐┌───────┴───────┐┌───────┴───────┐┌───────┴───────┐└───┘
  q_0: ─────┤0              ├┤0              ├┤0              ├┤0              ├─────
            │               ││               ││               ││               │
  q_1: ─────┤1              ├┤1              ├┤1              ├┤1              ├─────
            │               ││               ││               ││               │
  q_2: ─────┤2 Pauli(XZZXI) ├┤2 Pauli(IXZZX) ├┤2 Pauli(XIXZZ) ├┤2 Pauli(ZXIXZ) ├─────
            │               ││               ││               ││               │
  q_3: ─────┤3              ├┤3              ├┤3              ├┤3              ├─────
            │               ││               ││               ││               │
  q_4: ─────┤4              ├┤4              ├┤4              ├┤4              ├─────
            └───────────────┘└───────────────┘└───────────────┘└───────────────┘
</pre>

<p>
Alternatively one can decompose the controlled pauli matrices. Unfortunately this also decomposes \(Z=HXH\):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">generators</span> <span class="org-operator">=</span> generators_5qubit_code()
<span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_syndrome_circuit(generators, with_barrier<span class="org-operator">=</span><span class="org-constant">True</span>)
qc.decompose([<span class="org-string">"cpauli"</span>]).draw()
</pre>
</div>

<pre class="example" id="org40c7205">
       ┌───┐ ░                                ░                                ░                               »
|0&gt;_0: ┤ H ├─░───■────■─────────■────■────────░────────────────────────────────░───────────────────────────────»
       ├───┤ ░   │    │         │    │        ░                                ░                               »
|0&gt;_1: ┤ H ├─░───┼────┼─────────┼────┼────────░───■────■─────────■────■────────░───────────────────────────────»
       ├───┤ ░   │    │         │    │        ░   │    │         │    │        ░                               »
|0&gt;_2: ┤ H ├─░───┼────┼─────────┼────┼────────░───┼────┼─────────┼────┼────────░────────■─────────■────■───────»
       ├───┤ ░   │    │         │    │        ░   │    │         │    │        ░        │         │    │       »
|0&gt;_3: ┤ H ├─░───┼────┼─────────┼────┼────────░───┼────┼─────────┼────┼────────░────────┼─────────┼────┼───────»
       └───┘ ░   │    │         │    │        ░ ┌─┴─┐  │         │    │        ░ ┌───┐┌─┴─┐┌───┐  │    │       »
  q_0: ──────░───┼────┼─────────┼────┼────────░─┤ X ├──┼─────────┼────┼────────░─┤ H ├┤ X ├┤ H ├──┼────┼───────»
             ░ ┌─┴─┐  │         │    │        ░ ├───┤┌─┴─┐┌───┐  │    │        ░ ├───┤└───┘└───┘┌─┴─┐  │  ┌───┐»
  q_1: ──────░─┤ X ├──┼─────────┼────┼────────░─┤ H ├┤ X ├┤ H ├──┼────┼────────░─┤ H ├──────────┤ X ├──┼──┤ H ├»
             ░ ├───┤┌─┴─┐┌───┐  │    │        ░ ├───┤└───┘└───┘┌─┴─┐  │  ┌───┐ ░ └───┘          └───┘┌─┴─┐└───┘»
  q_2: ──────░─┤ H ├┤ X ├┤ H ├──┼────┼────────░─┤ H ├──────────┤ X ├──┼──┤ H ├─░─────────────────────┤ X ├─────»
             ░ ├───┤└───┘└───┘┌─┴─┐  │  ┌───┐ ░ └───┘          └───┘┌─┴─┐└───┘ ░                     └───┘     »
  q_3: ──────░─┤ H ├──────────┤ X ├──┼──┤ H ├─░─────────────────────┤ X ├──────░───────────────────────────────»
             ░ └───┘          └───┘┌─┴─┐└───┘ ░                     └───┘      ░                               »
  q_4: ──────░─────────────────────┤ X ├──────░────────────────────────────────░───────────────────────────────»
             ░                     └───┘      ░                                ░                               »
«             ░                                     ░ ┌───┐
«|0&gt;_0: ──────░─────────────────────────────────────░─┤ H ├
«             ░                                     ░ ├───┤
«|0&gt;_1: ──────░─────────────────────────────────────░─┤ H ├
«             ░                                     ░ ├───┤
«|0&gt;_2: ──■───░─────────────────────────────────────░─┤ H ├
«         │   ░                                     ░ ├───┤
«|0&gt;_3: ──┼───░────────■────■─────────■────■────────░─┤ H ├
«         │   ░ ┌───┐┌─┴─┐  │  ┌───┐  │    │        ░ └───┘
«  q_0: ──┼───░─┤ H ├┤ X ├──┼──┤ H ├──┼────┼────────░──────
«         │   ░ └───┘└───┘┌─┴─┐└───┘  │    │        ░
«  q_1: ──┼───░───────────┤ X ├───────┼────┼────────░──────
«         │   ░           └───┘       │    │        ░
«  q_2: ──┼───░───────────────────────┼────┼────────░──────
«         │   ░                     ┌─┴─┐  │        ░
«  q_3: ──┼───░─────────────────────┤ X ├──┼────────░──────
«       ┌─┴─┐ ░ ┌───┐               └───┘┌─┴─┐┌───┐ ░
«  q_4: ┤ X ├─░─┤ H ├────────────────────┤ X ├┤ H ├─░──────
«       └───┘ ░ └───┘                    └───┘└───┘ ░
</pre>

<p>
For the shor code I only print the compact representations:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">generators</span> <span class="org-operator">=</span> generators_shor_code()
<span class="org-variable-name">qc</span> <span class="org-operator">=</span> make_syndrome_circuit(generators, with_barrier<span class="org-operator">=</span><span class="org-constant">False</span>)
qc.draw()
</pre>
</div>

<pre class="example" id="orgd2f20a6">
       ┌───┐                             ┌───┐                                                  »
|0&gt;_0: ┤ H ├──────────■──────────────────┤ H ├──────────────────────────────────────────────────»
       ├───┤          │                  └───┘                ┌───┐                             »
|0&gt;_1: ┤ H ├──────────┼────────────────────■──────────────────┤ H ├─────────────────────────────»
       ├───┤          │                    │                  └───┘                ┌───┐        »
|0&gt;_2: ┤ H ├──────────┼────────────────────┼────────────────────■──────────────────┤ H ├────────»
       ├───┤          │                    │                    │                  └───┘        »
|0&gt;_3: ┤ H ├──────────┼────────────────────┼────────────────────┼────────────────────■──────────»
       ├───┤          │                    │                    │                    │          »
|0&gt;_4: ┤ H ├──────────┼────────────────────┼────────────────────┼────────────────────┼──────────»
       ├───┤          │                    │                    │                    │          »
|0&gt;_5: ┤ H ├──────────┼────────────────────┼────────────────────┼────────────────────┼──────────»
       ├───┤          │                    │                    │                    │          »
|0&gt;_6: ┤ H ├──────────┼────────────────────┼────────────────────┼────────────────────┼──────────»
       ├───┤          │                    │                    │                    │          »
|0&gt;_7: ┤ H ├──────────┼────────────────────┼────────────────────┼────────────────────┼──────────»
       └───┘┌─────────┴─────────┐┌─────────┴─────────┐┌─────────┴─────────┐┌─────────┴─────────┐»
  q_0: ─────┤0                  ├┤0                  ├┤0                  ├┤0                  ├»
            │                   ││                   ││                   ││                   │»
  q_1: ─────┤1                  ├┤1                  ├┤1                  ├┤1                  ├»
            │                   ││                   ││                   ││                   │»
  q_2: ─────┤2                  ├┤2                  ├┤2                  ├┤2                  ├»
            │                   ││                   ││                   ││                   │»
  q_3: ─────┤3                  ├┤3                  ├┤3                  ├┤3                  ├»
            │                   ││                   ││                   ││                   │»
  q_4: ─────┤4 Pauli(ZZIIIIIII) ├┤4 Pauli(IZZIIIIII) ├┤4 Pauli(IIIZZIIII) ├┤4 Pauli(IIIIZZIII) ├»
            │                   ││                   ││                   ││                   │»
  q_5: ─────┤5                  ├┤5                  ├┤5                  ├┤5                  ├»
            │                   ││                   ││                   ││                   │»
  q_6: ─────┤6                  ├┤6                  ├┤6                  ├┤6                  ├»
            │                   ││                   ││                   ││                   │»
  q_7: ─────┤7                  ├┤7                  ├┤7                  ├┤7                  ├»
            │                   ││                   ││                   ││                   │»
  q_8: ─────┤8                  ├┤8                  ├┤8                  ├┤8                  ├»
            └───────────────────┘└───────────────────┘└───────────────────┘└───────────────────┘»
«
«|0&gt;_0: ─────────────────────────────────────────────────────────────────────────────────────────
«
«|0&gt;_1: ─────────────────────────────────────────────────────────────────────────────────────────
«
«|0&gt;_2: ─────────────────────────────────────────────────────────────────────────────────────────
«               ┌───┐
«|0&gt;_3: ────────┤ H ├────────────────────────────────────────────────────────────────────────────
«               └───┘                ┌───┐
«|0&gt;_4: ──────────■──────────────────┤ H ├───────────────────────────────────────────────────────
«                 │                  └───┘                ┌───┐
«|0&gt;_5: ──────────┼────────────────────■──────────────────┤ H ├──────────────────────────────────
«                 │                    │                  └───┘                ┌───┐
«|0&gt;_6: ──────────┼────────────────────┼────────────────────■──────────────────┤ H ├─────────────
«                 │                    │                    │                  └───┘        ┌───┐
«|0&gt;_7: ──────────┼────────────────────┼────────────────────┼────────────────────■──────────┤ H ├
«       ┌─────────┴─────────┐┌─────────┴─────────┐┌─────────┴─────────┐┌─────────┴─────────┐└───┘
«  q_0: ┤0                  ├┤0                  ├┤0                  ├┤0                  ├─────
«       │                   ││                   ││                   ││                   │
«  q_1: ┤1                  ├┤1                  ├┤1                  ├┤1                  ├─────
«       │                   ││                   ││                   ││                   │
«  q_2: ┤2                  ├┤2                  ├┤2                  ├┤2                  ├─────
«       │                   ││                   ││                   ││                   │
«  q_3: ┤3                  ├┤3                  ├┤3                  ├┤3                  ├─────
«       │                   ││                   ││                   ││                   │
«  q_4: ┤4 Pauli(IIIIIIZZI) ├┤4 Pauli(IIIIIIIZZ) ├┤4 Pauli(XXXXXXIII) ├┤4 Pauli(IIIXXXXXX) ├─────
«       │                   ││                   ││                   ││                   │
«  q_5: ┤5                  ├┤5                  ├┤5                  ├┤5                  ├─────
«       │                   ││                   ││                   ││                   │
«  q_6: ┤6                  ├┤6                  ├┤6                  ├┤6                  ├─────
«       │                   ││                   ││                   ││                   │
«  q_7: ┤7                  ├┤7                  ├┤7                  ├┤7                  ├─────
«       │                   ││                   ││                   ││                   │
«  q_8: ┤8                  ├┤8                  ├┤8                  ├┤8                  ├─────
«       └───────────────────┘└───────────────────┘└───────────────────┘└───────────────────┘
</pre>
</div>
</div>
</div>

<div id="outline-container-org537dc1d" class="outline-3">
<h3 id="org537dc1d">Exercise 10.61</h3>
<div class="outline-text-3" id="text-org537dc1d">
<p>
Describe explicit recovery operations \(E_j^\dagger\) corresponding to the different
possible error syndromes that may be measured using the circuit in Figure 10.16.
</p>
</div>

<div id="outline-container-exercise-10.61-solution" class="outline-4">
<h4 id="exercise-10.61-solution">Solution</h4>
<div class="outline-text-4" id="text-exercise-10.61-solution">
<p>
This can easily be done using the code we have produced for previous exercises.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">generators</span> <span class="org-operator">=</span> generators_steane_code_standard()
<span class="org-variable-name">steane_syndromes</span> <span class="org-operator">=</span> compute_syndromes(generators)

<span class="org-keyword">assert</span> <span class="org-builtin">len</span>(steane_syndromes) <span class="org-operator">==</span> 3<span class="org-operator">*</span>7, <span class="org-string">"Steane code is non-degenerate (1)"</span>
<span class="org-keyword">assert</span> <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(steane_syndromes.values())) <span class="org-operator">==</span> 3<span class="org-operator">*</span>7, <span class="org-string">"Steane code is non-degenerate (2)"</span>

<span class="org-keyword">def</span> <span class="org-function-name">shorten</span>(pauli_str: <span class="org-builtin">str</span>):
    <span class="org-variable-name">ret</span> <span class="org-operator">=</span> <span class="org-constant">None</span>

    <span class="org-keyword">if</span> (i :<span class="org-operator">=</span> pauli_str.find(<span class="org-string">'Z'</span>)) <span class="org-operator">!=</span> <span class="org-operator">-</span>1:
        <span class="org-variable-name">ret</span> <span class="org-operator">=</span> f<span class="org-string">"Z_</span>{i<span class="org-operator">+</span>1}<span class="org-string">"</span>
    <span class="org-keyword">elif</span> (i :<span class="org-operator">=</span> pauli_str.find(<span class="org-string">'X'</span>)) <span class="org-operator">!=</span> <span class="org-operator">-</span>1:
        <span class="org-variable-name">ret</span> <span class="org-operator">=</span> f<span class="org-string">"X_</span>{i<span class="org-operator">+</span>1}<span class="org-string">"</span>
    <span class="org-keyword">elif</span> (i :<span class="org-operator">=</span> pauli_str.find(<span class="org-string">'Y'</span>)) <span class="org-operator">!=</span> <span class="org-operator">-</span>1:
        <span class="org-variable-name">ret</span> <span class="org-operator">=</span> f<span class="org-string">"Y_</span>{i<span class="org-operator">+</span>1}<span class="org-string">"</span>

    <span class="org-keyword">assert</span> ret <span class="org-operator">!=</span> <span class="org-constant">None</span>, <span class="org-string">"Invalid input"</span>
    <span class="org-variable-name">s</span> <span class="org-operator">=</span> pauli_str[:i] <span class="org-operator">+</span> <span class="org-string">"I"</span> <span class="org-operator">+</span> pauli_str[i<span class="org-operator">+</span>1:]
    <span class="org-keyword">assert</span> s <span class="org-operator">==</span> <span class="org-string">"I"</span> <span class="org-operator">*</span> <span class="org-builtin">len</span>(pauli_str), <span class="org-string">"Invalid input"</span>

    <span class="org-keyword">return</span> ret

<span class="org-comment-delimiter"># </span><span class="org-comment">This prints the syndromes and their error E (note: E=E.H)</span>
<span class="org-keyword">for</span> error, syndrome <span class="org-keyword">in</span> <span class="org-builtin">sorted</span>(steane_syndromes.items(), key<span class="org-operator">=</span>(<span class="org-keyword">lambda</span> x: x[1])):
    <span class="org-builtin">print</span>(f<span class="org-string">"</span>{syndrome}<span class="org-string">: </span>{error}<span class="org-string">, </span>{shorten(error)}<span class="org-string">"</span>)
</pre>
</div>

<pre class="example" id="org4bfa416">
000001: IIIIIXI, X_6
000010: IIIIXII, X_5
000011: IXIIIII, X_2
000100: IIIXIII, X_4
000101: XIIIIII, X_1
000110: IIIIIIX, X_7
000111: IIXIIII, X_3
001000: IIZIIII, Z_3
001111: IIYIIII, Y_3
010000: IZIIIII, Z_2
010011: IYIIIII, Y_2
011000: IIIZIII, Z_4
011100: IIIYIII, Y_4
100000: ZIIIIII, Z_1
100101: YIIIIII, Y_1
101000: IIIIZII, Z_5
101010: IIIIYII, Y_5
110000: IIIIIIZ, Z_7
110110: IIIIIIY, Y_7
111000: IIIIIZI, Z_6
111001: IIIIIYI, Y_6
</pre>
</div>
</div>
</div>

<div id="outline-container-org03eacbc" class="outline-3">
<h3 id="org03eacbc">Exercise 10.62</h3>
<div class="outline-text-3" id="text-org03eacbc">
<p>
Show by explicit construction of generators for the stabilizer that concatenating an
\([n_1,1]\) stabilizer code with an \([n_2,1]\) stabilizer code gives an \([n_1n_2,1]\)
stabilizer code.
</p>
</div>

<div id="outline-container-orgf00578a" class="outline-4">
<h4 id="orgf00578a">Solution</h4>
<div class="outline-text-4" id="text-orgf00578a">
<p>
Let us assume that we first encode everything with \(C_1\) and then, on top of this, we
encode every of the resulting \(n_1\) qubits with \(C_2\). Clearly this leads to a space with
\(n_1n_2\) dimensions which we use to encode a single logical qubit.
</p>

<p>
What are the generators of the concatenated code \(C_2\circ\?C_1\)? Therefore let
\((g^{(1)}_i)_{i\in1..n_1}\) and \((g^{(2)}_i)_{i\in1..n_2}\) be the generators of \(C_1\) and
\(C_2\) (individually). The stabilizer of \(C_2\circ\?C_1\) has two responsibilities
</p>

<ol class="org-ol">
<li>Stabilize each of the \(n_2\) copies of \(C_1\) (one for each qubit of \(C_2\)).</li>
<li>On top of that, stabilize \(C_2\) relative to \(C_1\).</li>
</ol>

<p>
For the first responsibility we use the following \(n_2(n_1-1)\) generators:
</p>

<p>
\[
  \tilde{g}_{l,k} = I \ldots \otimes g_k^{(1)} \otimes \ldots I ,
\]
</p>

<p>
for \(k=1..n_1\) and \(l=1..n_2\) and the factor \(g_k^{(1)}\) sits at position \(l\) in the
tensor product. For the second set of stabilizer generators let us first write
</p>

<p>
\[
  g_k^{(2)} = \bigotimes_{j=1}^{n_2} N_{k,j} ,
\]
</p>

<p>
where \(N_{k,j}\in\{I,X,Y,Z\}\). Moreover let \(\bar{N}_{kj}\) be the "lifting" of \(N_{kj}\) to
\(C_1\). Then the second set of stabilizer generators (containing \(n_2-1\) elements) are
</p>

<p>
\[
  \bar{g}_k = \bigotimes_{j=1}^{n_2} \bar{N}_{k,j} ,
\]
</p>

<p>
where \(k=1..n_2\). Note that by construction of the lifted operators the \(\bar{N}_{kj}\)
commute with all generators from the first set. Overall we found the \(n_1n_2-1\) generators
of \(C_2\circ\?C_1\)!
</p>
</div>
</div>
</div>

<div id="outline-container-org0414a45" class="outline-3">
<h3 id="org0414a45">Exercise 10.63</h3>
<div class="outline-text-3" id="text-org0414a45">
<p>
Suppose \(U\) is any unitary operation mapping the Steane code into itself, and such that
\(U\bar{Z}U^\dagger=\bar{X}\) and \(U\bar{X}U^\dagger=\bar{Z}\). Prove that up to a global
phase the action of \(U\) on the encoded states \(\ket{0_L}\) and \(\ket{1_L}\) is
\(\ket{0_L}\mapsto(\ket{0_L}+\ket{1_L})/\sqrt{2}\) and
\(\ket{1_L}\mapsto(\ket{0_L}-\ket{1_L})/\sqrt{2}\).
</p>
</div>

<div id="outline-container-org198cf11" class="outline-4">
<h4 id="org198cf11">Proof</h4>
<div class="outline-text-4" id="text-org198cf11">
<p>
Let \(\ket{\pm_L}=(\ket{0_L}\pm\ket{1_L})/\sqrt(2)\) be the eigenstates of \(\bar{X}\). From
\(\bar{X}\ket{+_L}=\ket{+_L}\) and \(\bar{X}=U\bar{Z}U^\dagger\) we obtain
</p>

<p>
\[
  U^\dagger \ket{+_L} = \bar{Z} U^\dagger \ket{+_L} .
\]
</p>

<p>
Hence \(U^\dagger\ket{+_L}\) is a \(+1\) eigenstate of \(\bar{Z}\). Hence
</p>

<p>
\[ U^\dagger\ket{+_L} = e^{\ii\varphi_{0}} \ket{0_L} . \]
</p>

<p>
In the same way (using \(\bar{X}\ket{-_L}=-\ket{-_L}\) and again
\(\bar{X}=U\bar{Z}U^\dagger\)) we obtain
</p>

<p>
\[ U^\dagger\ket{-_L} = e^{\ii\varphi_{1}} \ket{1_L} . \]
</p>

<p>
It remains to show that \(\varphi_0=\varphi_1=:\varphi\). Note that it is not possible to
show that \(\varphi=0\) (simply because it is wrong in general).
</p>

<p>
From \(\bar{Z}\ket{-_L}=\ket{+_L}\) and \(U\ket{X}U^\dagger=\bar{Z}\) we deduce
</p>

<p>
\[
  \ket{-_L} = U\bar{X}U^\dagger \ket{+_L} = U\bar{X} e^{\ii\varphi_0} \ket{0_L}
  = U e^{\ii\varphi_0} \ket{1_L} = e^{\ii(\varphi_0-\varphi_1)} \ket{-_L} .
\]
</p>

<p>
Hence \(\varphi_0=\varphi_1\) as desired. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdbd2d68" class="outline-3">
<h3 id="orgdbd2d68">Exercise 10.64 (Back propagation of errors)</h3>
<div class="outline-text-3" id="text-orgdbd2d68">
<p>
It is clear that an \(X\) error on the control of a <code>CNOT</code> gate propagates to the target
qubit. In addition, it turns out that a \(Z\) error on the target propagates back to the
control! Show this using the stabilizer formalism, and also directly using quantum circuit
identities. You may find Exercise 4.20 on page 179 useful.
</p>
</div>

<div id="outline-container-org3a78c40" class="outline-4">
<h4 id="org3a78c40">Solution</h4>
<div class="outline-text-4" id="text-org3a78c40">
<p>
As mentioned we already know the following propagation rule
\(\cx_{12}X_1=X_1X_2\cx_{12}\). Moreover, from <a href="chapter_4.html#exercise-4-20">exercise 4.20</a> we know that
</p>

<p>
\[
  \cx_{21} = H_1H_2 \cx_{12} H_1H_2 .
\]
</p>

<p>
Hence
</p>

\begin{align*}
  \cx_{12} Z_2 &= H_1H_2 \cx_{21} H_1H_2 Z_2 \\
  &= H_1H_2 \cx_{21} X_2 H_1H_2 \\
  &= H_1H_2 X_1X_2 \cx_{21} H_1H_2 \\
  &= Z_1Z_2 H_1H_2 \cx_{21} H_1H_2 \\
  &= Z_1Z_2 \cx_{12} .
\end{align*}

<p>
Hence a \(Z\) error at the control of \(\cx\) progagates as two \(Z\), one at control and one at
the target.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.65" class="outline-3">
<h3 id="exercise-10.65">Exercise 10.65</h3>
<div class="outline-text-3" id="text-exercise-10.65">
<p>
An unknown qubit in the state \(\ket{\psi}\) can be swapped with a second qubit which is
prepared in the state \(\ket{0}\) using only two <code>CNOT</code> gates using the circuit
</p>

<pre class="example">
            ┌───┐
  |0&gt;: ──■──┤ X ├ |psi&gt;
       ┌─┴─┐└─┬─┘
|psi&gt;: ┤ X ├──■── |0&gt;
       └───┘
</pre>



<p>
Show that the two circuits below, which use only a single <code>CNOT</code> gate, with measurement
and a classically controlled single qubit operation, also accomplish the same task:
</p>

<pre class="example">
       ┌───┐         ┌───┐
  |0&gt;: ┤ X ├─────────┤ Z ├ |psi&gt;
       └─┬─┘┌───┐┌─┐ └─╥─┘
|psi&gt;: ──■──┤ H ├┤M├───║──
            └───┘└╥┘   ║
  c: 1/═══════════╩════╩══
                  0
</pre>


<pre class="example">
       ┌───┐         ┌───┐
  |0&gt;: ┤ H ├──■──────┤ X ├ |psi&gt;
       └───┘┌─┴─┐┌─┐ └─╥─┘
|psi&gt;: ─────┤ X ├┤M├───║──
            └───┘└╥┘   ║
  c: 1/═══════════╩════╩═
                  0
</pre>
</div>

<div id="outline-container-orge593fe3" class="outline-4">
<h4 id="orge593fe3">Solution</h4>
<div class="outline-text-4" id="text-orge593fe3">
<p>
Let \(\ket{\psi}=a\ket{0}+\ket{1}\). Let us track the action of the first circuit:
</p>

\begin{align*}
  \ket{0}\ket{\psi} &\stackrel{\cx_{12}}{\mapsto} a\ket{00} + b\ket{11} \\
  &\stackrel{H_2}{\mapsto} \frac{1}{\sqrt{2}} \left(a\ket{00} + a\ket{01} + b\ket{10} - b\ket{11} \right) \\
  &= \frac{1}{\sqrt{2}} \left[
    (a\ket{0} + b\ket{1})\ket{0} +
    (a\ket{0} - b\ket{1})\ket{1}
  \right]
\end{align*}

<p>
Hence measuring \(0\) or \(1\) occurs with probability 50% (which is not important but nice to
know) and after measuring \(0\) the state in the first wire is already \(\ket{\psi}\). If \(1\)
is measured only a \(Z\) is needed to transform the state into \(\ket{\psi}\).
</p>

<p>
For the second circuit we proceed analogously:
</p>

\begin{align*}
  \ket{0}\ket{\psi} &\stackrel{H_1}{\mapsto} \frac{1}{\sqrt{2}}
    (a\ket{00} + b\ket{01} + a\ket{10} + b\ket{11}) \\
  &\stackrel{\cx_{12}}{\mapsto} \frac{1}{\sqrt{2}}
    (a\ket{00} + b\ket{01} + a\ket{11} + b\ket{10}) \\
  &= \frac{1}{\sqrt{2}} \left[
    (a\ket{0} + b\ket{1}) \ket{0} +
    (a\ket{1} + b\ket{0}) \ket{1}
  \right]
\end{align*}

<p>
After measuring \(0\) the state in the first wire is already \(\ket{\psi}\). If \(1\) is
measured only a \(X\) is needed to transform the state into \(\ket{\psi}\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgbdcea7b" class="outline-3">
<h3 id="orgbdcea7b">Exercise 10.66 (Fault-tolerant \(\pi/8\) gate construction)</h3>
<div class="outline-text-3" id="text-orgbdcea7b">
<p>
One way to implement a π/8 gate is to first swap the qubit state \(\ket{\psi}\) you wish to
transform with some known state \(\ket{0}\), then to apply a π/8 gate to the resulting
qubit. Here is a quantum circuit which does that:
</p>

<pre class="example">
       ┌───┐         ┌───┐┌───┐
  |0&gt;: ┤ H ├──■──────┤ X ├┤ T ├ T|psi&gt;
       └───┘┌─┴─┐┌─┐ └─╥─┘└───┘
|psi&gt;: ─────┤ X ├┤M├───║───────
            └───┘└╥┘   ║
  c: 1/═══════════╩════╩═══════
                  0
</pre>


<p>
Doing this does not seem particularly useful, but actually it leads to something which is!
Show that by using the relations \(TX=\exp(−\ii\pi/4)SXT\) and \(TU=UT\) (\(U\) is the <code>CNOT</code>
gate and \(T\) acts on the control qubit) me may obtain the circuit from Figure 10.25.
</p>
</div>

<div id="outline-container-org1c11759" class="outline-4">
<h4 id="org1c11759">Solution</h4>
<div class="outline-text-4" id="text-org1c11759">
<p>
That \(T\) commutes with \(U\) follows from the fact that \(T\equiv\?R_z(\pi/4)\) is a function
of the \(Z\) operator whose eigenstates form the decision states of the <code>CNOT</code> gate
(\(U\)). Here with \(\equiv\) I mean <i>equality up to global phase</i>. That
\(TX=\exp(−\ii\pi/4)SXT\) follows essentially from the bloch sphere interpretation:
</p>

<p>
\[
  XTX \equiv X R_z(\pi/4) X = R_z(-\pi/4) \equiv S^\dagger T \equiv XSXT .
\]
</p>

<p>
The correct phase is not really important here but could also be recovered because there
are transparent rules to translate between \(T,S,Z\) on the one hand and \(R_z(\theta)\)
<i>including</i> phase on the other hand. For example:
</p>

<p>
\[
  T = \sqrt[4]{Z} = e^{i\pi/8} R_z(\pi/4) .
\]
</p>

<p>
Having this commutation relation at hand it is easy to commute \(T\) from the end to the
desired place near the beginning of the circuit.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.67" class="outline-3">
<h3 id="exercise-10.67">Exercise 10.67</h3>
<div class="outline-text-3" id="text-exercise-10.67">
<p>
Show that the following circuit identities
</p>

<dl class="org-dl">
<dt>(1)</dt><dd><pre class="example">
     ┌───┐
q_0: ┤ X ├──■──
     └───┘  │
q_1: ───────■──
          ┌─┴─┐
q_2: ─────┤ X ├
          └───┘
</pre>


<p>
equals
</p>

<pre class="example">
          ┌───┐
q_0: ──■──┤ X ├
       │  └───┘
q_1: ──■────■──
     ┌─┴─┐┌─┴─┐
q_2: ┤ X ├┤ X ├
     └───┘└───┘
</pre></dd>

<dt>(2)</dt><dd><pre class="example">

q_0: ───────■──
            │
q_1: ───────■──
     ┌───┐┌─┴─┐
q_2: ┤ Z ├┤ X ├
     └───┘└───┘
</pre>


<p>
equals
</p>

<pre class="example">

q_0: ──■────■──
       │    │
q_1: ──■────■──
     ┌─┴─┐┌───┐
q_2: ┤ X ├┤ Z ├
     └───┘└───┘
</pre></dd>
</dl>
</div>

<div id="outline-container-orgfadd445" class="outline-4">
<h4 id="orgfadd445">Solution</h4>
<div class="outline-text-4" id="text-orgfadd445">
<p>
There are several simple ways to see these identities. The most straightforward way is to
check that the circuits act the same on the eight basis states \(\ket{ijk}\)
(\(i,j,k\in\{0,1\}\)). This is <i>essentially</i> what we do in the following, but we take some
simple shortcuts which save us from tabulating eight possibilities for each identity
(instead we only have to consider two carefully chosen cases).
</p>

<p>
Consider identity (1). Clearly both circuits act the same way on the first two
circuits. For the first circuit we see that it only acts non-trivially (with an \(X\)) on
the third qubit if \(i=0\), \(j=1\). It is not hard to see that the second circuit does the
same.
</p>

<p>
Consider identity (2). It is not hard to see that both circuits map \(\ket{11k}\) to
\((-1)^k\ket{11\bar{k}}\), where \(k=k+1\mod2\). On the other hand, if at least one of \(i\),
\(j\) is not \(1\), then both circuits act as \(\ket{ijk}\mapsto(-1)^{k}\ket{ijk}\).
</p>
</div>
</div>
</div>

<div id="outline-container-org64d46ec" class="outline-3">
<h3 id="org64d46ec">Exercise 10.68 (Fault-tolerant Toffoli gate construction)</h3>
<div class="outline-text-3" id="text-org64d46ec">
<p>
A procedure similar to the above sequence of exercises for the π/8 gate gives a
fault-tolerant Toffoli gate
</p>

<ol class="org-ol">
<li><p>
First, swap the three qubit state \(\ket{xyz}\) you wish to transform with some known
state \(\ket{000}\), then apply a Toffoli gate to the resulting qubits. Show that the
following circuit accomplishes this task:
</p>

<pre class="example">
The book contains a circuit here.
</pre></li>

<li><p>
Using the commutation rules from <a href="#exercise-10.67">Exercise 10.67</a>, show that moving the final Toffoli
gate all the way back to the left side gives the circuit
</p>

<pre class="example">
The book contains a circuit here.
</pre></li>

<li>Assuming the ancilla preparation shown in the leftmost dotted box can be done
fault-tolerantly, show that this circuit can be used to give a fault-tolerant
implementation of the Toffoli gate using the Steane code.</li>
</ol>

<dl class="org-dl">
<dt>Remark</dt><dd>This <a href="https://arxiv.org/abs/1212.5069v1">arxiv paper</a> might be and interesting read on the topic of this exercise.</dd>
</dl>
</div>

<div id="outline-container-orgf0dfadc" class="outline-4">
<h4 id="orgf0dfadc">Solution</h4>
<div class="outline-text-4" id="text-orgf0dfadc">
<p>
Part (1) is really just two times the <a href="#orgdaad7b4">second</a> circuit and one time the <a href="#orgd6828c9">third</a> circuit from
<a href="#exercise-10.65">exercise 10.65</a>.
</p>

<p>
For part (2) there isn't much to say. The exercise statement already explained that this
follows from the identities from <a href="#exercise-10.67">exercise 10.67</a>.
</p>

<p>
For part (3) observe that the non-ancilla part of the circuit only contains Clifford gates
(some of which are classically controlled). In the main text we have already seen how to
implement those in the Steane code. So assuming the ancilla can also be prepared so that
it is already Steane-encoded the whole circuit can be implemented in a fault tolerant way.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf405179" class="outline-3">
<h3 id="orgf405179">Exercise 10.69</h3>
<div class="outline-text-3" id="text-orgf405179">
<p>
Show that a single failure anywhere in the ancilla preparation and verification can lead
to at most one \(X\) or \(Y\) error in the ancilla output.
</p>
</div>

<div id="outline-container-exercise-10.69-solution" class="outline-4">
<h4 id="exercise-10.69-solution">Proof</h4>
<div class="outline-text-4" id="text-exercise-10.69-solution">
<p>
The following argumentation is designed to work with the 7-qubit Steane code. However, it
is generic as it applies to any \([n,1]\) stabilizer code showing that the arguments also
apply to e.g. the 5-qubit code. Note however that strictly speaking several assumptions go
into the construction of the schematic circuit from Firgure 10.28. For example we assume
that the controlled-​\(M\) operation can be implemented in a transversal way. For this
exercise we are only concerned about the Prepare-Verify part of the circuit allowing us to
be more general. But you can always set \(n=7\) to restrict everything to the Steane code
and keep things simple.
</p>

<p>
Let us distinguish two cases:
</p>

<ol class="org-ol">
<li>A single error in the preparation stage (and no error in verification stage).</li>
<li>A single error in the verification stage (and no error in preparation stage).</li>
</ol>

<p>
Consider <b>case 1</b> (error in preparation stage). Let us briefly show that multiple \(X\)
errors are possible directly after the preparation stage even if <i>only</i> one of its
components fails. To see this assume that the first <code>CNOT</code> between the first and second
ancilla produces a single \(X\) error at its control qubit (ancilla 1). By the propagation
rules for <code>CNOT</code> this error gets distributed (by the following <code>CNOT</code> gates) to almost all
ancilla qubits, leading to the following total error after preparation:
</p>

<p>
\[X\otimes I \otimes X^{\otimes n-2}\]
</p>

<p>
For that reason we assume that the error after the preparation stage is in the most
general form according to the error model from the main text
</p>

<p>
\[
E = \bigotimes_{j=1}^n N_j, \text{ where } N_j \in \{I,X,Y,Z\} .
\]
</p>

<p>
Recall that this error model says that a component fails with a certain probability \(p\)
and produces only Pauli errors at its outputs. If no errors would have occured the output
of the preparation stage is a cat state:
</p>

<p>
\[
  \cat = \frac{1}{\sqrt{2}} (\ket{0^n} + \ket{1^n}) .
\]
</p>

<p>
With error the output is \(E\cat\). Now we show that the verification stage detects if any
\(X\) or \(Y\) errors are present (but it does not see \(Z\) errors). In fact, the verification
stage can be implemented as a series of \(n-1\) pairs of <code>CNOT</code> gates
</p>

<p>
\[
  G_j = \cx_{j,x} \cx_{j+1,x}, \quad (j=1..n-1),
\]
</p>

<p>
(\(x\) being an additional ancilla outside the "main" ancillas initialized to \(\ket{0}\) for
each \(G_j\)) which are followed by a measurement (each). It is not hard to see that the
verification step implements the measurement of all \(g_j=Z_jZ_{j+1}\) for \(j=1..n-1\). These
operators can be seen as the stabilizer of the two dimensional subspace spanned by
</p>

<p>
\[
  \ket{0^n}, \ket{1^n} ,
\]
</p>

<p>
which contains \(\cat\). Thus applying verification to \(E\cat\) the verification either
detects an error (which saves us) or it says "OK" and the final state is one of two
possibilities
</p>

<p>
\[
  \catp{\pm} = \frac{1}{\sqrt{2}} (\ket{0^n} \pm \ket{1^n}) ,
\]
</p>

<p>
Note that \(\catp{+}=\cat\) is the cat state and contains <i>effectively</i> no errors but
could be the result of an <i>even</i> number of \(Z\) errors (which do not affect the cat
state). In case of an <i>odd</i> number of \(Z\) errors we get \(\catp{-}\). This would be a
"proper" error. It does not propagate into the data qubits (because \(Z\) commutes with the
control of any controlled gate) but it would be <i>decoded</i> into \(\ket{10^{n-1}}\) which
would be measured as \(1\) at the first ancilla. Hence this error would basically swap the
measurement result for the overall procedure (whose goal is to measure an operator \(M\)
whose eigenvalues are \(\pm1\)). This concludes case 1, as we have seen that actually <i>no</i>
\(X\) or \(Y\) errors can hide from the verification procedure.
</p>

<p>
Consider <b>case 2</b> (verification fails). In that case, by assumption, the preparation stage
correctly produces \(\cat\). Any error (\(X,Y,Z\)) originating from a control of the \(G_j\)
(see above) can only propagate into the additional ancillas and hence not into the rest of
the \(n\) "main" ancillas. Moreover, although a \(Z\) error in the additional ancillas can
propagate into the main ancillas, but \(X\) cannot. Similarly a \(Y=\ii\?ZX\) error in the
additional ancillas can only propagate a \(Z\) error into the main ancillas.
</p>

<p>
Hence, in this case, a \(X\) or \(Y\) error can only be produced if it originates from a part
of a component (a control of the <code>CNOT</code> gates) which is attached to the main ancillas and
furthermore it cannot further propagate into the other main ancillas. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org6eac808" class="outline-3">
<h3 id="org6eac808">Exercise 10.70</h3>
<div class="outline-text-3" id="text-org6eac808">
<p>
Show that \(Z\) errors in the ancilla do not propagate to affect the encoded data, but result
in an incorrect measurement result being observed.
</p>
</div>

<div id="outline-container-orgc619e67" class="outline-4">
<h4 id="orgc619e67">Solution</h4>
<div class="outline-text-4" id="text-orgc619e67">
<p>
In this solution we do not need to restrict to the Steane code. Instead we consider a
general stabilizer code on \(n\) qubits (Steane has \(n=7\)) for which the transversal
construction for the controlled \(M\) operator works as outlined and such that \(n\) is
odd. See also the first paragraph of the <a href="#exercise-10.69-solution">solution</a> of exercise 10.69.
</p>

<p>
Let us briefly recall that \(Z\) errors commute with the control of any controlled gate
\(C(U)\). In fact, we have
</p>

<p>
\[
  C(U) = P_0\otimes I + P_1\otimes U .
\]
</p>

<p>
Note that the projections \(P_j=\proj{j}\) onto the standard basis actually commute with \(Z\)
because the standard basis <i>is</i> the eigenbasis of \(Z\) (by definition). For that reason we
have
</p>

<p>
\[
  C(U) \cdot Z\otimes I = (P_0 Z) \otimes I + (P_1 Z) \otimes U
  = (Z P_0) \otimes I + (Z P_1) \otimes U
  = Z\otimes I \cdot C(U) .
\]
</p>

<p>
This implies that \(Z\) errors in the ancillas cannot propagate into the data qubits because
ancillas and data are only connected via <code>CNOT</code> gates (with controls in the
ancillas). This shows the first part of the claim.
</p>

<p>
Now let us check how \(Z\) errors affect the measurement. For that purpose let us define
</p>

<p>
\[
  \catp{\pm} = \frac{1}{\sqrt{2}} ( \ket{0^n} \pm \ket{1^n} )
\]
</p>

<p>
and first consider the working of the operator measurement in case no error happens. Let
\(\ket{\psi}\) be the encoded data and decompose it into
</p>

<p>
\[
  \ket{\psi} = a\ket{\psi_+} + b\ket{\psi_-} ,
\]
</p>

<p>
where \(\ket{\psi_{\pm}}\) are the encoded eigenstates of \(M\) (with eigenvalues
\(\pm1\)). Right before applying the controlled \(M\) the state is \(\cat\ket{\psi}\). After
applying the (encoded) controlled \(M\) operator we get (after reordering terms)
</p>

\begin{align*}
  & a \catp{+} \ket{\psi_+} + b\catp{-} \ket{\psi_-} .
\end{align*}

<p>
Here at this point we need that the transversal construction of the encoded controlled \(M\)
gate looks like in Figure 10.28 (see also Figure 10.24) and the coded uses an odd number
\(n\) of qubits (so that \((-1)^n=-1\)). Decoding transforms it into
</p>

\begin{align*}
  & a \ket{00^{n-1}} \ket{\psi_+} + b\ket{10^{n-1}} \ket{\psi_-} .
\end{align*}

<p>
Hence, measuring \(0\) (in the first ancilla) yields \(\ket{\psi_+}\) in the data qubits, and
measuring \(1\) yields \(\ket{\psi_-}\) in the data qubit. This is as desired.
</p>

<p>
What happens if we get \(r\geq1\) many \(Z\) errors after the prepare-verify stages? If \(r\) is
even this does not affect the cat state and the procedure works as expected. If \(r\) is odd
the cat state \(\cat=\catp{\?+}\) is replaced by \(\catp{-}\). In essence, in the above
derivation \(\catp{+}\) and \(\catp{-}\) swap their roles. Hence, right before measurement we
get the state
</p>

\begin{align*}
  & a \ket{10^{n-1}} \ket{\psi_+} + b\ket{00^{n-1}} \ket{\psi_-} .
\end{align*}

<p>
This implies that we infer the wrong eigenvalue in this case (with 100% probability). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcd1850f" class="outline-3">
<h3 id="orgcd1850f">Exercise 10.71</h3>
<div class="outline-text-3" id="text-orgcd1850f">
<p>
Verify that when \(M=e^{-\ii\pi/4}SX\) the procedure we have described gives a
fault-tolerant method for measuring \(M\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>If I did no mistake in the proof below the \(\pi/8\) gates at the ancillas are
not needed.</dd>
</dl>
</div>

<div id="outline-container-org1e9ced0" class="outline-4">
<h4 id="org1e9ced0">Proof</h4>
<div class="outline-text-4" id="text-org1e9ced0">
<p>
Let us consider this exercise for the 7-qubit Steane code. Let us denote the ancilla
qubits by the labels \(a_i\) and the qubits for the data by \(d_i\) (\(i=1..7\)). We show that
the encoded controlled \(M\) operator is given by a product of controlled \(V=ZSX\) gates with
controls and targets as in Figure 10.24 (where the first block are the ancillas and the
second block the data):
</p>

<p>
\[
  \prod_{i=1}^{7} C(ZSX)_{a_i,d_i}
\]
</p>

<p>
First of all observe that
</p>

\begin{align*}
  M Z M^\dagger &= SX Z XS^\dagger = -Z , \\
  M X M^\dagger &= SX X XS^\dagger = Y .
\end{align*}

<p>
This is the behaviour we want to have on the encoded qubits (logical qubits). On the other
hand we have (on the physical qubits)
</p>

\begin{align*}
  V Z V^\dagger &= ZSX Z XS^\dagger Z = -Z , \\
  V X V^\dagger &= ZSX X XS^\dagger Z = -Y .
\end{align*}

<p>
This is exactly what we want for the Steane code! In fact, the logical Pauli operators are
\(\bar{Z}=Z^{\otimes7}\), \(\bar{X}=X^{\otimes7}\), and \(\bar{Y}=-Y^{\otimes7}\). The formula
for \(\bar{Y}\) follows from \(Y=\ii\?XZ\). So the minus sign in front of \(Y\) is exactly what
we want. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org16d854f" class="outline-3">
<h3 id="org16d854f"><span class="todo WIP">WIP</span> Exercise 10.72 (Fault-tolerant Toffoli ancilla state construction)</h3>
<div class="outline-text-3" id="text-org16d854f">
<p>
Show how to fault-tolerantly prepare the state created by the circuit in the dotted box of
Exercise 10.68, that is,
</p>

<p>
\[
  \ket{\Theta} = \frac{1}{2}( \ket{000} + \ket{100} + \ket{010} + \ket{111} )
\]
</p>

<p>
You may find it helpful to first give the stabilizer generators for this state.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Since I couldn't solve the exercise in the way suggested I searched for a
solution elsewhere. In section 6.2 of (Shor, Peter W., 1996) (<a href="https://doi.org/10.1109/SFCS.1996.548464">link</a>) I found a nice and
transparent construction which does not take the approach suggested here (but it is
still based on cat states). I didn't read the whole paper but it seems to have had a big
influence on the contents of chapter 10 (it is also cited by the book).</dd>
</dl>
</div>

<div id="outline-container-org28c7039" class="outline-4">
<h4 id="org28c7039">Attempted solution</h4>
<div class="outline-text-4" id="text-org28c7039">
<p>
By construction we have
</p>

<p>
\[
  \ket{\Theta} = \mathrm{CCX} H_1 H_2 \ket{000} .
\]
</p>

<p>
So in order to find generators of the stabilizer of \(\ket{\Theta}\) we start with the generators
</p>

<p>
\[ \langle Z_1, Z_2, Z_3 \rangle \]
</p>

<p>
of \(\ket{000}\) and apply the stabilizer formalism. Applying the two Hadamard gates
according to the stabilizer formalism (every generator gets conjugated by the gates:
\(g\mapsto\?UgU^\dagger\)) yields
</p>

<p>
\[ \langle X_1, X_2, Z_3 \rangle . \]
</p>

<p>
The interesting thing happens when we apply the Toffoli gate (a non-clifford gate). In
that case we leave the Pauli group and get:
</p>

<p>
\[ \langle X_1\cx_{23}, X_2\cx_{13}, Z_3\cz_{12} \rangle . \]
</p>

<p>
To see this use <a href="#exercise-10.67">exercise 10.67</a>. All three generators are three qubit gates, but they still
have eigenvalues \(\pm1\) (as they are produced by conjugation).
</p>

<p>
Now I would like to use the construction from 10.28. However there are several problems I
cannot solve at the moment. For example the construction requires to put yet another layer
of <i>control</i> to the generators. Since the generators already contain controlled gates this
requires doubly controlled gates (a priori at least). This does not look like a promising
approach to me. So I leave this solution open ended &#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-10.73" class="outline-3">
<h3 id="exercise-10.73">Exercise 10.73 (Fault-tolerant encoded state construction)</h3>
<div class="outline-text-3" id="text-exercise-10.73">
<p>
Show that the Steane code encoded \(\ket{0}\) state can be constructed fault-tolerantly in
the following manner.
</p>

<ol class="org-ol">
<li>Begin with the circuit of Figure 10.16, and replace the measurement of each generator,
as shown in Figure 10.30, with each ancilla qubit becoming a cat state
\((\ket{0^7}+\ket{1^7})/\sqrt{2}\), and the operations rearranged to have their controls
on different qubits, so that errors do not propagate within the code block.</li>
<li>Add a stage to fault-tolerantly measure \(Z\).</li>
<li>Calculate the error probability of this circuit, and of the circuit when the generator
measurements are repeated three times and majority voting is done.</li>
<li>Enumerate the operations which should be performed conditioned on the measurement
results and show that they can be done fault-tolerantly.</li>
</ol>
</div>

<div id="outline-container-org20bd14e" class="outline-4">
<h4 id="org20bd14e">Solution</h4>
<div class="outline-text-4" id="text-org20bd14e">
<p>
The construction which is described above is just a variation of the schematic given in
Figure 10.28. Each of the six measurements (one for each generator) has its own block of
seven ancilla qubits (but the same data block). Measuring them in a row implies that we
get a state \(\ket{\psi}\) (in the data block) which is a simultaneous eigenstate of the six
generators. Repeating this procedure three times and taking majority votes ensures a
success probability for a correct measurement of \(O(p^2)\) (NOTE: this is not explicitly
mentioned in the book but each repetition reuses the data-block output from the previous
iteration. This works because errors do not propagate in the data block and hence at most
one qubit is corrupted in case a single component fails).
</p>

<p>
As already mentioned, after all this the state \(\ket{\psi}\) is a simultaneous eigenstate
of the six generators. Let us denote the measurement result by a bit vector
\(b\in\BB^6\). The state \(\ket{\psi}\) is \(\ket{0_L}\) iff \(b=0^6\). Otherwise we can <i>correct</i>
the state by treating \(b\) as a syndrome and apply operators according to the table
produced in the <a href="#exercise-10.61-solution">solution</a> of exercise 10.61.
</p>
</div>
</div>
</div>

<div id="outline-container-org2e09cdf" class="outline-3">
<h3 id="org2e09cdf">Exercise 10.74</h3>
<div class="outline-text-3" id="text-org2e09cdf">
<p>
Construct a quantum circuit to fault-tolerantly generate the encoded \(\ket{0}\) state for
the five qubit code (Section 10.5.6).
</p>
</div>

<div id="outline-container-org7e94300" class="outline-4">
<h4 id="org7e94300">Sketch of a solution</h4>
<div class="outline-text-4" id="text-org7e94300">
<p>
Conceptually one does exactly the same as for the Steane code. Just have a look into
<a href="#exercise-10.73">exercise 10.73</a>. I see no benefit in repeating it here.
</p>
</div>
</div>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4.50 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>
