;; -*- org-confirm-babel-evaluate: nil -*-
#+title:  Notes on the book `Quantum Computation and Quantum Information`
#+author: Reinhard Stahn
#+latex_header: \newcommand{\CC}{\mathbb{C}}
#+latex_header: \newcommand{\CU}{\mathrm{CU}}
#+latex_header: \newcommand{\CX}{\mathrm{CX}}
#+latex_header: \newcommand{\CZ}{\mathrm{CZ}}
#+startup: inlineimages latexpreview show2levels

Notes on the [cite:Quantum Computation Bible @ChuangNielsen2011].

TODOs:
- [X] Write Exercise x.y instead of exercise x.y in headings.
- [ ] Remove the numbers from (at least some) headings in the HTML output.
- [ ] How to tell the HTML exporter to recognize the latex macros (e.g. for \CZ).
- [ ] Remove toplevel Heading "quantum bible", Make Chapters toplevel?
- [ ] move latex_header to separate file

* quantum bible
** ACTIVE Chapter 4
  :PROPERTIES:
  :header-args:python: :session *chapter-4* :tangle yes :comments link :results silent :exports both
  :END:
*** Notes
**** Setup sympy
#+name: setup-chapter-4
#+begin_src python
  import sympy as sp
  from sympy import cos, exp, I, Matrix, pi, sin, sqrt
  from sympy.physics.quantum import TensorProduct

  from qiskit import QuantumCircuit

  def tprod(A1, *As):
      """Generalize TensorProduct to one and more then two arguments."""
      P = A1
      for A in As:
          P = TensorProduct(P, A)
      return P
#+end_src

**** Pauli- and Rotation-Matrices
The Pauli matrices, and some of their friends

#+name: paulis-and-friends
#+begin_src python
  # The Paulis:
  X = Matrix([[0, 1], [1, 0]])
  Y = Matrix([[0, -I], [I, 0]])
  Z = Matrix([[1, 0], [0, -1]])

  # Identity
  Id = Matrix([[1, 0], [0, 1]])
  # Hadamard Gate
  H = Matrix([[1, 1], [1, -1]]) / sqrt(2)
  # Phase Gate (sqrt(Z))
  S = Matrix([[1, 0], [0, I]])
  # pi/8 Gate
  T = Matrix([[1, 0], [0, exp(pi * I / 4)]])

  # roation operators
  # - Rz: Phase Shift
  # - Rx: "Strange" Rotation
  # - Ry: Real Rotation
  theta = sp.symbols('theta')
  Rz = Matrix([[exp(-I*theta/2), 0], [0, exp(I*theta/2)]])
  Rx = Matrix([[cos(theta/2), -I*sin(theta/2)], [-I*sin(theta/2), cos(theta/2)]])
  Ry = Matrix([[cos(theta/2), -sin(theta/2)], [sin(theta/2), cos(theta/2)]])
#+end_src

The rotation operators correspond to a rotation of angle $\theta$ around the respective axis in the
*Bloch Sphere*.

#+caption: The Bloch Sphere
#+name: fig:bloch-sphere.svg
#+attr_org: :width 400px
#+attr_html: :style width: 50%
[[./images/bloch-sphere.svg]]

**** TODO Misc Gates
#+name: misc-gates
#+begin_src python
  SWAP = Matrix([
    [1, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1]
  ])
#+end_src

**** TODO Controlled Gates
For the definition of the controlled gates we introduce the projections $P_j$ corresponding to the
computational basis.

#+name: controlled-gates
#+begin_src python
  # First define the projections onto the computational basis
  P0 = Matrix([[1, 0], [0, 0]])
  P1 = Matrix([[0, 0], [0, 1]])

  # controlled X (NOT), and Z gates
  CX = tprod(P0, Id) + tprod(P1, X)
  CZ = tprod(P0, Id) + tprod(P1, Z)

  # Toffoli Gate
  Toff = tprod(P0, P0, Id) + tprod(P0, P1, Id) + tprod(P1, P0, Id) + tprod(P1, P1, X)

  # Fredkin Gate
  Fred = tprod(P0, Id, Id) + tprod(P1, SWAP)
#+end_src

#+name: make-controlled-gates
#+begin_src python
  def make_CU(num_wires, control, target, U):
      """Returns a controlled U Gate. U must be single qubit gate. Wires are
      numbered 0 to num_wires-1."""
      assert 0 <= control < num_wires
      assert 0 <= target < num_wires
      assert control != target

      t0 = [Id]*num_wires
      t1 = [Id]*num_wires

      t0[control] = P0
      t1[control] = P1
      t1[target] = U

      return tprod(*t0) + tprod(*t1)


  def make_CnU(num_wires, controls, target, U):
      """Generalization of make_CU to several controls."""
      assert all([0 <= c < num_wires for c in controls])
      assert 0 <= target < num_wires
      assert all([c != target for c in controls])

      from itertools import product
      P = [P0, P1]

      CnU = None
      ts = []
      for bitlist in product(*[[0, 1]]*len(controls)):
          t = [Id]*num_wires

          for i, bit in enumerate(bitlist):
              t[controls[i]] = P[bit]

          ts.append(t)
      ts[-1][target] = U

      tensors = [tprod(*t) for t in ts]
      CnU = None
      for tensor in tensors:
          CnU = tensor if CnU is None else CnU + tensor

      return CnU


  # Unit Tests for very pour people:
  assert make_CU(2, 0, 1, X) == CX, "Expected CX Gate"
  assert make_CnU(3, [0, 1], 2, X) == Toff, "Expected Toffoli Gate"
#+end_src

*** Exercises
**** Exercise 4.1
In Exercise 2.11, which you should do now if you haven’t already done it, you computed the
eigenvectors of the Pauli matrices. Find the points on the Bloch sphere which correspond to the
normalized eigenvectors of the different Pauli matrices.

Eigenvalues are +1 and -1 for all Paulis.

Eigenvectors (non-normalized, tip: ~Y.eigenvects()~):

| Pauli | EV +1    | EV -1    |
|-------+----------+----------|
| Z     | (1, 0)   | (0, 1)   |
| X     | (1, 1)   | (1, -1)  |
| Y     | (1j, -1) | (-1, 1j) |
**** Exercise 4.2
Let $x$ be a real number and $A$ a matrix such that $A^2 = I$. Show that

\begin{align*}
% \label{eq:exercise-4.2-1}
\exp(ixA) = \cos(x)I + i\sin(x)A
\end{align*}

Use this result to verify Equations (4.4) through (4.6).

*Solution:* The equation is obvious from polynomial series of ~exp, sin, cos~.

**** Exercise 4.3
Show that, up to a global phase, the π/8 gate satisfies $T = R_z(\pi/4)$.

*Solution:* It is easy to see that $T = \exp(i\pi/8) \cdot R_z(\pi/4)$. Demonstration:

#+name: exercise-4.3-1
#+begin_src python :results replace
  rz = Rz.subs(theta, pi/4)
  exp(1j*pi/8) * rz - T  # should be zero
#+end_src

#+RESULTS: exercise-4.3-1
: Matrix([[0, 0], [0, -exp(I*pi/4) + exp(0.25*I*pi)]])

**** Exercise 4.4
Express the Hadamard gate H as a product of Rx and Rz rotations and e^{iφ} for some φ.

*Solution:* Clearly a mere product of two factors can't produce the Hadamard gate. Hence we try to
find $\alpha,\beta,\gamma$ such that $R_z(\alpha)\cdot R_x(\gamma) \cdot R_z(\beta)$ is the Hadamard
up to the phase factor. Due to the sqrt of 2 factor appearing in $H$ we deduce that $\gamma=\pm\pi/2$
is a good bet. Knowing what comes we choose $\gamma=\pi/2$.

#+name: exercise-4.4-1
#+begin_src python :results value latex replace
  a, b = sp.symbols('\\alpha \\beta')

  ra = Rz.subs(theta, a)
  rb = Rz.subs(theta, b)
  rx = Rx.subs(theta, pi/2)

  h0 = ra * rx * rb
  simp = sp.simplify(sqrt(2)*h0)
  latex_formula = sp.latex(simp)

  #sp.preview(simp, viewer='file', filename='output.png', euler=False,
  #           dvioptions=['-D', '200', '-T', 'tight', '-bg', 'Transparent', '-fg', 'rgb 0.2 0.6 1.0'])
  #"output.png"

  latex_formula
#+end_src

A short calculation leads to:

#+RESULTS: exercise-4.4-1
#+begin_export latex
\left[\begin{matrix}e^{\frac{i \left(- \alpha - \beta\right)}{2}} & - i e^{- \frac{i \left(\alpha - \beta\right)}{2}}\\- i e^{\frac{i \left(\alpha - \beta\right)}{2}} & e^{\frac{i \left(\alpha + \beta\right)}{2}}\end{matrix}\right]
#+end_export

# RHS is result above
$$
R_z(\alpha)\cdot R_x(\pi/2) \cdot R_z(\beta) = \frac{1}{\sqrt{2}} \cdot
\left[\begin{matrix}e^{0.5 i \left(- \alpha - \beta\right)} & - 1.0 i e^{- 0.5 i \left(\alpha - \beta\right)}\\- 1.0 i e^{0.5 i \left(\alpha - \beta\right)} & e^{0.5 i \left(\alpha + \beta\right)}\end{matrix}\right]
$$

Hence setting $\alpha = \beta = \pi/2$ and $\phi = \pi/2$ we get

$$
H = e^{i\pi/2} \cdot R_z(\pi/2)\cdot R_x(\pi/2) \cdot R_z(\pi/2)
$$

**** Exercise 4.5
Prove that $(\hat{n}\cdot\sigma)^2 = I$, and use this to verify Equation (4.8).

*Solution:* This is easy to see from the following calculation:

#+name: exercise-4.5-1
#+begin_src python :results replace :exports both
  nx, ny, nz = sp.symbols('n_x n_y n_z')
  r = nx*X + ny*Y + nz*Z

  sp.simplify(r*r)
#+end_src

#+RESULTS: exercise-4.5-1
: Matrix([[n_x**2 + n_y**2 + n_z**2, 0], [0, n_x**2 + n_y**2 + n_z**2]])

By assumption we have ~nx**2 + ny**2 + nz**2 = 1~, hence follows the claim.

**** Exercise 4.6
Show that the rotation operators $R_{\hat{n}}(\theta)$ corresponds to a rotation of angle $\theta$
around the axis given by $\hat{n}$.

In other words: If we identify Qubits which just differ by phase, and identify each Qubit with its
(unique) Bloch vector, then the action of the quantum rotation is isomorphic to the ordinary
rotation with said axis and angle within the Bloch Sphere.
***** Proof
We divide the proof into several steps.

Let $|\psi\rangle = \cos\left(\theta /2\right) |0 \rangle \, + \, e^{i\varphi} \sin\left(\theta
/2\right) |1\rangle$ and recall the parameterization $p = (\sin\theta \cos\varphi,\;
\sin\theta \sin\varphi,\; \cos\theta)$
of the sphere.

****** (A) The claim is true for the special case $\hat{n} = (0, 0, 1)$.

PROOF: The standard basis $(|0\rangle, |1\rangle)$ diagonalizes $Z$. Hence, $Z$ trivially acts on
$\varphi$ which corresponds to a rotation around the z-axis. QED.

****** (B) The claim is true for the special case $\hat{n} = (0, 1, 0)$.

PROOF: It is sufficient to prove this for infinitesimal small angles. More precisely, we consider
$\delta \to 0$ and use $\approx$ for equality up to $O(\delta^2)$.

Let $r_y(\delta)$ be the rotation of angle $\delta$ around y-axis. Let $\theta' = \theta + a\delta$ and $\varphi'=\varphi+b\delta$
be the coordinates of $r_y(\delta)p$. We want to calculate $a, b$. We have:

\begin{align*}
r_y(\delta)p &\approx (\sin(\theta)\cos(\varphi) + \delta\cos(\theta),\;
  a \sin(\theta)\sin(\varphi),\;
  a \cos(\theta) - \delta\sin(\theta)\cos(\varphi)) \\
  &\approx (\sin\theta' \cos\varphi',\; \sin\theta' \sin\varphi',\; \cos\theta')
\end{align*}

It is advisable to first calculate $a$ from the third components and then $b$ from the second:

$$
  a = \cos(\varphi),\quad b = - \frac{\cos(\theta)\sin(\varphi)}{\sin(\theta)}
$$

Next we abbreviate $c=\cos(\theta/2)$, $s=\sin(\theta/2)$ and similarly $c', s'$ with $\theta'$ in place of $\theta$.

$$
  R_y(\delta) |\psi\rangle \approx (c - \frac{\delta}{2} e^{i\varphi} s) |0\rangle + (\frac{\delta}{2} c + e^{i\varphi}s) |1\rangle
$$

It is to be shown that this equals (up to $O(\delta^2)$)

$$
  e^{i\delta f} (c'|0\rangle + e^{i\varphi'}s'|1\rangle)
$$

for some real $x$. A calculation yields that this is indeed true for $f=-s\sin(\varphi)/2c$. QED.

****** (C) The claim is true for the special case $\hat{n} = (1, 0, 0)$.

PROOF: Observe that:

$$
  R_x(\theta) = R_y(\pi/2) R_z(\theta) R_y(-\pi/2)
$$

Moreover, recall that a similar formula holds for the rotations within the Bloch Sphere:

$$
  r_x(\theta) = r_y(\pi/2) r_z(\theta) r_y(-\pi/2)
$$

This together with (A) and (B) implies the claim. QED.

****** Intermezzo
Let $\hat{n} = (x, y, z)$, and $a = x + iy$. Then

$$
  N := \hat{n}\cdot(X, Y, Z) = \left(\begin{matrix} z & \overline{a} \\ a & -z \end{matrix}\right)
$$

It remains to show the claim for $N$.

****** (D) There exist $\alpha,\beta$ such that:

$$
  R_{\hat{n}}(\theta) = R_x(\alpha) R_y(\beta) \cdot R_z(\theta) \cdot R_y(-\beta) R_x(-\alpha)
$$

PROOF: The expression on the right simplifies to

\begin{bmatrix}
  \cos(\alpha)\cos(\beta) & \sin(\beta) + i \sin(\alpha)\cos(\beta) \\
  \sin(\beta) - i \sin(\alpha)\cos(\beta) & -\cos(\alpha)\cos(\beta)
\end{bmatrix}

It is not hard to see that $\alpha,\beta$ can be chosen such that this equals $N$. The concrete
values would be needed to determine the axis of rotation. However, we determine it another way. QED.

****** (E) $R_{\hat{n}}(\alpha)$ corresponds to a rotation of angle $\alpha$ around /some/ axis
(which is independent of the angle).

PROOF: This is a direct consequence of (D), together with (B) and (C). QED.

****** (F) The angle in (E) is indeed $\hat{n}$.

PROOF: We have to show that the positive eigenvector $v_+$ of $R_{\hat{n}(\alpha)}$ corresponds to
$\hat{n}$ on the Bloch sphere. Therefore let us calculate the eigenvalues:

#+name: exercise-4.6
#+begin_src python :results replace output
  x, y, z = sp.symbols('x y z')
  N = Matrix([[z, x - I*y], [x + I*y, -z]])
  ev = N.eigenvects()

  # Keep in mind that x^2 + y^2 +z^2
  for i in [0, 1]:
      print(f"eigenvalue = {ev[i][0]}\neigenvector = {ev[i][2]}\n")
#+end_src

#+RESULTS: exercise-4.6
: eigenvalue = -sqrt(x**2 + y**2 + z**2)
: eigenvector = [Matrix([
: [z/(x + I*y) - sqrt(x**2 + y**2 + z**2)/(x + I*y)],
: [                                               1]])]
:
: eigenvalue = sqrt(x**2 + y**2 + z**2)
: eigenvector = [Matrix([
: [z/(x + I*y) + sqrt(x**2 + y**2 + z**2)/(x + I*y)],
: [                                               1]])]

We see that the normalized eigenvectors for $\pm 1$ are:

$$
  v_{\pm} = \frac{1}{\sqrt{2}} \left(
    \pm \sqrt{1 \pm z}\cdot|0\rangle + \frac{x + iy}{\sqrt{1 \pm z}} \cdot |1\rangle \right)
$$

Let $\theta,\varphi$ such that

$$
  \hat{n} =: (\sin\theta \cos\varphi,\; \sin\theta \sin\varphi,\; \cos\theta)
$$

Let us abbreviate $c=\cos(\theta/2)$, $s=\sin(\theta/2)$. By the usual trigonometric identities we have:

$$
  \hat{n} = (2sc\cos(\varphi), 2sc\sin(\varphi), c^2 - s^2)
$$

Plugging this into the above formula for $v_+$ we see that indeed

$$ |\psi\rangle = c |0\rangle + e^{i\varphi}s |1\rangle $$

which proofs the claim. QED.

****** Conclusion
(F) proves the claim QED[exercise 4.6].

**** Exercise 4.7
Show that $XYX = - Y$ and use this to prove that $X R_y(\theta)X = R_y(-\theta)$.

*Solution:* Follows from $(XY)X = iZX = i^2Y$ (see [[id:8fd70970-1282-4a24-ab47-5eecf832498f][Pauli Matrices]]).
**** Exercise 4.8
An arbitrary single qubit unitary operator can be written in the form

$$ U = \exp(i\alpha) R_{\hat{n}} (\theta) $$

for some real numbers $\alpha$ and $\theta$, and a real three-dimensional unit vector $\hat{n}$.

1. Prove this fact.
2. Find values for the Hadamard gate $H$.
3. Find values for the phase gate $S = \sqrt{Z}$.

***** Proof of 1
:PROPERTIES:
:CUSTOM_ID: exercise-4-8-part-1
:END:
PROOF: Clearly every unitary Matrix has the form:

$$
  U = e^{i\gamma} \begin{pmatrix} e & -\overline{f} \\ f & \overline{e} \end{pmatrix}
  \text{ where } |e|^2 + |f|^2 = 1,
$$

since the columns have to be orthogonal. In the following we show that the rotation operators are
*characterized* as those unitary operators which look like the RHS without the phase factor.

We have:

$$
R_{\hat{n}}(\theta) = e^{-i\theta N/2} = \left(\begin{matrix}
  \cos(\theta/2) - iz \sin(\theta/2) & -i\overline{a} \sin(\theta/2) \\
  -ia \sin(\theta/2) & \cos(\theta/2) + iz \sin(\theta/2) \end{matrix}\right)
$$

where $\hat{n} = (x, y, z)$ and $a = x + iy$. It is sufficient to show that the First column of the
rotation opterator can be made equal to $(e, f)$, since the second column of $U$ is fixed
by unitarity - up to a phase factor (this is where the $\alpha$ kicks in).

Abbreviating $\zeta = \cos(\theta/2) - iz \sin(\theta/2)$ and decomposing $a = e^{i\varphi}|a|$ we
see that the first columnt of the rotation is:

$$ (\zeta, -i e^{i \varphi} \sqrt{1 - |\zeta|^2}) $$

Clearly $\zeta$ can be chosen to be any complex number with modulus at most $1$. Once this is fixed,
the second component can be made any number with modulus $\sqrt{1-|\zeta|^2}$. Hence the system

\begin{align*}
  \alpha &= \gamma \\
  \zeta &= e \\
  -i e^{i\varphi} &= f/|f| \text{ if } f \neq 0
\end{align*}

has a (unique) solution, which proves the claim. QED.

***** Part 2
We follow the proof of Part 1 and first represent $H$ in this special form:

$$
  H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}
    = \frac{i}{\sqrt{2}} \begin{pmatrix} -i & -i \\ -i & i \end{pmatrix}
$$

Hence $\zeta=-i/\sqrt{2}$ and $e^{i\varphi}=1$. This in turn leads to $x=z=1/\sqrt{2}$, $z=0$ and
$\theta=\pi$. In other words:

$$
  H = i R_{(\hat{x}+\hat{z})/\sqrt{2}}(\pi) = \frac{1}{\sqrt{2}} \left( X + Z \right).
$$

***** Part 3
Recall $Z = i R_z(\pi)$, hence:

$$ S = e^{i\pi/4} R_z(\pi/2). $$

**** Exercise 4.9
Explain why any single qubit unitary operator may be written in the form (4.12).

*Solution:* This essentially follows from the first lines of the proof of part 1 in [[#exercise-4-8-part-1][exercise 4.8]]
(representation of $U$).

**** Exercise 4.10
Give a decomposition analogous to Theorem 4.1 but using $R_x$ instead of $R_z$.

***** Solution
By Theorem 4.1 we find the following representation of $HUH$:

$$
  HUH = e^{i\alpha} R_z(\beta)\cdot R_y(\gamma)\cdot R_z(\delta)
$$

Conjugating this again with $H$ we get:

$$
  U = e^{i\alpha} R_x(\beta)\cdot R_y(-\gamma)\cdot R_x(\delta)
$$

QED.

**** Exercise 4.11
Suppose $\hat{m}$ and $\hat{n}$ are non-parallel real unit vectors in three dimensions. Use Theorem 4.1 to show that
an arbitrary single qubit unitary $U$ may be written

$$
  U = e^{i\alpha} R_{\hat{n}}(\beta) R_{\hat{m}}(\gamma) R_{\hat{n}}(\delta)
$$

for appropriate choices of α, β, γ and δ.

# No idea how to prove it directly from Theorem 4.1.

***** Proof
Since we consider only products of Gates we may identify Gates resp. Qubits which are equivalent up
to a phase factor. That is we work on the quotient space $\CC^2/\CC$ for the Qubits and
$\CC^{2\times2}/\CC$ for the Gates.

We have to proof that:

$$
  U \equiv R_{\hat{n}}(\beta) R_{\hat{m}}(\gamma) R_{\hat{n}}(\delta)
$$

In exercise 4.8 we proved that $U\equiv R_{\hat{k}}(\varepsilon)$ for some axis and angle. Let us
denote by $r$ the (ordinary) rotations in the Bloch Sphere. By exercise 4.6 we know that the quantum
roations are isomorphic to the corresponding ordinary rotations. That is, we have to show:

$$
  r_{\hat{k}}(\varepsilon) = r_{\hat{n}}(\beta) r_{\hat{m}}(\gamma) r_{\hat{n}}(\delta) .
$$

On the other hand this is a well known fact about the group of rotations (real orthogonal matrices
with determinant equal to 1) in three dimensions. We prove it here anyway:

The above equation is equivalent to

$$
   r_{\hat{n}}(-\beta) = r_{\hat{m}}(\gamma) r_{\hat{n}}(\delta) r_{\hat{k}}(-\varepsilon) .
$$

Since $\beta$ is a free parameter it suffices to show that the RHS maps $\hat{n}$ to itself, for
appropriate choices of $\gamma$ and $\delta$. Therefore let $\hat{t} = r_{\hat{k}}(-\varepsilon)\hat{n}$ and consider:

$$
  \hat{n} = r_{\hat{m}}(\gamma) r_{\hat{n}}(\delta) \hat{t} .
$$

Consider the Meridian $M_1$ around $\hat{n}$ which contains $\hat{t}$ and the Meridian $M_2$ around
$\hat{m}$ which contains $\hat{n}$. Since the two axes are not parallel the two Meridians have two
intersection points $a$ and $b$ (they can be equal in the trivial case $\hat{t}=\hat{n}$). Clearly
we can choose $\delta$ in such a way that $\hat{t}$ moves to one of the intersection points, say
$a$. Now, by definition of $M_2$ we can choose $\gamma$ in sich a way that $a$ moves to $\hat{n}$. QED.

**** Exercise 4.12
Give A, B, C, and α (in Corollary 4.2) for the Hadamard gate.

***** Solution
First let us find the parameters in

$$
  H = e^{i\alpha} R_z(\beta) R_y(\gamma) R_z(\delta)
$$

The RHS is given explicitly in (4.12) from where it is immediat that $\gamma=\pi/2$. The other three
parameters satisfy a linear system of equations, which can be solved easily: $\alpha=\pi/2$,
$\beta=0$, and $\delta=\pi$.

Hence:

\begin{align*}
  A &= R_z(\beta) R_y(\gamma/2) = R_y(\pi/4) = \frac{1}{2}
    \begin{pmatrix}
      \sqrt{\sqrt{2} + 2} & - \sqrt{2 - \sqrt{2}} \\
      \sqrt{2 - \sqrt{2}} & \sqrt{\sqrt{2} + 2}
    \end{pmatrix} \\
  B &= R_y(-\gamma/2) R_z(-(\delta + \beta)/2) = R_y(-\pi/4) R_z(-\pi/2) = \frac{1}{2}
    \begin{pmatrix}
      e^{\frac{i\pi}{4}} \sqrt{\sqrt{2} + 2} & e^{-\frac{i\pi}{4}} \sqrt{2 - \sqrt{2}} \\
      - e^{\frac{i\pi}{4}} \sqrt{2 - \sqrt{2}} & e^{-\frac{i\pi}{4}} \sqrt{\sqrt{2} + 2}
    \end{pmatrix} \\
  C &= R_z((\delta - \beta)/2) = R_z(\pi/2) =
    \begin{pmatrix}
      e^{- \frac{i \pi}{4}} & 0 \\
      0 & e^{\frac{i \pi}{4}}
    \end{pmatrix}
\end{align*}
**** Exercise 4.13
It is useful to be able to simplify circuits by inspection, using well-known identities. Prove the
following three identities:

$$ X = HZH,\quad Z = HXH,\quad Y = - HYH $$

***** Proof
The first two identities follow from the fact that $H$ is (unitary and) self-adjoint and contains
eigenvectors of $X$ as columns (and rows). The third identity follows from

$$ H = \frac{1}{\sqrt{2}} \left( X + Z \right). $$

and the commutator properties of the Paulis, e.g. $XY=iZ$ and its cyclic variations. Of course the
first two identities could also be proved like that.
**** Exercise 4.14
Use the previous exercise to show that $HTH=R_x(\pi/4)$, up to a global phase.

***** Proof
This follows from $T\equiv R_z(\pi/4)$ (up to phase factor) and $HZH=X$.
**** Exercise 4.15
The Bloch representation gives a nice way to visualize the effect of composing two rotations.

1. Prove that if a rotation through an angle β1 about the axis n̂1 is followed by a
rotation through an angle β2 about an axis n̂2 , then the overall rotation is through an angle β12
about an axis n̂12 given by

\begin{align*}
  c_{12} &= c_1 c_2 - s_1 s_2 \; \hat{n}_1 \cdot \hat{n}_2 \\
  s_{12} \hat{n}_{12} &= s_1 c_2 \; \hat{n}_1 + c_1 s_2 \; \hat{n}_2 + s_1 s_2 \; \hat{n}_2 \times \hat{n}_1 ,
\end{align*}

where $c_i=\cos(\beta_i/2)$, $s_i=\sin(\beta_i/2)$, $c_{12}=\cos(\beta_{12}/2)$, and $s_{12}=\sin(\beta_{12}/2)$.

2. Show that if β1 = β2 and n̂1 = ẑ these equations simplify to

\begin{align*}
  c_{12} &= c_2 − s_2 \; \hat{z} \cdot \hat{n}_2 \\
  s_{12} \hat{n}_12 &= sc \; (\hat{z} + \hat{n}_2) + s_2 \; \hat{n}_2 \times \hat{z} ,
\end{align*}

where $c=c_1$ and $s=s_1$.

*Remark:* /It seems/ (if we did no mistake) that there is a typo in the original formula for
$s_{12}\hat{n}_{12}$. We corrected this (hopefully).

***** Proof
We only proof the first assertion since the second one follows trivially from the first.

We use the previously established fact that the 3D-rotations are isomorphic to the Pauli rotation
operators (exercise 4.6). Along that way we essentially establish the relation between Quaternions
and 3D rotations (and Pauli rotations).

For a vector $\hat{n}$ let us define $N_{\hat{n}}=-i(n_1X+n_2Y+n_3Z)$. The composition of the two
rotations is given by:

$$
  (c_{12} + s_{12} N_{\hat{n}_{12}}) = (c_2 + s_2 N_{\hat{n}_2}) \cdot (c_1 + s_1 N_{\hat{n}_1}) .
$$

To spare us from the tedious work to expand the RHS by hand we use sympy for that. We are only
interested in algebraic operations and in particular we don't want to see any cumbersome matrix
expression. To help sympy we use the fact that the Quaterions can be modelled by the Pauli
Matrices. Just use the Identity matrix as the unit (the real number 1) and $-iX$, $-iY$, $-iZ$ as
the three imaginary units. Keep in mind that we only use the Quaterions as a trick to tell sympy
that we are not interested in Matrices. Essentially we still use the Pauli Rotations to prove the
claim.

#+name: exercise-4.15
#+begin_src python :results replace
  from sympy import Quaternion

  x1, y1, z1 = sp.symbols('x1 y1 z1')
  x2, y2, z2 = sp.symbols('x2 y2 z2')
  c1, c2, s1, s2 = sp.symbols('c1 c2 s1 s2')

  N1 = Quaternion(0, x1, y1, z1)
  N2 = Quaternion(0, x2, y2, z2)

  R1 = c1 + s1*N1
  R2 = c2 + s2*N2

  R2 * R1
#+end_src

#+RESULTS: exercise-4.15
: (c1*c2 - s1*s2*x1*x2 - s1*s2*y1*y2 - s1*s2*z1*z2) + (c1*s2*x2 + c2*s1*x1 - s1*s2*y1*z2 + s1*s2*y2*z1)*i + (c1*s2*y2 + c2*s1*y1 + s1*s2*x1*z2 - s1*s2*x2*z1)*j + (c1*s2*z2 + c2*s1*z1 - s1*s2*x1*y2 + s1*s2*x2*y1)*k

Rearranging the result for better readability:

#+begin_example
(c1*c2 - s1*s2*x1*x2 - s1*s2*y1*y2 - s1*s2*z1*z2)
+ (c1*s2*x2 + c2*s1*x1 - s1*s2*y1*z2 + s1*s2*y2*z1)*i
+ (c1*s2*y2 + c2*s1*y1 + s1*s2*x1*z2 - s1*s2*x2*z1)*j
+ (c1*s2*z2 + c2*s1*z1 - s1*s2*x1*y2 + s1*s2*x2*y1)*k
#+end_example

From here we can directly read out the claim! QED.

**** Exercise 4.16
What is the 4×4 unitary matrix for the following circuits

#+RESULTS: exercise-4.16-appendix
#+begin_example

q_0: ─────
     ┌───┐
q_1: ┤ H ├
     └───┘

     ┌───┐
q_0: ┤ H ├
     └───┘
q_1: ─────
#+end_example

***** Solution
According the convention of the book, these two circuits are represented by $I\otimes H$,
$H\otimes I$ (in that order). We note here that Qiskit uses the reverse order. The Kronecker Product
yields the matrices (since the basis vectors are ordered in a canonical way: 00, 01, 10, 11):

$$
  I\otimes H = \frac{1}{\sqrt{2}}
  \,\begin{bmatrix}
    1 &  1 & 0 &  0 \\
    1 & -1 & 0 &  0 \\
    0 &  0 & 1 &  1 \\
    0 &  0 & 1 & -1
  \,\end{bmatrix}
$$

$$
  H\otimes I = \frac{1}{\sqrt{2}}
  \,\begin{bmatrix}
    1 & 0 &  1 &  0 \\
    0 & 1 &  0 &  1 \\
    1 & 0 & -1 &  0 \\
    0 & 1 &  0 & -1
  \,\end{bmatrix}
$$

***** Appendix
Code which produces the circuits:

#+name: exercise-4.16-appendix
#+begin_src python :results output replace
  qc1 = QuantumCircuit(2)
  qc1.h(1)

  qc2 = QuantumCircuit(2)
  qc2.h(0)

  print(qc1.draw('text'), "\n")
  print(qc2.draw('text'))
#+end_src

**** Exercise 4.17
Construct a =CNOT= (CX) gate from a =CZ= using two Hadamard Gates.

***** Solution
The general form of a CU-gate is ($P_j$ being projections):

$$
  \CU = P_1 \otimes I + P_2 \otimes U
$$

Hence by $HZH=X$:

$$
  CX = I\otimes H \cdot CZ \cdot I\otimes H
$$

**** Exercise 4.18
Show that swapping the two qubits leaves $\CZ$ invariant. That is, these two circuits are equal:

#+begin_example

q_0: ──■──
     ┌─┴─┐
q_1: ┤ Z ├
     └───┘

     ┌───┐
q_0: ┤ Z ├
     └─┬─┘
q_1: ──■──
#+end_example

For this reason, the $CZ$ is often denoted in a symmetric form:

#+RESULTS: exercise-4.18-appendix
:
: q_0: ─■─
:       │
: q_1: ─■─


***** Proof
This follows from

$$
  \CZ = P_1 \otimes I + P_2 \otimes Z = I \otimes P_1 + Z \otimes P_2 .
$$

***** Appendix
Code which produces the circuits (at least the plot of the symmetric CZ gate):

#+name: exercise-4.18-appendix
#+begin_src python :results output replace
  qc = QuantumCircuit(2)
  qc.cz(0, 1)

  print(qc.draw('text'))
#+end_src

**** Exercise 4.19
The gate is a simple permutation whose action on a density matrix ρ is to rearrange the elements in
the matrix. Write out this action explicitly in the computational basis.

***** Solution
The density matrix for two qubits in the computational basis looks as follows:

$$
  \rho = \sum_{i,j=0}^1 p_{ij} |ij\rangle .
$$

$\CX$ maps $|0j\rangle$ to itself, and it swaps $|10\rangle$ with $|11\rangle$. Hence, as a mapping
on the density matrix it acts as follows on the density matrix:

$$
  p_{0i} \mapsto p_{0i},\quad p_{10} \mapsto p_{11},\quad p_{11} \mapsto p_{10} .
$$

**** Exercise 4.20
Show that the following two circuits are equal:

#+RESULTS: exercise-4.20-appendix
:      ┌───┐     ┌───┐
: q_0: ┤ H ├──■──┤ H ├
:      ├───┤┌─┴─┐├───┤
: q_1: ┤ H ├┤ X ├┤ H ├
:      └───┘└───┘└───┘
:      ┌───┐
: q_0: ┤ X ├
:      └─┬─┘
: q_1: ──■──


Moreover the effect of the CX gate on the eigenbasis of $X$ is as follows:

$$
  \,|\pm+\rangle \mapsto |\pm+\rangle,\quad |\pm-\rangle \mapsto |\mp-\rangle
$$

In other words: With respect to the eigenbasis of $X$ the CX gate acts again like a CX gate but with
the control and target qubit switched.

# TODO: make drawings of the circuits.

***** Proof
The statement after "Moreover" is direct consequence of the first statement. Therefore we only prove
the first one.

We have to show that $H\otimes H \cdot CX \cdot H\otimes H$ is the CX gate with the qubits reversed.

First, let us recall the projections on the eigenbasis of $X$:

\begin{align*}
  P_+ &= |+\rangle \otimes \langle+| = \begin{bmatrix} 1 & 1 \\ 1 & 1 \end{bmatrix}, \\
  P_- &= |-\rangle \otimes \langle-| = \begin{bmatrix} 1 & -1 \\ -1 & 1 \end{bmatrix}.
\end{align*}

Consider

$$
  H\otimes H \cdot CX \cdot H\otimes H = P_+ \otimes I + P_- \otimes Z .
$$

We have to show that, after swapping the two qubits the RHS equals $CX$. In fact:

$$
  I \otimes P_+ + Z \otimes P_- = \frac{1}{2}
      \,\begin{bmatrix}
         1 &  1 &  0 &  0 \\
         1 &  1 &  0 &  0 \\
         0 &  0 &  1 &  1 \\
         0 &  0 &  1 &  1
      \,\end{bmatrix}
    \,+ \frac{1}{2}
      \,\begin{bmatrix}
         1 & -1 &  0 &  0 \\
        -1 &  1 &  0 &  0 \\
         0 &  0 & -1 &  1 \\
         0 &  0 &  1 & -1
      \,\end{bmatrix}
    =
      \,\begin{bmatrix}
        1 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 \\
        0 & 0 & 0 & 1 \\
        0 & 0 & 1 & 0
      \,\end{bmatrix} = \CX .
$$

***** Appendix
Code which produces the circuits:

#+name: exercise-4.20-appendix
#+begin_src python :results output replace
  qc1 = QuantumCircuit(2)
  qc1.h(0)
  qc1.h(1)
  qc1.cx(0, 1)
  qc1.h(0)
  qc1.h(1)

  qc2 = QuantumCircuit(2)
  qc2.cx(1, 0)

  print(qc1.draw('text'))
  print(qc2.draw('text'))
#+end_src

**** Exercise 4.21
Verify that Figure 4.8 implements the $C^2(U)$ operation.

***** Solution
The easiest solution might be to just try out all four possibilities to plugin the computational
basis into the first two wires.

Another approach is to just calculate the corresponding algebraic expression:

\begin{align*}
        &(P_0 \otimes I \otimes I + P_1 \otimes I \otimes V) \\
  \cdot &(P_0 \otimes I \otimes I + P_1 \otimes X \otimes I) \\
  \cdot &(I \otimes P_0 \otimes I + I \otimes P_1 \otimes V^\dagger) \\
  \cdot &(P_0 \otimes I \otimes I + P_1 \otimes X \otimes I) \\
  \cdot &(I \otimes P_0 \otimes I + I \otimes P_1 \otimes V)
\end{align*}

Using $XP_0X=P_1$ and $XP_1X=P_0$ we get, that this is:

$$
  P_0 \otimes P_0 \otimes I + P_1 \otimes P_0 \otimes I + P_0 \otimes P_1 \otimes I + P_1 \otimes P_1 \otimes V^2 .
$$

Which is indeed $C^2(U)$.

**** Exercise 4.22
Prove that a $C^2(U)$ gate (for any single qubit unitary $U$) can be constructed using at most eight
one-qubit gates, and six $\CX$.

***** Proof
If we combine the construction of $C^2(U)$ from figure 4.8 (the $U=V^2$ thing) with the construction
of $C(U)$ from figure 4.6 (the $AXBXC=U$ thing), we immediately see that we can construct a circuit
with six $CX$ and ten one-qubit gates (two of the three phase gates cancel each other). However, we
can reduce the number of one qubit gates by two, since two pairs can actually be merged into a
single one-qubit operator.

**** Exercise 4.23
Construct a $C^1(U)$ gate for $U=R_x(\theta)$ and $U=R_y(\theta)$, using only CNOT and single qubit
gates. Can you reduce the number of single qubit gates needed in the construction from three to two?

***** Solution
For the y-rotation this is easy:

$$
  C^1(R_y(\theta)) = \CX \cdot R_{y,2}(-\theta/2) \cdot \CX \cdot R_{y,2}(\theta/2) .
$$

: q_0: ─────────────■────────────────■──
:      ┌─────────┐┌─┴─┐┌──────────┐┌─┴─┐
: q_1: ┤ Rx(θ/2) ├┤ X ├┤ Rx(-θ/2) ├┤ X ├
:      └─────────┘└───┘└──────────┘└───┘

We get the same result if we use the proof of Corollary 4.2. For the x-rotation we first deduce from
exercise 4.6 (interpretation as 3D rotations):

$$
  R_x(\theta) = R_z(-\pi/2) \cdot R_y(\theta) \cdot R_z(\pi/2) .
$$

Now the proof of Corollary 4.2 shows:

$$
  C^1(R_x(\theta)) = R_{z,2}(-\pi/2) \CX \cdot R_{y,2}(-\theta/2) \cdot \CX \cdot R_{z,2}(-\pi/2) R_{y,2}(\theta/2) .
$$

: q_0: ─────────────────────────■────────────────■──────────────
:      ┌─────────┐┌──────────┐┌─┴─┐┌──────────┐┌─┴─┐┌──────────┐
: q_1: ┤ Ry(θ/2) ├┤ Rz(-π/2) ├┤ X ├┤ Ry(-θ/2) ├┤ X ├┤ Rz(-π/2) ├
:      └─────────┘└──────────┘└───┘└──────────┘└───┘└──────────┘

***** Appendix
The code for the circuit plots:

#+name: exercise-4.22-appendix
#+begin_src python :results output replace :exports code
  qc1 = QuantumCircuit(2)
  qc1.rx(123, 1)  # modify angle in plot
  qc1.cx(0, 1)
  qc1.rx(1234, 1)  # modify angle in plot
  qc1.cx(0, 1)

  qc2 = QuantumCircuit(2)
  qc2.ry(123, 1)  # modify angle in plot
  qc2.rz(1234, 1)  # modify angle in plot
  qc2.cx(0, 1)
  qc2.ry(1234, 1)  # modify angle in plot
  qc2.cx(0, 1)
  qc2.rz(1234, 1)  # modify angle in plot

  print(qc1.draw('text'))
  print(qc2.draw('text'))
#+end_src

#+RESULTS: exercise-4.22-appendix
#+begin_example

q_0: ─────────────■────────────────■──
     ┌─────────┐┌─┴─┐┌──────────┐┌─┴─┐
q_1: ┤ Rx(123) ├┤ X ├┤ Rx(1234) ├┤ X ├
     └─────────┘└───┘└──────────┘└───┘

q_0: ─────────────────────────■────────────────■──────────────
     ┌─────────┐┌──────────┐┌─┴─┐┌──────────┐┌─┴─┐┌──────────┐
q_1: ┤ Ry(123) ├┤ Rz(1234) ├┤ X ├┤ Ry(1234) ├┤ X ├┤ Rz(1234) ├
     └─────────┘└──────────┘└───┘└──────────┘└───┘└──────────┘
#+end_example

**** Exercise 4.24
Verify that Figure 4.9 implements the Toffoli gate.

***** Proof
Preliminaries: Recall that $T=e^{i\pi/8}R_z(\pi/4)$ and $XZX=-Z$. It suffices to prove the claim for
states of the form $|ij\rangle\otimes|\psi\rangle$ (the basis states in the first two wires), by
linearity.

The first wire always acts as $T$. This does nothing to $|0\rangle$ and applies a phase shift to $|1\rangle$.

Now we consider the first two wires (the upper wires) states of the form $|01\rangle$ (that is, the
control qubit is turned off). Then, the second wire acts as $ST^\dagger T^\dagger=I$. Hence
$|01\rangle$ is mapped to itself. Now consider $|1i\rangle$. The second wire now acts as

$$
  SX T\dagger XT\dagger = e^{-i\pi/4} S XR_z(\pi/4)XR_z(\pi/4) = e^{-i\pi/4} S .
$$

Hence $|1i\rangle$ is mapped to $|1\rangle\otimes S|i\rangle$. We summarize: The first two wires act as:

$$
  \,|ij\rangle \mapsto \begin{cases}
      i|11\rangle  & \text{if } i=j=1 \\
      \,|ij\rangle & \text{else.}
  \,\end{cases}
$$

Now consider the third wire. It is not hard to see that if one of the first two qubits is
$|0\rangle$, then all operators cancel each other (equalize to $I$) due to $X^2=-1$ and $T^\dagger T=I$.

So the only interesting case is if the first to qubits are both on (equal state 1). In that case we
have to show that the operator in the third row is equal to $-iX$. We have:

$$
  T X T^\dagger X = R_z(\pi/4) X R_z(-\pi/4) X = R_z(\pi/2) .
$$

Hence the operator in the third row is:

$$
  H R_z(\pi/2) R_z(\pi/2) H = R_x(\pi) = -iX.
$$

QED.

**** TODO Exercise 4.25 [3/4]
Recall that the Fredkin (controlled-swap) gate performs the transform:

\begin{bmatrix}
  1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
  0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
  0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
  0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
  0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
  0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix}


1. [X] Give a quantum circuit which uses three Toffoli gates to construct the Fredkin gate (Hint: think
   of the swap gate construction – you can control each gate, one at a time).
2. [X] Show that the first and last Toffoli gates can be replaced by gates.
3. [X] Now replace the middle Toffoli gate with the circuit in Figure 4.8 to obtain a Fredkin gate
   construction using only six two-qubit gates.
4. [ ] Can you come up with an even simpler construction, with only five two-qubit gates?

***** Solution to 1
Taking the swap-gate construction from Figure 1.7 we may deduce that the following circuit might do
what we want:

#+RESULTS: exercise-4-25-appendix-1
:
: q_0: ──■────■────■──
:        │  ┌─┴─┐  │
: q_1: ──■──┤ X ├──■──
:      ┌─┴─┐└─┬─┘┌─┴─┐
: q_2: ┤ X ├──■──┤ X ├
:      └───┘     └───┘

In fact, a short calculation yields the desired result.

#+begin_src python
  T01 = make_CnU(3, [0, 1], 2, X)
  T02 = make_CnU(3, [0, 2], 1, X)

  assert T01 * T02 * T01 == Fred, "Exercise 4.25, Solution to 1."
#+end_src

***** Solution to 2
The following circuit equals the Fredkin Gate too:

#+RESULTS: exercise-4-25-appendix-2
:
: q_0: ───────■───────
:           ┌─┴─┐
: q_1: ──■──┤ X ├──■──
:      ┌─┴─┐└─┬─┘┌─┴─┐
: q_2: ┤ X ├──■──┤ X ├
:      └───┘     └───┘

In fact:

#+begin_src python
  C12 = make_CU(3, 1, 2, X)

  assert C12 * T02 * C12 == Fred, "Exercise 4.25, Solution to 2."
#+end_src

***** Solution to 3
Apriori this new circuit uses 8 = 6 + 2 two-qubit gates. However the first two of these can be
merged into one (together with the Hadamard in between). Observe that the a similar fact is true for
the last two two-qubit gates of the construction from Figure 4.9. Hence we only need 6 such gates.

***** Solution to 4
So far I have no solution. My first guess was to use the construction from Firgure 4.8 (the thing
with $V^2=X$). With the same trick as in Solution 3 (merging adjacent gates) one gets a solution
with 6 two-qubit gates. I tried to move around gates at the right end (via commutator relations)
hoping the find an equivalent circuit with on gate less - so far without success.

***** Appendix
This code produces the images to the solutions.

#+name: exercise-4-25-appendix-1
#+begin_src python :results output replace :exports both
  qc1 = QuantumCircuit(3)
  qc1.ccx(0, 1, 2)
  qc1.ccx(0, 2, 1)
  qc1.ccx(0, 1, 2)

  print(qc1.draw('text'))
#+end_src

#+name: exercise-4-25-appendix-2
#+begin_src python :results output replace :exports both
  qc2 = QuantumCircuit(3)
  qc2.cx(1, 2)
  qc2.ccx(0, 2, 1)
  qc2.cx(1, 2)

  print(qc2.draw('text'))
#+end_src



** Chapter 5
  :PROPERTIES:
  :header-args:python: :session *chapter-5* :tangle yes :comments link :results silent
  :END:
*** notes
#+name: dummy
#+begin_src python :results replace
  test = 123
  test
#+end_src

#+RESULTS: dummy
: 123
