<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 9</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 9</h1>\[
\newcommand{\BB}{\mathbb{B}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\HH}{\mathbb{H}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\jj}{\mathrm{j}}
\newcommand{\kk}{\mathrm{k}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\RF}{\mathrm{RF}}
\newcommand{\sys}{\mathrm{sys}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\cx}{\mathrm{CX}}
\newcommand{\cy}{\mathrm{CY}}
\newcommand{\cz}{\mathrm{CZ}}
\newcommand{\cat}{\ket{\mathrm{cat}}}
\newcommand{\catp}[1]{\ket{\mathrm{cat}_{#1}}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % deprecated, use braket instead.
\newcommand{\braket}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\rank}[1]{\mathrm{rank}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\wt}[1]{\mathrm{wt}\left(#1\right)}
\newcommand{\prob}[1]{\mathrm{Prob}\left[#1\right]}
\newcommand{\orac}{\mathrm{Orac}}
\newcommand{\?}{} % sometimes I need just a separator other than whitespace
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1a01d0f">Setup</a>
<ul>
<li><a href="#orgb0d6dad">Imports</a></li>
</ul>
</li>
<li><a href="#orgd849136">Exercises</a>
<ul>
<li><a href="#orge87f82a">Exercise 9.1</a></li>
<li><a href="#org1a99238">Exercise 9.2</a></li>
<li><a href="#org05a76b0">Exercise 9.3</a></li>
<li><a href="#exercise-9.4">Exercise 9.4</a></li>
<li><a href="#orgb73a20b">Exercise 9.5</a></li>
<li><a href="#orgb20599e">Exercise 9.6</a></li>
<li><a href="#org0d214dc">Exercise 9.7</a></li>
<li><a href="#org707d177">Exercise 9.8 (Convexity of the trace distance)</a></li>
<li><a href="#exercise-9.9">Exercise 9.9 (Existence of fixed points)</a></li>
<li><a href="#exercise-9.10">Exercise 9.10</a></li>
<li><a href="#orgf55407c">Exercise 9.11</a></li>
<li><a href="#orga96308a">Exercise 9.12</a></li>
<li><a href="#orgee79254">Exercise 9.13</a></li>
<li><a href="#org3d5f987">Exercise 9.14 (Invariance of fidelity under unitary transforms)</a></li>
<li><a href="#orgb752f6e">Exercise 9.15</a></li>
<li><a href="#orgbe8d046">Exercise 9.16 (The Hilbert–Schmidt inner product and entanglement)</a></li>
<li><a href="#org9f152b7">Exercise 9.17</a></li>
<li><a href="#org4ad7da8">Exercise 9.18 (Contractivity of the angle)</a></li>
<li><a href="#exercise-9.19">Exercise 9.19 (Joint concavity of fidelity)</a></li>
<li><a href="#org1ad1133">Exercise 9.20 (Concavity of fidelity)</a></li>
<li><a href="#orgf08ec81">Exercise 9.21</a></li>
<li><a href="#orgdfb757f">Exercise 9.22 (Chaining property for fidelity measures)</a></li>
<li><a href="#orga1cef55">Exercise 9.23</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1a01d0f" class="outline-2">
<h2 id="org1a01d0f">Setup</h2>
<div class="outline-text-2" id="text-org1a01d0f">
</div>
<div id="outline-container-orgb0d6dad" class="outline-3">
<h3 id="orgb0d6dad">Imports</h3>
<div class="outline-text-3" id="text-orgb0d6dad">
<div class="org-src-container">
<pre class="src src-sage" id="org41cca44"><span class="org-keyword">from</span> utils_sage <span class="org-keyword">import</span> ket
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd849136" class="outline-2">
<h2 id="orgd849136">Exercises</h2>
<div class="outline-text-2" id="text-orgd849136">
</div>
<div id="outline-container-orge87f82a" class="outline-3">
<h3 id="orge87f82a">Exercise 9.1</h3>
<div class="outline-text-3" id="text-orge87f82a">
<p>
What is the trace distance between the probability distribution \((1,0)\) and the probability
distribution \((1/2,1/2)\)? Between \((1/2,1/3,1/6)\) and \((3/4,1/8,1/8)\)?
</p>
</div>

<div id="outline-container-orge87c38c" class="outline-4">
<h4 id="orge87c38c">Solution</h4>
<div class="outline-text-4" id="text-orge87c38c">
<p>
We have
</p>

<p>
\[
  D((1,0), (1/2,1/2)) = \frac{1}{2} ( 1/2 + 1/2 ) = \frac{1}{2} ,
\]
</p>

<p>
and
</p>

<p>
\[
  D((1/2,1/3,1/6), (3/4,1/8,1/8)) = \frac{1}{2} ( 1/4 + 5/24 + 1/24 ) = \frac{1}{4} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org1a99238" class="outline-3">
<h3 id="org1a99238">Exercise 9.2</h3>
<div class="outline-text-3" id="text-org1a99238">
<p>
Show that the trace distance between probability distributions \((p,1-p)\) and \((q,1-q)\) is
\(\abs{p-q}\).
</p>
</div>

<div id="outline-container-orgda5b6b5" class="outline-4">
<h4 id="orgda5b6b5">Proof</h4>
<div class="outline-text-4" id="text-orgda5b6b5">
<p>
\[
  D((p,1-p), (q, 1-q)) = \frac{1}{2} (\abs{p-q} + \abs{1-p-1+q}) = \abs{p-q} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org05a76b0" class="outline-3">
<h3 id="org05a76b0">Exercise 9.3</h3>
<div class="outline-text-3" id="text-org05a76b0">
<p>
What is the fidelity of the probability distributions \((1,0)\) and \((1/2,1/2)\)? Of
\((1/2,1/3,1/6)\) and \((3/4,1/8,1/8)\)?
</p>
</div>

<div id="outline-container-org7318be3" class="outline-4">
<h4 id="org7318be3">Solution</h4>
<div class="outline-text-4" id="text-org7318be3">
<p>
We have
</p>

<p>
\[
  F((1,0), (1/2,1/2)) = \sqrt{1\cdot1/2} + 0 = \sqrt{2\inv}
\]
</p>

<p>
and
</p>

<p>
\[
  F((1/2,1/3,1/6), (3/4,1/8,1/8)) = \sqrt{3/8} + \sqrt{1/24} + \sqrt{1/48}
  = \frac{1 + 4\sqrt{2}}{4\sqrt{3}} \approx 0.961 .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-9.4" class="outline-3">
<h3 id="exercise-9.4">Exercise 9.4</h3>
<div class="outline-text-3" id="text-exercise-9.4">
<p>
Prove (9.3):
</p>

<p>
\[
  D(p, q) = \max_S \abs{p(S)-q(S)} = \max_S \abs{\sum_{x\in S} (p_x - q_x)} .
\]
</p>
</div>

<div id="outline-container-org449606f" class="outline-4">
<h4 id="org449606f">Proof</h4>
<div class="outline-text-4" id="text-org449606f">
<p>
Let \(J\) be the index set of the probability distribution (I mean: when we write \(p_x\) the
\(x\) is from \(J\)). For a set \(S\subset\?J\) let \(s\) be its 0-1-encoding, that is, \(s_x=1\)
iff \(x\in\?S\). Clearly \(p(S)=p\cdot s\) if we write \(p\cdot\?s=\sum_xp_xs_x\). Let us
calculate:
</p>

\begin{align*}
  \max_S \abs{p(S) - q(S)} &= \max_s \abs{(p-q)\cdot s} \\
  &= \max_s \abs{(p-q)\cdot (s - 2\inv)} \\
  &= \max_t \abs{(p-q)\cdot t} \\
  &\leq \norm{p-q}_1 \cdot \max \abs{t} \\
  &= D(p, q) .
\end{align*}

<p>
Here the \(\max_t\) runs over all \(t\) with \(t_x=\pm2\inv\) and \(\norm{p-q}_1=D(p,q)\) is the
L1-norm. For the second equality we used that \(\sum_xp_x=\sum_xq_x=1\). Note that the
inequality is just a basic version of <a href="https://en.wikipedia.org/wiki/H%C3%B6lder's_inequality">Hölder's inequality</a> (which can be seen directly of
course). Equality clearly holds for
</p>

<p>
\[
  t_x = \begin{cases} +2\inv & \text{for } p_x \geq q_x \\ -2\inv & \text{else.} \end{cases} .
\]
</p>

<p>
Equivalently (using the bijection \(t=s-2\inv\)):
</p>

<p>
\[
  s_x = \begin{cases} 1 & \text{for } p_x \geq q_x \\ 0 & \text{else.} \end{cases} .
\]
</p>

<p>
Note that one could also invert the cases (and treat \(p_x=q_x\) arbitrarily) but this
choice also shows that one can leave out the absolute values from the procedure. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb73a20b" class="outline-3">
<h3 id="orgb73a20b">Exercise 9.5</h3>
<div class="outline-text-3" id="text-orgb73a20b">
<p>
Show that the absolute value signs may be removed from Equation (9.3), that is,
</p>

<p>
\[
  D(p, q) = \max_S (p(S)-q(S)) = \max_S \left(\sum_{x\in S} (p_x - q_x)\right) .
\]
</p>
</div>

<div id="outline-container-orga541127" class="outline-4">
<h4 id="orga541127">Proof</h4>
<div class="outline-text-4" id="text-orga541127">
<p>
This statement was already proved in the solution of <a href="#exercise-9.4">exercise 9.4</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb20599e" class="outline-3">
<h3 id="orgb20599e">Exercise 9.6</h3>
<div class="outline-text-3" id="text-orgb20599e">
<p>
What is the trace distance between the density operators
</p>

<p>
\[
  \frac{3}{4}\proj{0} + \frac{1}{4}\proj{1} ; \;
  \frac{2}{3}\proj{0} + \frac{1}{3}\proj{1} ?
\]
</p>

<p>
Between:
</p>

<p>
\[
  \frac{3}{4}\proj{0} + \frac{1}{4}\proj{1} ; \;
  \frac{2}{3}\proj{+} + \frac{1}{3}\proj{-} ?
\]
</p>

<p>
(Recall that \(\ket{\pm}=(\ket{0}\pm\ket{1})/\sqrt{2}\).)
</p>
</div>

<div id="outline-container-org0985f06" class="outline-4">
<h4 id="org0985f06">Solution</h4>
<div class="outline-text-4" id="text-org0985f06">
<p>
For the commuting pair of density operators we have
</p>

<p>
\[
  D_1 = \frac{1}{2} \left(\abs{\frac{3}{4}-\frac{2}{3}} + \abs{\frac{1}{4}-\frac{1}{3}}\right)
  = \frac{1}{12} .
\]
</p>

<p>
Let us consider the second, more interesting example. To compute \(D_2=D(\rho,\sigma)\) we
could compute the eigenvalues \(\lambda_i\) of \(\rho-\sigma\). We then have
\(D_2=(\abs{\lambda_1}+\abs{\lambda_2})/2\).
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">plus</span> <span class="org-operator">=</span> matrix((ket(<span class="org-string">'0'</span>) <span class="org-operator">+</span> ket(<span class="org-string">'1'</span>))<span class="org-operator">/</span>sqrt(2))
<span class="org-variable-name">minus</span> <span class="org-operator">=</span> matrix((ket(<span class="org-string">'0'</span>) <span class="org-operator">-</span> ket(<span class="org-string">'1'</span>))<span class="org-operator">/</span>sqrt(2))

<span class="org-variable-name">rho</span> <span class="org-operator">=</span> matrix([[3<span class="org-operator">/</span>4, 0], [0, 1<span class="org-operator">/</span>4]])
<span class="org-variable-name">sigma</span> <span class="org-operator">=</span> (2<span class="org-operator">/</span>3)<span class="org-operator">*</span>plus.H<span class="org-operator">*</span>plus <span class="org-operator">+</span> (1<span class="org-operator">/</span>3)<span class="org-operator">*</span>minus.H<span class="org-operator">*</span>minus

<span class="org-comment-delimiter"># </span><span class="org-comment">To compute the distance we essentially have to compute the eigenvalues of rho - sigma</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">(and add their absolute values).</span>
<span class="org-variable-name">A</span> <span class="org-operator">=</span> rho <span class="org-operator">-</span> sigma
<span class="org-keyword">assert</span> A.eigenvalues() <span class="org-operator">==</span> [<span class="org-operator">-</span>1<span class="org-operator">/</span>12<span class="org-operator">*</span>sqrt(13), 1<span class="org-operator">/</span>12<span class="org-operator">*</span>sqrt(13)]

<span class="org-comment-delimiter"># </span><span class="org-comment">Just for fun: In this special case you can extract the relevant information from the</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">A.H*A since this one is already diagonal.</span>
<span class="org-variable-name">A2</span> <span class="org-operator">=</span> A.H <span class="org-operator">*</span> A
<span class="org-keyword">assert</span> A2 <span class="org-operator">==</span> (13<span class="org-operator">/</span>144) <span class="org-operator">*</span> matrix.diagonal([1, 1])
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Hence
</p>

<p>
\[
  D_2 = \frac{\sqrt{13}}{12} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org0d214dc" class="outline-3">
<h3 id="org0d214dc">Exercise 9.7</h3>
<div class="outline-text-3" id="text-org0d214dc">
<p>
Show that for any states \(\rho\) and \(\sigma\), one may write \(\rho-\sigma=Q-S\), where \(Q\)
and \(S\) are positive operators with support on orthogonal vector spaces. (Hint: use the
spectral decomposition \(\rho-\sigma=UDU^\dagger\), and split the diagonal matrix \(D\) into
positive and negative parts. This fact will continue to be useful later.)
</p>
</div>

<div id="outline-container-orgc8feaff" class="outline-4">
<h4 id="orgc8feaff">Proof</h4>
<div class="outline-text-4" id="text-orgc8feaff">
<p>
The exercise already outlines what to do. I just make it <i>a little bit</i> more precise. Let
\(D=\diag(\ldots,d_i,\ldots)\) be a diagonalization of \(\rho-\sigma\):
</p>

<p>
\[
  \rho - \sigma = U D U^\dagger
\]
</p>

<p>
Now rewrite \(D\) in terms of two other diagonal matrices
</p>

<p>
\[
  D = D_Q - D_S
\]
</p>

<p>
where \((D_Q)_{ii}=d_i\) if \(d_i\?>0\) and \((D_S)_{ii}=-d_i\) if \(d_i\?<0\) (and zeros
everywhere else). Now define
</p>

<p>
\[
  Q = U D_Q U^\dagger, \; S = U D_S U^\dagger .
\]
</p>

<p>
Clearly \(Q\) and \(S\) are two positive operators with \(\rho-\sigma=Q-S\) with orthogonal
support. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org707d177" class="outline-3">
<h3 id="org707d177">Exercise 9.8 (Convexity of the trace distance)</h3>
<div class="outline-text-3" id="text-org707d177">
<p>
Show that the trace distance is convex in its first input,
</p>

<p>
\[
  D\left(\sum_i p_i \rho_i, \sum_i p_i \sigma_i \right)
  \leq \sum_i p_i D(\rho_i, \sigma_i) .
\]
</p>
</div>

<div id="outline-container-org7d9ca8c" class="outline-4">
<h4 id="org7d9ca8c">Proof</h4>
<div class="outline-text-4" id="text-org7d9ca8c">
<p>
This directly follows from strong convexity with \(q_i=p_i\), using \(D(p,p)=0\). QED.
</p>

<p>
<a id="org442248d"></a>
But in my opinion this result is actually misleading. The book emphasizes the fact that
\(D\) is a metric, but actually it corresponds to a <i>norm</i> on the matrix space:
</p>

<p>
\[
  \norm{\rho}_{S_1} = \trace{\abs{\rho}} .
\]
</p>

<p>
We have \(D(\rho,\sigma)=2\inv\norm{\rho-\sigma}_{S_1}\). This is a so called <a href="https://en.wikipedia.org/wiki/Schatten_norm"><i>Schatten
norm</i></a>. The Schatten classes are the natural analog of the \(L^p\)​-spaces for operators on
Hilbert spaces. The above norm corresponds to \(p=1\). The Hilbert-Schmidt inner product
corresponds to a Schatten norm too, here \(p=2\).
</p>

<p>
As for any norm we have the following more general result (of course one has to prove that
the Schatten norm is actually a norm, but this is trivial based on what we already know
about \(D\))
</p>

<p>
\[
  D\left(\sum_i a_i \rho_i, \sum_i a_i \sigma_i \right) = 2\inv\norm{\sum_i a_i(\rho_i-\sigma_i)}_{S_1}
  \leq 2\inv\sum_i \abs{a_i} \norm{\rho_i-\sigma_i}_{S_1} = \sum_i \abs{a_i} D(\rho_i,\sigma_i)
\]
</p>

<p>
Here the \(a_i\) could be <i>any</i> complex numbers. It doesn't even matter that the operators
are density operators - it could be any matrices. And as said, this is just an abstract
property of norms in general. The <i>strong</i> convexity result is different in the way that
it really relies on special properties of this particular norm and the concrete arguments
it is applied to (density operators, numbers which are probabilities).
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-9.9" class="outline-3">
<h3 id="exercise-9.9">Exercise 9.9 (Existence of fixed points)</h3>
<div class="outline-text-3" id="text-exercise-9.9">
<p>
Schauder’s ﬁxed point theorem is a classic result from mathematics that implies that any
continuous map on a convex, compact subset of a Hilbert space has a fixed point. Use
Schauder’s fixed point theorem to prove that any trace-preserving quantum operation
\(\calE\) has a fixed point, that is, \(\rho\) such that \(\calE(\rho)=\rho\).
</p>
</div>

<div id="outline-container-org2d079ee" class="outline-4">
<h4 id="org2d079ee">Proof</h4>
<div class="outline-text-4" id="text-org2d079ee">
<p>
Just for definiteness let me recall my favorite version of Schauder's fixed point
theorem. There are various specializations and generalizations. In my oppinion the
following version hits the sweet spot in terms of generality and simplicity. The main
difference to the version mentioned in the exercise is that it gets rid of the <i>totally
irrelevant</i> property that the sourrounding space is a <i>Hilbert</i> space. There are
generalizations to more abstract settings but this might distract too much.
</p>

<dl class="org-dl">
<dt>Theorem (Schauder's fixed point theorem)</dt><dd>Let \(V\) be a Banach space and \(K\subset\?V\)
a compact and convex set. Let \(f:K\to\?K\) be continuous. Then \(f\) has a fixed point
\(x=f(x)\).</dd>
</dl>

<p>
In our setting we have \(f=\calE\), \(V=\CC^{d\times d}\) and \(K\) is the set of density
matrices (c.f. Theorem 2.5):
</p>

<p>
\[
  K = \{ \rho \in \CC^{d\times d} \; | \; \rho\geq0 , \trace{\rho} = 1 \} .
\]
</p>

<p>
\(K\) is clearly a closed set (if \((\rho_n)\) are density matrices with a limit
\(\rho_n\to\rho\) then the limit is also a density matrix). To show that it is compact it
suffices to show that \(K\) is bounded (in finite dimensional vector spaces <i>compact</i> is the
same as <i>bounded and closed</i> - <a href="https://en.wikipedia.org/wiki/Heine%E2%80%93Borel_theorem">Heine-Borel</a>). Recall that the operator norm of a hermitian
matrix is equal to the <i>spectral radius</i> - the maximum of the absolute values of its
eigenvalues (search for the relation of the <i>spectral radius</i> to the operator norm on any
decent resource on any of those topics, try e.g. <a href="https://en.wikipedia.org/wiki/Operator_norm">wikipedia</a>). Since the spectral radius is
at most \(1\) the claim follows. Hence \(K\) is indeed compact.
</p>

<p>
Convexity is also a well-known property of \(K\). In fact, the density matrices are just the
convex closure of the projection operators (this is just a mathematician's reformulation
of the definition of density matrices as ensembles of pure states).
</p>

<p>
Since \(\calE\) is trace-preserving we have \(\calE(K)\subseteq\?K\).
</p>

<p>
By the representation by Kraus matrices a quantum operation extends to a linear operator
on \(\CC^{d\times\?d}\). In finite dimensions <i>linearity</i> implies <i>continuity</i> (I didn't
find a dedicated resource on that, just have a look into <a href="https://en.wikipedia.org/wiki/Bounded_operator">bounded operators</a>). In particular
\(\calE:K\to\?K\) is continuous.
</p>

<p>
The preconditions of Schauder's theorem are satisfied. Hence \(\calE\) has a fixed
point. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-9.10" class="outline-3">
<h3 id="exercise-9.10">Exercise 9.10</h3>
<div class="outline-text-3" id="text-exercise-9.10">
<p>
Suppose \(\calE\) is a <i>strictly contractive</i> trace-preserving quantum operation, that is,
for any \(\rho\) and \(\sigma\), \(D(\calE(\rho),\calE(\sigma))\?<\?D(\rho,\sigma)\). Show that
\(\calE\) has a unique fixed point.
</p>
</div>

<div id="outline-container-org0cd6127" class="outline-4">
<h4 id="org0cd6127">Proof</h4>
<div class="outline-text-4" id="text-org0cd6127">
<p>
We already know from <a href="#exercise-9.9">exercise 9.9</a> that there must be one fixed point \(\rho_0\). Suppose
there was a second one \(\rho_1\neq\rho_0\). Then
</p>

<p>
\[
  D(\rho_0,\rho_1) = D(\calE(\rho_0),\calE(\rho_1)) < D(\rho_0,\rho_1) .
\]
</p>

<p>
The equality from the fixed point property. The inequality is the strict
contractivity. But this inequality is a contradiction to the fact that \(d\?<\?d\) cannot
hold for any real number \(d\)! Hence the claim that there was a second fixed point is
wrong. QED.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
The result is related to <a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Banach's fixed point theorem</a>. At least in finite
dimensions a strictly contractive map is already <i>uniformly</i> contractive. That is, there
exists a \(\lambda\?<1\) such that
</p>

<p>
\[ D(\calE(\rho),\calE(\sigma)) < \lambda D(\rho,\sigma) \]
</p>

<p>
for all \(\rho\), \(\sigma\). This can be easily seen by assuming the contrary and
considering a sequence \((\rho_n,\sigma_n)\) which violates the inequality for
\(\lambda=1-n\inv\) (also use the compactness of \(K\) to single out a converging
sub-sequence). Hence Banach's fixed point theorem applies and even yields a procedure
which converges exponentially fast to the unique fixed point.
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orgf55407c" class="outline-3">
<h3 id="orgf55407c">Exercise 9.11</h3>
<div class="outline-text-3" id="text-orgf55407c">
<p>
Suppose \(\calE\) is a trace-preserving quantum operation for which there exists a density
operator \(\rho_0\) and a trace-preserving quantum operation \(\calE'\) such that
</p>

<p>
\[
  \calE(\rho) = p \rho_0 + (1-p) \calE'(\rho) ,
\]
</p>

<p>
for some \(p\), \(0\?<\?p\leq1\). Physically, this means that with probability \(p\) the input
state is thrown out and replaced with the fixed state \(\rho_0\), while with probability
\(1-p\) the operation \(\calE'\) occurs. Use joint convexity to show that \(\calE\) is a
strictly contractive quantum operation, and thus has a unique fixed point.
</p>
</div>

<div id="outline-container-orge227b84" class="outline-4">
<h4 id="orge227b84">Proof</h4>
<div class="outline-text-4" id="text-orge227b84">
<p>
By strong contractivity (or just basic properties of <i>any</i> norm - see my <a href="#org442248d">extensive
commentary</a> to exercise 9.8) we have
</p>

<p>
\[
  D(\calE(\rho),\calE(\sigma)) \leq p D(\rho_0,\rho_0) + (1-p) D(\calE'(\rho),\calE'(\sigma))
  \leq 0 + (1-p) D(\rho,\sigma) .
\]
</p>

<p>
Hence the operation is strictly contractive. By <a href="#exercise-9.10">exercise 9.10</a> there exists a unique fixed
point. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orga96308a" class="outline-3">
<h3 id="orga96308a">Exercise 9.12</h3>
<div class="outline-text-3" id="text-orga96308a">
<p>
Consider the depolarizing channel introduced in Section 8.3.4 on page 378,
\(\calE(\rho)=pI/2+(1-p)\rho\). For arbitrary \(\rho\) and \(\sigma\) find
\(D(\calE(\rho),\calE(\sigma))\) using the Bloch representation, and prove explicitly that
the map \(\calE\) is strictly contractive, that is,
\(D(\calE(\rho),\calE(\sigma))\?<\?D(\rho,\sigma)\).
</p>
</div>

<div id="outline-container-org15546b8" class="outline-4">
<h4 id="org15546b8">Solution</h4>
<div class="outline-text-4" id="text-org15546b8">
<p>
Of course one could use the fact that the depolarizing channel acts like
</p>

<p>
\[
  (x,y,z) \mapsto (1-p)(x,y,z)
\]
</p>

<p>
on the Bloch space together with the fact that this identification is an isometry - up to
a factor of \(2\) (see equation (9.20)). But it also easily follows from <i>just plugging
stuff into other stuff</i>:
</p>

<p>
\[
  D(\calE(\rho),\calE(\sigma)) = 2\inv \norm{pI/2 + (1-p)\rho - pI/2 - (1-p)\sigma}_{S_1}
  = 2\inv (1-p) \norm{\rho-\sigma}_{S_1} = (1-p) D(\rho,\sigma) .
\]
</p>

<p>
Of course it is also not hard to see that \(I/2\) is the fixed point and that the
depolarizing channel contracts every other state towards it exponentially fast.
</p>
</div>
</div>
</div>

<div id="outline-container-orgee79254" class="outline-3">
<h3 id="orgee79254">Exercise 9.13</h3>
<div class="outline-text-3" id="text-orgee79254">
<p>
Show that the bit flip channel (Section 8.3.3) is contractive but not strictly
contractive. Find the set of fixed points for the bit flip channel.
</p>
</div>

<div id="outline-container-org73d529a" class="outline-4">
<h4 id="org73d529a">Solution</h4>
<div class="outline-text-4" id="text-org73d529a">
<p>
The bit flip channel is given by the following Kraus operators
</p>

<p>
\[
  E_0 = \sqrt{p} \, I , \; E_1 = \sqrt{1-p} \, X .
\]
</p>

<p>
The action on the Bloch sphere is easily seen to be (use \(XNX=-N\) for \(N\) being \(Y\) or
\(Z\), and \(XXX=X\)):
</p>

<p>
\[
  (x,y,z) \mapsto (x, (2p-1)y, (2p-1)z) .
\]
</p>

<p>
Hence, if we are in the non-trivial case, \(p\neq1\), the set of fixed points is given by
\(\{2\inv(1+xX)\,|\,x\in[-1,1]\}\) (we only consider density matrices). In the trivial case
the bit flip is just the identity operation.
</p>
</div>
</div>
</div>

<div id="outline-container-org3d5f987" class="outline-3">
<h3 id="org3d5f987">Exercise 9.14 (Invariance of fidelity under unitary transforms)</h3>
<div class="outline-text-3" id="text-org3d5f987">
<p>
Prove (9.61),
</p>

<p>
\[
  F(U\rho U^\dagger, U\rho U^\dagger) = F(\rho, \sigma) ,
\]
</p>

<p>
by using the fact that for any positive operator \(A\),
\(\sqrt{UAU^\dagger}=U\sqrt{A}U^\dagger\).
</p>
</div>

<div id="outline-container-org54583c3" class="outline-4">
<h4 id="org54583c3">Proof</h4>
<div class="outline-text-4" id="text-org54583c3">
<p>
Recall that the spectral theorem implies \(f(UAU^\dagger)=Uf(A)U^\dagger\) for any
continuous function \(f\) defined on the spectrum of \(A\) and any unitary \(U\). Actually this
<i>functional calculus</i> is typically defined by a formula like
</p>

<p>
\[
  f(A) = V f(D) V^\dagger
\]
</p>

<p>
where \(D=V^\dagger\?AV\) is the diagonalization of \(A\) and \(f(D)\) is just applied
entry-wise. So it is no surprise that the claimed formula
\(\sqrt{UAU^\dagger}=U\sqrt{A}U^\dagger\) holds. But let us come back to the exercise:
</p>

\begin{align*}
  F(U\rho U^\dagger, U\rho U^\dagger)
  &= \trace{\sqrt{U\rho^{1/2}U^\dagger U\sigma U^\dagger U \rho^{1/2} U^\dagger}} \\
  &= \trace{\sqrt{U\rho^{1/2} \sigma \rho^{1/2} U^\dagger}} \\
  &= \trace{U\sqrt{\rho^{1/2} \sigma \rho^{1/2}}U^\dagger} \\
  &= \trace{\sqrt{\rho^{1/2} \sigma \rho^{1/2}}} \\
  &= F(\rho, \sigma) .
\end{align*}

<p>
For the first equality we applied the hint to \(\sqrt{\rho}\). For the third equality we
applied it to \(\sqrt{\rho^{1/2}\sigma\rho^{1/2}}\). Finally we applied
\(\trace{UAU^\dagger}=\trace{AU^\dagger\?U}=\trace{A}\), using the cyclicity property of the
trace. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb752f6e" class="outline-3">
<h3 id="orgb752f6e">Exercise 9.15</h3>
<div class="outline-text-3" id="text-orgb752f6e">
<p>
Show that
</p>

<p>
\[
  F(\rho,\sigma) = \max_{\ket{\varphi}} \abs{\braket{\psi}{\varphi}} ,
\]
</p>

<p>
where \(\ket{\psi}\) is any <i>fixed</i> purification of \(\rho\), and the maximization is over all
purifications of \(\sigma\).
</p>
</div>

<div id="outline-container-org3b1f249" class="outline-4">
<h4 id="org3b1f249">Proof</h4>
<div class="outline-text-4" id="text-org3b1f249">
<p>
To prove this we just need a minor modification of the proof of Theorem 9.4. So recall
the proof given in the book. To give a bit of relevant context recall that
</p>

<p>
\[
  \ket{\psi} = (U_R \otimes \sqrt{\rho} U_Q) \ket{m}
\]
</p>

<p>
is a purification of \(\rho\) (and we have a similar formula for \(\ket{\varphi}\)). It is not
hard to check that <i>any</i> unitary \(U_R\) and \(U_Q\) give rise to a purification. This is just
a direct computation (hint: use \(\ptrace{R}{A}=\sum_i\bra{i_R}U_R^\dagger\?AU_R\ket{i_R}\)
to compute the partial trace). That <i>any</i> purification on <code>RQ</code> has this form follows from
<a href="chapter_2.html#exercise-2.81">exercise 2.81</a>, but this is not really important here.
</p>

<p>
Fixing \(\ket{\psi}\) more or less means that we also fix \(U_R\), \(U_Q\). Actually, they are
not really unique but we cannot easily tell which combinations are allowed so let us just
assume they are fixed. On the other hand we are free to choose \(V_R\) and \(V_Q\) in any way
because \(\ket{\varphi}\) can be chosen freely. Let
</p>

<p>
\[
  U = V_Q V_R^\dagger U_R U_Q^\dagger ,
\]
</p>

<p>
as in the book. Note one subtle thing here: the operators <i>must</i> be treated as matrices
here since they originally operate on different spaces (but this is explained in the book
of course).
</p>

<p>
According to the book to obtain equality in \(F(\rho,\sigma)=\abs{\braket{\psi}{\varphi}}\)
we have to accomplish that \(U=V^\dagger\) where \(\abs{\sqrt{\rho}\sqrt{\sigma}}V\) is the
polar decomposition of \(\sqrt{\rho}\sqrt{\sigma}\). But this can easily be done by choosing
e.g. \(V_R=I\) and
</p>

<p>
\[
  V_Q = V^\dagger U_Q U_R^\dagger,
\]
</p>

<p>
where \(V\) is expressed as a matrix with respect to the basis \((\ket{i_Q})_i\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe8d046" class="outline-3">
<h3 id="orgbe8d046">Exercise 9.16 (The Hilbert–Schmidt inner product and entanglement)</h3>
<div class="outline-text-3" id="text-orgbe8d046">
<p>
Suppose <code>R</code> and <code>Q</code> are two quantum systems with the same Hilbert space. Let \((\ket{i_R})\)
and \((\ket{i_Q})\) be orthonormal basis sets for <code>R</code> and <code>Q</code>. Let \(A\) be an operator on <code>R</code>
and \(B\) an operator on <code>Q</code>. Define \(\ket{m}=\sum_i\ket{i_R}\ket{i_Q}\). Show that
</p>

<p>
\[
  \trace{A^\dagger B} = \bra{m} A\otimes B \ket{m} ,
\]
</p>

<p>
where the multiplication on the left hand side is of matrices, and it is understood that
the matrix elements of \(A\) are taken with respect to the basis \((\ket{i_R})\) and those for
\(B\) with respect to the basis \((\ket{i_Q})\).
</p>
</div>

<div id="outline-container-org397482c" class="outline-4">
<h4 id="org397482c">Proof</h4>
<div class="outline-text-4" id="text-org397482c">
<p>
This is just a short calculation
</p>

\begin{align*}
  \bra{m} A\otimes B \ket{m}
  &= \sum_{ij} \bra{i_R,i_Q} A \otimes B \ket{j_R,j_Q} \\
  &= \sum_{ij} \bra{i_R}A\ket{j_R} \cdot \bra{i_Q}B\ket{j_Q} \\
  &= \sum_{ij} A_{ij} B_{ij} \\
  &= \trace{A^\dagger B} .
\end{align*}

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org9f152b7" class="outline-3">
<h3 id="org9f152b7">Exercise 9.17</h3>
<div class="outline-text-3" id="text-org9f152b7">
<p>
Show that \(0\leq\?A(\rho,\sigma)\leq\pi/2\), with equality in the first inequality if and
only if \(\rho=\sigma\).
</p>
</div>

<div id="outline-container-org034ea03" class="outline-4">
<h4 id="org034ea03">Proof</h4>
<div class="outline-text-4" id="text-org034ea03">
<p>
The first claim follows from the fact that \(\arccos:[0,1]\to[0,\pi/2]\) is a strictly
decreasing bijection and that \(F\) has values in \([0,1]\). The second assertion follows from
the fact that \(F(\rho,\sigma)=1\) iff \(\rho=\sigma\) by Uhlmann's theorem. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org4ad7da8" class="outline-3">
<h3 id="org4ad7da8">Exercise 9.18 (Contractivity of the angle)</h3>
<div class="outline-text-3" id="text-org4ad7da8">
<p>
Let \(\calE\) be a trace-preserving quantum operation. Show that
</p>

<p>
\[
  A(\calE(\rho), \calE(\sigma)) \leq A(\rho, \sigma) .
\]
</p>
</div>

<div id="outline-container-orgf56bdc8" class="outline-4">
<h4 id="orgf56bdc8">Proof</h4>
<div class="outline-text-4" id="text-orgf56bdc8">
<p>
This is a direct corollary of the monotonicity of the fidelity (Theorem 9.6) and the fact
that \(\arccos:[0,1]\to[0,\pi/2]\) is decreasing (and \(F(\rho,\sigma)\in[0,1]\)). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-9.19" class="outline-3">
<h3 id="exercise-9.19">Exercise 9.19 (Joint concavity of fidelity)</h3>
<div class="outline-text-3" id="text-exercise-9.19">
<p>
Prove that the ﬁdelity is <i>jointly concave</i>,
</p>

<p>
\[
  F\left(\sum_ip_i\rho_i, \sum_ip_i\sigma_i\right) \geq \sum_i p_i F(\rho_i, \sigma_i) .
\]
</p>
</div>

<div id="outline-container-org5016bd8" class="outline-4">
<h4 id="org5016bd8">Proof</h4>
<div class="outline-text-4" id="text-org5016bd8">
<p>
Follows from strict concavity with \(q_i=p_i\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org1ad1133" class="outline-3">
<h3 id="org1ad1133">Exercise 9.20 (Concavity of fidelity)</h3>
<div class="outline-text-3" id="text-org1ad1133">
<p>
Prove that the ﬁdelity is concave in the first entry,
</p>

<p>
\[
  F\left(\sum_ip_i\rho_i, \sigma\right) \geq \sum_i p_i F(\rho_i, \sigma) .
\]
</p>
</div>

<div id="outline-container-org8b4b434" class="outline-4">
<h4 id="org8b4b434">Proof</h4>
<div class="outline-text-4" id="text-org8b4b434">
<p>
Follows from <a href="#exercise-9.19">exercise 9.19</a> with \(\sigma_i=\sigma\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf08ec81" class="outline-3">
<h3 id="orgf08ec81">Exercise 9.21</h3>
<div class="outline-text-3" id="text-orgf08ec81">
<p>
When comparing pure states and mixed states it is possible to make a stronger statement
than (9.110) about the relationship between trace distance and fidelity. Prove that
</p>

<p>
\[
  1 - F(\ket{\psi}, \sigma)^2 \leq D(\ket{\psi}, \sigma) .
\]
</p>
</div>

<div id="outline-container-org82ba2df" class="outline-4">
<h4 id="org82ba2df">Proof</h4>
<div class="outline-text-4" id="text-org82ba2df">
<p>
The key to the proof is (9.60):
</p>

<p>
\[
  F(\ket{\psi}, \rho)^2 = \bra{\psi} \rho \ket{\psi} .
\]
</p>

<p>
Let us calculate:
</p>

\begin{align*}
  D(\ket{\psi}, \rho) &= \max_P \trace{P(\proj{\psi}-\rho)} \\
  &\geq 1 - \trace{\proj{\psi}\rho} \\
  &= 1 - \bra{\psi} \rho \ket{\psi} \\
  &= 1 - F(\ket{\psi}, \rho)^2 .
\end{align*}

<p>
In the first line we maximize over all projections. In the second line we set
\(P=\proj{\psi}\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdfb757f" class="outline-3">
<h3 id="orgdfb757f">Exercise 9.22 (Chaining property for fidelity measures)</h3>
<div class="outline-text-3" id="text-orgdfb757f">
<p>
Suppose \(U\) and \(V\) are unitary operators, and \(\calE\) and \(\calF\) are trace-preserving
quantum operations meant to approximate \(U\) and \(V\). Letting \(d(\cdot,\cdot)\) be any
metric on the space of density matrices satisfying
\(d(U\rho\?U^\dagger,U\sigma\?U^\dagger)=d(\rho,\sigma)\) for all density matrices \(\rho\)
and \(\sigma\) and unitary \(U\) (such as the angle \(\arccos(F(\rho,\sigma))\), define the
corresponding error \(E(U,\calE)\) by
</p>

<p>
\[
  E(U, \calE) \equiv \max_{\rho} d(U\rho U^\dagger, \calE(\rho)) ,
\]
</p>

<p>
and show that \(E(VU,\calF\circ\calE)\leq\?E(U,\calE)+E(V,\calF)\). Thus, to perform a
quantum computation with high ﬁdelity it sufﬁces to complete each step of the computation
with high fidelity.
</p>
</div>

<div id="outline-container-org095c598" class="outline-4">
<h4 id="org095c598">Proof</h4>
<div class="outline-text-4" id="text-org095c598">
<p>
We have
</p>

<p>
\[
  E(VU,\calF\circ\calE) = \max_{\rho} d(VU \rho U^\dagger V^\dagger, \calF(\calE(\rho))) .
\]
</p>

<p>
Observe that
</p>

\begin{align*}
  d(VU \rho U^\dagger V^\dagger, \calF(\calE(\rho)))
  &= d(U \rho U^\dagger, V^\dagger \calF(\calE(\rho)) V) \\
  &\leq d(U \rho U^\dagger, \calE(\rho))) + d(\calE(\rho), V^\dagger \calF(\calE(\rho)) V) \\
  &= d(U \rho U^\dagger, \calE(\rho))) + d(V\calE(\rho)V^\dagger, \calF(\calE(\rho))) \\
  &\leq E(U,\calE) + E(V,\calF) .
\end{align*}

<p>
For the two equalities we used the assumed isometry property of the matric \(d\). The first
inequality is just the triangle inequality. From this the claim directly follows. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orga1cef55" class="outline-3">
<h3 id="orga1cef55">Exercise 9.23</h3>
<div class="outline-text-3" id="text-orga1cef55">
<p>
Show that \(\bar{F}=1\) if and only if \(\calE(\rho_j)=\rho_j\) for all \(j\) such that \(p_j\?>\?0\).
</p>
</div>

<div id="outline-container-org6a114de" class="outline-4">
<h4 id="org6a114de">Proof</h4>
<div class="outline-text-4" id="text-org6a114de">
<p>
Let us recall the formula for \(\bar{F}\):
</p>

<p>
\[
  \bar{F} = \sum_j p_j F(\rho_j, \calE(\rho_j))^2 .
\]
</p>

<p>
Since \(0\leq\?F(\rho_j,\calE(\rho_j))\leq1\), and \(0\leq\?p_j\leq1\), and \(\sum_jp_j=1\) we
see that \(\bar{F}=1\) is equivalent to
</p>

<p>
\[
  \forall j: p_j > 0 \Rightarrow F(\rho_j, \calE(\rho_j)) = 1 .
\]
</p>

<p>
On the other hand we already know that \(F(\rho,\sigma)=1\) is equivalent to \(\rho=\sigma\)
(follows e.g. from Uhlmann's theorem). Hence \(\bar{F}=1\) is equivalent to
</p>

<p>
\[
  \forall j: p_j > 0 \Rightarrow \rho_j = \calE(\rho_j) .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4.50 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>
