<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 8</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 8</h1>\[
\newcommand{\BB}{\mathbb{B}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\HH}{\mathbb{H}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\jj}{\mathrm{j}}
\newcommand{\kk}{\mathrm{k}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\RF}{\mathrm{RF}}
\newcommand{\sys}{\mathrm{sys}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\cx}{\mathrm{CX}}
\newcommand{\cy}{\mathrm{CY}}
\newcommand{\cz}{\mathrm{CZ}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % deprecated, use braket instead.
\newcommand{\braket}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\rank}[1]{\mathrm{rank}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\wt}[1]{\mathrm{wt}\left(#1\right)}
\newcommand{\prob}[1]{\mathrm{Prob}\left[#1\right]}
\newcommand{\orac}{\mathrm{Orac}}
\newcommand{\?}{} % sometimes I need just a separator other than whitespace
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9aa0337">Setup</a>
<ul>
<li><a href="#orge4b3f79">Imports</a></li>
<li><a href="#org0175033">Utility code</a></li>
<li><a href="#org7d729ab">Bloch sphere representation</a></li>
<li><a href="#chapter-8-process-tomography-single-qubit">Process tomography for single qubit</a></li>
</ul>
</li>
<li><a href="#orga9c2d77">Exercises</a>
<ul>
<li><a href="#exercise-8.1">Exercise 8.1 (Unitary evolution as a quantum operation)</a></li>
<li><a href="#org4e5f6a6">Exercise 8.2 (Measurement as a quantum operation)</a></li>
<li><a href="#org2d4c5f4">Exercise 8.3</a></li>
<li><a href="#exercise-8.4">Exercise 8.4 (Measurement)</a></li>
<li><a href="#org82bfaf4">Exercise 8.5 (Spin flips)</a></li>
<li><a href="#orgd91e06e">Exercise 8.6 (Composition of quantum operations)</a></li>
<li><a href="#orga14d843">Exercise 8.7</a></li>
<li><a href="#org3320c65">Exercise 8.8 (Non-trace-preserving quantum operations)</a></li>
<li><a href="#orgdbbc8cb">Exercise 8.9 (Measurement model)</a></li>
<li><a href="#exercise-8.10">Exercise 8.10</a></li>
<li><a href="#org40b0861">Exercise 8.11</a></li>
<li><a href="#orgc84dc38"><span class="todo WIP">WIP</span> Exercise 8.12</a></li>
<li><a href="#org32160dd">Exercise 8.13</a></li>
<li><a href="#orgb2e34c2">Exercise 8.14</a></li>
<li><a href="#org70ec5de">Exercise 8.15</a></li>
<li><a href="#exercise-8.16">Exercise 8.16</a></li>
<li><a href="#org2b46975">Exercise 8.17</a></li>
<li><a href="#orgda649b1">Exercise 8.18</a></li>
<li><a href="#orge50c21c">Exercise 8.19</a></li>
<li><a href="#exercise-8.20">Exercise 8.20 (Circuit model for amplitude damping)</a></li>
<li><a href="#orgfa8963e">Exercise 8.21 (Amplitude damping of a harmonic oscillator)</a></li>
<li><a href="#exercise-8.22">Exercise 8.22 (Amplitude damping of single qubit density matrix)</a></li>
<li><a href="#org1594616">Exercise 8.23 (Amplitude damping of dual-rail qubits)</a></li>
<li><a href="#orgc3391c8">Exercise 8.24 (Spontaneous emission is amplitude damping)</a></li>
<li><a href="#orgef1b665">Exercise 8.25</a></li>
<li><a href="#orgf6f50d9">Exercise 8.26 (Circuit model for phase damping)</a></li>
<li><a href="#exercise-8.27">Exercise 8.27 (Phase damping = phase flip channel)</a></li>
<li><a href="#orgf135d62">Exercise 8.28 (One <code>CNOT</code> phase damping model circuit)</a></li>
<li><a href="#orgdfce80f">Exercise 8.29 (Unitality)</a></li>
<li><a href="#org2fab00c">Exercise 8.30 (\(T_2\leq2T_1\))</a></li>
<li><a href="#org0e87c94"><span class="todo TODO">TODO</span> Exercise 8.31 (Exponential sensitivity to phase damping)</a></li>
<li><a href="#org3a90467">Exercise 8.32</a></li>
<li><a href="#org8d3478b">Exercise 8.33 (Specifying a quantum process)</a></li>
<li><a href="#org2813bd9">Exercise 8.34 (Process tomography for two qubits)</a></li>
<li><a href="#orgf7e4cb2">Exercise 8.35 (Process tomography example)</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org9aa0337" class="outline-2">
<h2 id="org9aa0337">Setup</h2>
<div class="outline-text-2" id="text-org9aa0337">
</div>
<div id="outline-container-orge4b3f79" class="outline-3">
<h3 id="orge4b3f79">Imports</h3>
<div class="outline-text-3" id="text-orge4b3f79">
<div class="org-src-container">
<pre class="src src-sage" id="orgff68c44"><span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> product
<span class="org-keyword">from</span> utils_sage <span class="org-keyword">import</span> Id, X, Y, Z, delta, eps, inner, trace, kron, P0, P1
</pre>
</div>

<p>
Let us set up some variables
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org50ffacc"><span class="org-variable-name">p</span>, <span class="org-variable-name">g</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'p g'</span>, domain<span class="org-operator">=</span><span class="org-string">'positive'</span>)
<span class="org-variable-name">x</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">z</span>, <span class="org-variable-name">e</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'x y z e'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
<span class="org-variable-name">u</span>, <span class="org-variable-name">v</span>, <span class="org-variable-name">w</span>, <span class="org-variable-name">s</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'u v w s'</span>, domain<span class="org-operator">=</span><span class="org-string">'complex'</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">We want to use p as a probability, not sure if this does anything, but looks useful:</span>
assume(p <span class="org-operator">&lt;=</span> 1)
assume(g <span class="org-operator">&lt;=</span> 1)
</pre>
</div>
</div>
</div>
<div id="outline-container-org0175033" class="outline-3">
<h3 id="org0175033">Utility code</h3>
<div class="outline-text-3" id="text-org0175033">
<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">def</span> <span class="org-function-name">make_operation</span>(Es: <span class="org-builtin">list</span>[matrix]):
    <span class="org-doc">"""Given a list of operation elements return their quantum operation."""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">op</span>(rho):
        <span class="org-keyword">return</span> <span class="org-builtin">sum</span>(E <span class="org-operator">*</span> rho <span class="org-operator">*</span> E.H <span class="org-keyword">for</span> E <span class="org-keyword">in</span> Es)
    <span class="org-keyword">return</span> op
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d729ab" class="outline-3">
<h3 id="org7d729ab">Bloch sphere representation</h3>
<div class="outline-text-3" id="text-org7d729ab">
</div>
<div id="outline-container-chapter-8-bloch-M-c" class="outline-4">
<h4 id="chapter-8-bloch-M-c">Derivation of the formula for \(M_{jk}\) and \(c_k\)</h4>
<div class="outline-text-4" id="text-chapter-8-bloch-M-c">
<p>
For convenience I provide a derivation of formulas (8.91) and (8.92) for the
representation of a quantum operation on a single-qubit principal system:
</p>

\begin{align*}
  M_{jk} &= \sum_l \left[
    a_{lj} a_{lk}^* + a_{lj}^* a_{lk} +
    \left(\abs{\alpha_l}^2 - \sum_p \abs{a_{lp}}^2 \right) \delta_{jk} +
    \ii \sum_p \epsilon_{jkp} (\alpha_l a_{lp}^* - \alpha_l^* a_{lp})
  \right] , \\
  c_k &= 2 \ii \sum_l \sum_{jp} \epsilon_{jpk} a_{lj} a_{lp}^* .
\end{align*}

<p>
Here we assume that the operation elements look as follows:
</p>

<p>
\[
  E_l = \alpha_l + \sum_{k=1}^3 a_{lk} \sigma_k ,
\]
</p>

<p>
and satisfy the trace-preserving property \(\sum_lE_l^\dagger\?E_l=1\) (here and in the
following I write scalars in place of multiples of the identity matrix). Let
</p>

<p>
\[
  \rho = \frac{1}{2} (1 + r_k \sigma_k) .
\]
</p>

<p>
Throughout this section (about Bloch sphere) let us apply a variant of <b>Einsteins
summation convention</b>. Whenever a free index appears twice in a <i>product expression</i> we
sum over it. For example, the above formula for \(\rho\) means
</p>

<p>
\[
  \rho = \frac{1}{2} (1 + \sum_k r_k \sigma_k) .
\]
</p>

<p>
As a special case we implicitly read \(\abs{x_i}^2\) as \(x_ix_i^*\) and hence imply summation
over \(i\) in case of a square of an absolute value too. Let us start by considering the
trace-preserving condition
</p>

<p>
\[
  1 = E_l^\dagger E_l = (\alpha_l^* + a_{lp}^*\sigma_p) (\alpha_l + a_{lp}\sigma_q)
  = \abs{\alpha_l}^2 + \alpha_l^* a_{lp} \sigma_p + \alpha_l a_{lp}^* \sigma_p + a_{lp}^*a_{lp} \sigma_p \sigma_q .
\]
</p>

<p>
Note that \(\sigma_p\sigma_q=\ii\epsilon_{pqk}\sigma_k+\delta_{pq}\). Hence
</p>

<p>
\[
  1 = \abs{\alpha_l}^2 + \abs{a_{lp}}^2 +
    2\Re(\alpha_la_{lk}^*)\sigma_k + \ii\epsilon_{pqk} a_{lp}^* a_{lq} \sigma_k .
\]
</p>

<p>
We can deduce the two constraints the coefficients \(\alpha\) and \(a\) have to satisfy in
order for the trace-preserving property to hold (we use here that the Pauli operators
together with the identity are a (orthonormal) basis of \(\CC^{2\times2}\)):
</p>

<p>
<a id="org0e1ffe7"></a>
\[
  \abs{\alpha_l}^2 + \abs{a_{lp}}^2 = 1 ,
\]
</p>

<p>
and
</p>

<p>
<a id="orgd94c1c5"></a>
\[
  \forall k: \; \ii\epsilon_{pqk} a_{lp}^* a_{lq} = -2\Re(\alpha_la_{lk}^*) .
\]
</p>

<p>
Now consider
</p>

<p>
\[
  2 \calE(\rho) =
  2 E_l \rho E_l^\dagger = (\alpha_l + a_{lp}\sigma_p) (1 + r_k \sigma_k) (\alpha_l^* + a_{lq}^*\sigma_q)
  =: I_1 + I_2 ,
\]
</p>

<p>
where the \(I_1\) corresponds to the \(1\) in the middle factor and \(I_2\) to the \(r_k\sigma_k\)
in the middle factor. In case you wonder: the factor of \(2\) at the front should make the
expression a bit simpler by avoiding numerous factors \(1/2\) in the following.
</p>

\begin{align*}
  I_1 &= \abs{\alpha_l}^2 + \alpha_l a_{lp}^* \sigma_p + \alpha_l^* a_{lp} \sigma_p +
    a_{lp}a_{lq}^* \sigma_p\sigma_q \\
  &= \abs{\alpha_l}^2 + \abs{a_{lp}}^2 + 2\Re(\alpha_la_{lk}^*)\sigma_k
    + \ii\epsilon_{pqk} a_{lp} a_{lq}^* \sigma_k \\
  &= 1 + 2\ii \epsilon_{pqk} a_{lp} a_{lq}^* \sigma_k .
\end{align*}

<p>
For the last equality we used the <a href="#org0e1ffe7">first</a> and <a href="#orgd94c1c5">second</a> formula for the
trace-preservation. Since \(I_1\) contains the part of \(2\calE(\rho)=1+r_k'\sigma_k\) which
does not depend on on the \(r_k\) we already proved the formula for \(c_k\). The treatment of
\(I_2\) is a bit more involved.
</p>

\begin{align*}
  I_2 &= \abs{\alpha_l}^2 r_k \sigma_k +
    \alpha_l a_{lp}^* r_k \sigma_k\sigma_p + \alpha_l^* a_{lp} r_k \sigma_p\sigma_k +
    a_{lp} a_{lq}^* r_k \sigma_p \sigma_k \sigma_q \\
  &= \abs{\alpha_l}^2 r_k \sigma_k +
    \alpha_l a_{lp}^* r_k (\ii\epsilon_{kpj}\sigma_j + \delta_{kp}) +
    \alpha_l^* a_{lp} r_k (-\ii\epsilon_{kpj}\sigma_j + \delta_{kp}) +
    a_{lp} a_{lq}^* r_k \sigma_p \sigma_k \sigma_q \\
  &=: I_{20} + I_{21} + I_{22} .
\end{align*}

<p>
Here \(I_{22}\) stands for the last summand (the product of three Paulis), \(I_{21}\) stands for
the two commands involving the \(\delta_{kp}\). Finally \(I_{20}\) is the rest. Note that
\(I_{20}\) already corresponds to terms appearing in the formula for \(M_{jk}\) and hence
needs no further treatment. We have
</p>

<p>
\[
  I_{21} = \alpha_l a_{lk}^* r_k + \alpha_l^* a_{lk} r_k
  = 2 \Re(\alpha_l a_{lk}^*) r_k .
\]
</p>

<p>
Note that this term cannot have any possible correspondence in \(M\) (or \(c\)). Hence we
expect it to be cancelled by \(I_{22}\). Therefore let us finally consider \(I_{22}\). Note
that
</p>

<p>
\[
  \sigma_p \sigma_k \sigma_q = - \sigma_p \sigma_q \sigma_k + 2 \sigma_p \delta_{qk} .
\]
</p>

<p>
Hence
</p>

<p>
\[
  I_{22} = (- a_{lp} a_{lq}^* \sigma_p\sigma_q) r_k\sigma_k + 2 a_{lp} a_{lk}^* r_k \sigma_p
  =: J_1 + J_2 .
\]
</p>

<p>
Moreover
</p>

<p>
\[
  J_1 = (-\abs{a_{lp}}^2 - \ii\epsilon_{pqs}a_{lp}a_{lq}^* \sigma_s) r_k\sigma_k
  = -\abs{a_{lp}}^2 r_k\sigma_k - \ii\epsilon_{pqk}a_{lp}a_{lq}^* -
    \ii \epsilon_{pqs} a_{lp}a_{lq}^* \sigma_s (r_p \sigma_p + r_q \sigma_q)
  =: J_{10} + J_{11} + J_{12} .
\]
</p>

<p>
For the second equality I splitted the summation over \(k\) into \(k=s\) and \(k\neq\?s\) (this
leads to a tiny clash with out summation convention but shouldn't be a major hurdle for
understanding the calculations). Note that \(J_{10}\) corresponds to a term in \(M\), so with
this one we are done. By <a href="#orgd94c1c5">trace-preservation</a> we have that
</p>

<p>
\[
  J_{11} + I_{21} = 0 ,
\]
</p>

<p>
which is the awaited cancellation for \(I_{21}\). So these terms are also done. Recall that
the only still open terms are \(J_{12}\) and \(J_2\). We will go on with the former.
</p>

<p>
\[
  J_{12} = -\ii a_{lp} a_{lq}^* \left( \epsilon_{pqs}
    \left[ r_p \ii \epsilon_{spq}\sigma_q + r_q \ii \epsilon_{sqp}\sigma_p \right] \right)
  = a_{lp} a_{lq}^* (r_p\sigma_q - r_q \sigma_p) .
\]
</p>

<p>
This can be nicely combined with \(J_2\):
</p>

<p>
\[
  J_{12} + J_2 = a_{lp} a_{lq}^* r_p \sigma_q + a_{lp} a_{lq}^* r_q \sigma_p
  = a_{lk} a_{lj}^* r_k \sigma_j + a_{lj} a_{lk}^* r_k \sigma_j ,
\]
</p>

<p>
which yields the remaining terms in the formula for \(M\). QED.
</p>
</div>
</div>

<div id="outline-container-org45a8e67" class="outline-4">
<h4 id="org45a8e67">Sage code</h4>
<div class="outline-text-4" id="text-org45a8e67">
<p>
The following function implements \(M\) and \(c\) from the previous section in sage.
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org74d6e09"><span class="org-keyword">def</span> <span class="org-function-name">affine</span>(<span class="org-operator">*</span>Es):
    <span class="org-doc">"""Maps a list of single-qubit operation elements to their Bloch-representation</span>

<span class="org-doc">    Args:</span>
<span class="org-doc">        Es: A list of single qubit operation elements, trace preserving.</span>

<span class="org-doc">    Returns:</span>
<span class="org-doc">        M, c: as in formulas (8.91) and (8.92)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">N</span> <span class="org-operator">=</span> <span class="org-builtin">len</span>(Es)

    <span class="org-keyword">assert</span> N <span class="org-operator">!=</span> 0, <span class="org-string">"Need at least one operation element"</span>
    <span class="org-keyword">assert</span> <span class="org-builtin">all</span>([<span class="org-builtin">len</span>(E) <span class="org-operator">==</span> 4 <span class="org-keyword">for</span> E <span class="org-keyword">in</span> Es]), <span class="org-string">"Need 4 coefficients for each Ei"</span>

    <span class="org-variable-name">alpha</span> <span class="org-operator">=</span> [E[0] <span class="org-keyword">for</span> E <span class="org-keyword">in</span> Es]
    <span class="org-variable-name">bs</span> <span class="org-operator">=</span> [E[1:4] <span class="org-keyword">for</span> E <span class="org-keyword">in</span> Es]

    <span class="org-variable-name">M</span> <span class="org-operator">=</span> [[<span class="org-builtin">sum</span>(
          bs[l][j] <span class="org-operator">*</span> bs[l][k].conjugate() <span class="org-operator">+</span> bs[l][j].conjugate() <span class="org-operator">*</span> bs[l][k]
          <span class="org-operator">+</span> delta(j, k) <span class="org-operator">*</span> alpha[l] <span class="org-operator">*</span> alpha[l].conjugate()
          <span class="org-operator">-</span> delta(j, k) <span class="org-operator">*</span> <span class="org-builtin">sum</span>(bs[l][p] <span class="org-operator">*</span> bs[l][p].conjugate() <span class="org-keyword">for</span> p <span class="org-keyword">in</span> <span class="org-builtin">range</span>(3))
          <span class="org-operator">+</span> I <span class="org-operator">*</span> <span class="org-builtin">sum</span>(eps(j, k, p)<span class="org-operator">*</span>(alpha[l]<span class="org-operator">*</span>bs[l][p].conjugate() <span class="org-operator">-</span> alpha[l].conjugate()<span class="org-operator">*</span>bs[l][p])
                    <span class="org-keyword">for</span> p <span class="org-keyword">in</span> <span class="org-builtin">range</span>(3))
        <span class="org-keyword">for</span> l <span class="org-keyword">in</span> <span class="org-builtin">range</span>(N)) <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(3)] <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(3)]

    <span class="org-variable-name">c</span> <span class="org-operator">=</span> [<span class="org-builtin">sum</span>(<span class="org-builtin">sum</span>(<span class="org-builtin">sum</span>(
             2<span class="org-operator">*</span>i <span class="org-operator">*</span> eps(j, p, k) <span class="org-operator">*</span> bs[l][j] <span class="org-operator">*</span> bs[l][p].conjugate()
           <span class="org-keyword">for</span> p <span class="org-keyword">in</span> <span class="org-builtin">range</span>(3)) <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(3)) <span class="org-keyword">for</span> l <span class="org-keyword">in</span> <span class="org-builtin">range</span>(N))
         <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(3)]

    <span class="org-keyword">return</span> simplify(matrix(M)), simplify(vector(c))


<span class="org-keyword">def</span> <span class="org-function-name">toPauli</span>(M):
    <span class="org-doc">"""Takes a 2x2 matrix and returns its coefficients in the Pauli-Basis (I,X,Y,Z)."""</span>
    <span class="org-keyword">assert</span> M.dimensions() <span class="org-operator">==</span> (2, 2), <span class="org-string">"Expected a two dimensional matrix"</span>
    <span class="org-keyword">return</span> [inner(p<span class="org-operator">/</span>2, M) <span class="org-keyword">for</span> p <span class="org-keyword">in</span> [Id, X, Y, Z]]


<span class="org-keyword">def</span> <span class="org-function-name">affine2</span>(<span class="org-operator">*</span>Ps):
    <span class="org-doc">"""Like affine but applies toPauli before that to accept the operator elements</span>
<span class="org-doc">    directly as matrices."""</span>
    <span class="org-keyword">return</span> affine(<span class="org-operator">*</span>[toPauli(p) <span class="org-keyword">for</span> p <span class="org-keyword">in</span> Ps])
</pre>
</div>

<p>
Now we are prepared to consider the examples from the book. First let us consider the
<b>bit-flip</b>:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orga716e97"><span class="org-variable-name">E0</span> <span class="org-operator">=</span> sqrt(p) <span class="org-operator">*</span> Id
<span class="org-variable-name">E1</span> <span class="org-operator">=</span> sqrt(1<span class="org-operator">-</span>p) <span class="org-operator">*</span> X

<span class="org-variable-name">M</span>, <span class="org-variable-name">c</span> <span class="org-operator">=</span> affine(<span class="org-operator">*</span>[toPauli(E) <span class="org-keyword">for</span> E <span class="org-keyword">in</span> [E0, E1]])

<span class="org-keyword">assert</span> M <span class="org-operator">==</span> matrix.diagonal([1, 2<span class="org-operator">*</span>p<span class="org-operator">-</span>1, 2<span class="org-operator">*</span>p<span class="org-operator">-</span>1])
<span class="org-keyword">assert</span> c <span class="org-operator">==</span> vector([0, 0, 0])
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Next consider the <b>amplitude damping</b>:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">E0</span> <span class="org-operator">=</span> matrix.diagonal([1, sqrt(1<span class="org-operator">-</span>g)])
<span class="org-variable-name">E1</span> <span class="org-operator">=</span> matrix([[0, sqrt(g)], [0, 0]])

<span class="org-variable-name">M</span>, <span class="org-variable-name">c</span> <span class="org-operator">=</span> affine(<span class="org-operator">*</span>[toPauli(E) <span class="org-keyword">for</span> E <span class="org-keyword">in</span> [E0, E1]])
<span class="org-variable-name">M</span> <span class="org-operator">=</span> M.expand()

<span class="org-keyword">assert</span> M <span class="org-operator">==</span> matrix.diagonal([sqrt(1<span class="org-operator">-</span>g), sqrt(1<span class="org-operator">-</span>g), 1<span class="org-operator">-</span>g])
<span class="org-keyword">assert</span> c <span class="org-operator">==</span> vector([0, 0, g])
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
For some exercises I think it is convenient to be able to perform (possibly
non-trace-preserving) single qubit operations. For this the Bloch sphere is not sufficient
anymore, but we still have a representation in \(\RR^4\) (see my solution of <a href="#exercise-8.16">exercise
8.16</a>). More precisely on the real subspace of \(\CC^{2\times2}\) generated by the
Pauli-operators \((I,X,Y,Z)\).
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org5d335ea"><span class="org-comment-delimiter"># </span><span class="org-comment">A generalized density matrix and an arbitrary operator E:</span>
<span class="org-variable-name">rho_gen</span> <span class="org-operator">=</span> (e <span class="org-operator">+</span> x<span class="org-operator">*</span>X <span class="org-operator">+</span> y<span class="org-operator">*</span>Y <span class="org-operator">+</span> z<span class="org-operator">*</span>Z)
<span class="org-variable-name">E_gen</span> <span class="org-operator">=</span> s<span class="org-operator">*</span>Id <span class="org-operator">+</span> u<span class="org-operator">*</span>X <span class="org-operator">+</span> v<span class="org-operator">*</span>Y <span class="org-operator">+</span> w<span class="org-operator">*</span>Z

<span class="org-keyword">def</span> <span class="org-function-name">qop1d</span>(Es, rho):
    <span class="org-doc">"""Take a list of operator elements and apply the quantum operation to the given mixed</span>
<span class="org-doc">    single-qubit state. It returns the result as a vector in RR^4 wrt the Pauli basis."""</span>
    <span class="org-variable-name">rho1</span> <span class="org-operator">=</span> make_operation(Es)(rho)
    <span class="org-keyword">return</span> simplify(vector(toPauli(rho1)))
</pre>
</div>

<p>
The corresponding matrix is given by
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org467b3f0"><span class="org-keyword">def</span> <span class="org-function-name">make_qop1d_matrix_4d</span>(Es):
    <span class="org-doc">"""Return the matrix representation on RR^4 of the operation given by the</span>
<span class="org-doc">    elements. Works for non-trace-preserving operations too."""</span>
    <span class="org-variable-name">bs</span> <span class="org-operator">=</span> matrix.identity(4)
    <span class="org-keyword">return</span> simplify(matrix([[b<span class="org-operator">*</span>qop1d(Es, rho<span class="org-operator">=</span>A) <span class="org-keyword">for</span> A <span class="org-keyword">in</span> [Id, X, Y, Z]] <span class="org-keyword">for</span> b <span class="org-keyword">in</span> bs]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-chapter-8-process-tomography-single-qubit" class="outline-3">
<h3 id="chapter-8-process-tomography-single-qubit">Process tomography for single qubit</h3>
<div class="outline-text-3" id="text-chapter-8-process-tomography-single-qubit">
<p>
I found it highly non-trivial to verify equation (8.179)
</p>

<p>
<a id="orgd695e9c"></a>
\[
  \chi = \Lambda \begin{bmatrix} \rho'_0 & \rho'_1 \\ \rho'_2 & \rho'_3 \end{bmatrix} \Lambda
\]
</p>

<p>
in Box 8.5 on process tomography for a single qubit. Therefore I try to prove it here in a
way which is hopefully systematic enough to gain some insight. For later reference let us
call the matrix in the middle \(R'\) (Note that I shifted the indices my one - this makes
matters slightly simpler). Recall that
</p>

<p>
\[
  \Lambda = \frac{1}{2} (Z\otimes I + X \otimes X) .
\]
</p>

<p>
I take this as a motivation to define \(L_0=Z\), \(L_1=X\), \(R_0=I\), \(R_1=X\). This implies
\(\Lambda=\sum_aL_a\otimes\?R_a\), and in particular
</p>

<p>
\[
  4 \Lambda (\rho\otimes \rho') \Lambda = \sum_{ab} L_a \rho L_b \otimes R_a \rho' R_b .
\]
</p>

<p>
Let \(P_{kl}=\ket{k}\bra{l}\). Recall that the \(\rho'_i\) are given by
\(\rho'_i=\calE(\rho_i)\) and \(\rho_i=P_{kl}\) where \(kl\) is the binary representation of
\(i\). Observe that \(P_{kl}=R_kP_{00}R_l\) (we will use it later). A crucial thing in box 8.5
is the definition of the basis for the operation elements:
</p>

<p>
\[
  N_0=I, \; N_1=X, \; N_2=\tilde{Y}=-\ii Y, \; N_3=Z .
\]
</p>

<p>
One important property of this basis is the following:
</p>

<p>
\[
  X N_i X = \begin{cases} N_i & \text{for } i=0,1 \\ -N_i & \text{for } i=2,3 \end{cases}
\]
</p>

<p>
But of course this does not explain the peculiar form of \(N_2\) (\(Y\) would do the
same). Another "nice" property is \(XN_0=N_1\), and \(XN_2=N_3\). Also note that \(N_2=XZ\)
which says that \(N_2\) is a bit- and a phase-flip in one. This turns out to be important
further below. Before we start proving the claim we note that
</p>

<p>
\[
  R' = \sum_i \rho_i \otimes \rho_i' = \sum_{klmn} \chi_{mn} P_{kl} \otimes N_m P_{kl} N_n .
\]
</p>

<p>
The \(\chi_{mn}\) are unknown and our goal is to prove the <a href="#orgd695e9c">above formula</a> for them. Now
consider
</p>

<p>
<a id="orgd24d882"></a>
</p>
\begin{align*}
  \Lambda R' \Lambda &= \frac{1}{4} \sum_{klmn} \chi_{mn} \Lambda (P_{kl} \otimes N_m P_{kl} N_n) \Lambda \\
  &= \frac{1}{4} \sum_{klmnab} \chi_{mn} \, L_a P_{kl} L_b \otimes R_a N_m P_{kl} N_n R_b \\
  &= \frac{1}{4} \sum_{klmnab} \chi_{mn} \, L_aR_a P_{kl} R_bL_b \otimes R_a N_m R_a P_{kl} R_b N_n R_b .
\end{align*}

<p>
For the last equality we used the fact that
</p>

<p>
\[
  \{P_{kl}|kl\} = \{R_aP_{kl}R_b|kl\}
\]
</p>

<p>
for all \(a,b\). In the following let us define the negation of a bit-value by \(\bar{a}\) and
the most significant bit of \(m\) as
</p>

<p>
\[
  \tilde{m} = \begin{cases} 0 & \text{if } m = 0,1 \\ 1 & \text{if } m = 2, 3 \end{cases} .
\]
</p>

<p>
In the same way \(\tilde{n}\) is defined to be the most significant bit of \(n\). These
definitions are handy because they help us further simplify \(\Lambda\?R'\Lambda\). Before
doing so observe
</p>

<p>
\[
  R_a N_n R_a = (-1)^{a\tilde{n}} N_n
\]
</p>

<p>
and
</p>

<p>
\[
  L_a R_a P_{kl} R_b L_b = (-1)^{\bar{a}k+\bar{b}l} P_{kl} .
\]
</p>

<p>
Hence
</p>

\begin{align*}
  \Lambda R' \Lambda &= \frac{1}{4} \sum_{klmnab} \chi_{mn} (-1)^{\bar{a}k+a\tilde{m}+\bar{b}l+b\tilde{n}}
  P_{kl} \otimes N_m P_{kl} N_n \\
  &= \sum_{mn} (-1)^{\tilde{m}+\tilde{n}} \chi_{mn} P_{\tilde{m}\tilde{n}} \otimes N_m P_{\tilde{m}\tilde{n}} N_n .
\end{align*}

<p>
The second equality can be seen from the fact that the term \(P_{kl}\otimes\?N_mP_{kl}N_n\)
does not depend on \(a\) or \(b\). Hence the summation over \(a,b\) does only yield a non-zero
term if \(k=\tilde{m}\) and \(l=\tilde{n}\). Let \(m=m_1m_0\) and \(n=n_1n_0\) be the binary
representation of \(m\) and \(n\). By what we have shown:
</p>

<p>
\[
  \Lambda R' \Lambda = \sum_{mn} (-1)^{m_1+n_1} \chi_{mn} P_{m_1n_1} \otimes N_m P_{m_1n_1} N_n .
\]
</p>

<p>
Observe that
</p>

<p>
\[
  N_m \ket{m_1} = (-1)^{m_1} \ket{\overline{m_1}^{\bar{m_0}}} ,
\]
</p>

<p>
where \(\bar{a}^0:=a\) and \(\bar{a}^1=\bar{a}\). Hence <a href="#orgd695e9c">the claim</a> follows. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orga9c2d77" class="outline-2">
<h2 id="orga9c2d77">Exercises</h2>
<div class="outline-text-2" id="text-orga9c2d77">
</div>
<div id="outline-container-exercise-8.1" class="outline-3">
<h3 id="exercise-8.1">Exercise 8.1 (Unitary evolution as a quantum operation)</h3>
<div class="outline-text-3" id="text-exercise-8.1">
<p>
Pure states evolve under unitary transforms as \(\ket{\psi}\mapsto\,U\ket{\psi}\). Show
that, equivalently, we may write \(\rho\mapsto\calE(\rho)\equiv\,U\rho\,U^\dagger\),
for \(\rho=\proj{\psi}\).
</p>
</div>

<div id="outline-container-orga049735" class="outline-4">
<h4 id="orga049735">Proof</h4>
<div class="outline-text-4" id="text-orga049735">
</div>
<div id="outline-container-org1652d8e" class="outline-5">
<h5 id="org1652d8e">Preparation</h5>
<div class="outline-text-5" id="text-org1652d8e">
<p>
This is a really basic question and it should actually be obvious <i>if</i> you really
understand the bra-ket notation (beware however that it might <i>appear</i> to be obvious if
you merely feel <i>familiar</i> with it).
</p>

<p>
To give a meaningful solution beyond "it is obvious" we take a step back and recall what
the <a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation">bra-ket</a> notation actually means. In quantum mechanics we always work on (complex)
Hilbert spaces. A Hilbert space is a (complex) vector space \(\calH\) equipped with a
<a href="https://en.wikipedia.org/wiki/Sesquilinear_form">sesquilinear form</a>, which has to obey certain axioms to be mentioned soon. We denote it by
</p>

<p>
\[
  (\ket{\psi}, \ket{\varphi}) .
\]
</p>

<p>
A sesquilinear form is a mapping \(\calH\times\calH\to\CC\) which is linear in the second
argument and conjugate-linear in the first argument. For a Hilbert space we require in
addition that (<b>positivity</b>)
</p>

<p>
\[
  \forall \ket{\psi} \in \calH\backslash\{0\}: \; (\ket{\psi}, \ket{\psi}) > 0 ,
\]
</p>

<p>
and that (<b>symmetry</b>)
</p>

<p>
\[
  \forall \ket{\psi}, \ket{\varphi} \in \calH : \; (\ket{\psi},\ket{\varphi})
  = \overline{(\ket{\varphi},\ket{\psi})} .
\]
</p>

<p>
(The bar means <i>complex conjugation</i>.) Such a sesquilinear form is called a <b>scalar
product</b>. This is what makes a complex <i><a href="https://en.wikipedia.org/wiki/Hilbert_space">Hilbert space</a></i>, a complex vector space equipped
with a scalar product. There are also real Hilbert spaces but we do not need them
here. Note that we are always talking about <i>finite</i> dimensional vector spaces. In case of
infinite dimensional vector spaces a <b><a href="https://en.wikipedia.org/wiki/Complete_metric_space">completeness</a></b> axiom is required in addition. (In the
finite dimensional case this axiom follows automatically from the <a href="https://en.wikipedia.org/wiki/Completeness_of_the_real_numbers">completeness</a> axiom of
real (and hence complex) numbers).
</p>

<p>
In the framework of Dirac's bra-ket notation the kets are just the elements of the Hilbert
space. We already used this in the above introduction. The bras are elements of the <i>dual
space</i> \(\calH^*\) which is just the space of linear maps \(\calH\to\CC\). For any
\(\ket{\psi}\in\calH\) an example of such a map is given by
</p>

<p>
\[
  \ket{\varphi} \mapsto (\ket{\psi}, \ket{\varphi}) .
\]
</p>

<p>
<a id="orga955cc6"></a> In fact, one can prove that any element of \(\calH^*\) (that
is, any linear map \(\calH\to\CC\)) can be written like this for a <i>unique</i>
\(\ket{\psi}\). This is called the <b>canonical isomorphism</b> between \(\calH\) and \(\calH^*\) (it
is called <i>canonical</i> since we could define it without knowing anything concrete about our
Hilbert space, in other words it is definable in the most abstract terms). Note that the
canonical isomorphism \(\iota\) is <i>conjugate</i> linear, that is,
\(\iota(\lambda\ket{\psi})=\bra{\psi}\lambda^*\).
</p>

<p>
This canonical isomorphism actually motivates the bras. A bra \(\bra{\psi}\in\calH^*\) is
the linear map given by
</p>

<p>
\[
  \bra{\psi} : \; \ket{\varphi} \mapsto \sprod{\psi}{\varphi} := (\ket{\psi}, \ket{\varphi}) .
\]
</p>

<p>
Having said that, terms like
</p>

<p>
\[
  \bra{\psi} U \ket{\varphi}
\]
</p>

<p>
are the same as
</p>

<p>
\[
  \bra{\psi} U \ket{\varphi} = (\bra{\psi}\circ U) \ket{\varphi} = (\ket{\psi}, U\ket{\varphi}) ,
\]
</p>

<p>
where \(\circ\) denotes the composition of functions (\(U\) and \(\bra{\psi}\) as linear maps
are both functions of course). And of course, the bra-ket notation also makes the above
introduced notation for the scalar product obsolete since basically the bra and the ket
are the left and right half of the scalar product.
</p>
</div>
</div>

<div id="outline-container-org9e4fdc9" class="outline-5">
<h5 id="org9e4fdc9">The actual proof</h5>
<div class="outline-text-5" id="text-org9e4fdc9">
<p>
Let us return to the actual exercise. We use the above notation \((\ldots,\ldots)\) for the
scalar product to make the derivation clearer. Let \(U\) be a unitary operator on \(\calH\)
and let
</p>

<p>
\[
  \rho = \rho_{\ket{\psi}} = \proj{\psi} .
\]
</p>

<p>
The task is to calculate \(\rho_{U\ket{\psi}}\) and to show that it is equal to
\(\calE(\rho_{\ket{\psi}})\). Note that \(\rho\) is a linear map \(\calH\to\calH\) given by
</p>

<p>
\[
  \rho \ket{\varphi} = \ket{\psi} \sprod{\psi}{\varphi} = (\ket{\psi}, \ket{\varphi}) \ket{\varphi} .
\]
</p>

<p>
Hence
</p>

\begin{align*}
  \rho_{U\ket{\psi}} \ket{\varphi} &= (U\ket{\psi}, \ket{\varphi}) U\ket{\psi} \\
  &= (\ket{\psi}, U^\dagger\ket{\varphi}) U\ket{\psi} \\
  &= \bra{\psi} U^\dagger \ket{\varphi} U\ket{\psi} \\
  &= U\ket{\psi} \bra{\psi} U^\dagger \ket{\varphi} \\
  &= U\rho_{\ket{\psi}} U^\dagger \ket{\varphi} .
\end{align*}

<p>
The first equality follows from the definition of \(\rho_{\ket{\psi}}\). The second one
follows from the definition of the (hermitian) <a href="https://en.wikipedia.org/wiki/Hermitian_adjoint">adjoint</a> operator. The third one is the
definition of the bras. The fourth equality just moves the complex number
\(\bra{\psi}U\ket{\varphi}\) to the right. The last equation is again the definition of
\(\rho_{\ket{\psi}}\).
</p>

<p>
Since the above eqation holds for all \(\varphi\) we have
</p>

<p>
\[
  \rho_{U\ket{\psi}} = U\rho_{\ket{\psi}} U^\dagger .
\]
</p>

<p>
QED.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
There is another slightly deeper way to see this result. Let us denote the
above mentioned <a href="#orga955cc6">canonical isomorphism</a> by
</p>

<p>
\[
  \iota(\ket{\psi}) = \bra{\psi} .
  \]
</p>

<p>
It is not hard to show and extension of the conjugate-linearity property of the
canonical isomorphism:
</p>

<p>
\[
  \iota(U\ket{\psi}) = \iota(\ket{\psi}) U^\dagger = \bra{\psi} U^\dagger .
  \]
</p>

<p>
In fact, the proof is even shorter than the proof of the claim of the exercise. That is,
the <i>canonical</i> way to associate a linear mapping \(\calH^*\to\calH^*\) with \(U\) is the
right composition with \(U^\dagger\). From this the claim of the exercise follows too.
</p></dd>
</dl>
</div>
</div>
</div>
</div>

<div id="outline-container-org4e5f6a6" class="outline-3">
<h3 id="org4e5f6a6">Exercise 8.2 (Measurement as a quantum operation)</h3>
<div class="outline-text-3" id="text-org4e5f6a6">
<p>
Recall from Section 2.2.3 (on page 84) that a quantum measurement with outcomes labeled by
\(m\) is described by a set of measurement operators \(M_m\) such that
\(\sum_mM_m^\dagger\,M_m=I\). Let the state of the system immediately before the measurement
be \(\rho\). Show that for \(\calE_m(\rho)=M_m\rho\,M_m^\dagger\), the state of the system
immediately after the measurement is
</p>

<p>
\[
  \frac{\calE_m(\rho)}{\trace{\calE_m(\rho)}} .
\]
</p>

<p>
Also show that the probability of obtaining this measurement result is
\(p(m)=\trace{\calE_m(\rho)}\).
</p>
</div>

<div id="outline-container-orgdf29ae4" class="outline-4">
<h4 id="orgdf29ae4">Solution</h4>
<div class="outline-text-4" id="text-orgdf29ae4">
<p>
Clearly the exercise assumes that we only know the postulates of quantum mechanics for
<i>pure</i> states as detailed in section 2.2.3 and not the generalization to mixed states as
detailed in 2.4.1. Otherwise the exercise would be a trivial restatement of the evolution
and measurement postulates.
</p>

<p>
Let us first assume that \(\rho=\proj{\psi}\) is a pure state (just expressed as a density
matrix). In order to compute the trace of an operator \(\sigma\) we can take <i>any</i>
orthonormal basis \(\{e\}\) and have \(\trace{\sigma}=\sum_{e}\bra{e}\sigma\ket{e}\). Let
\(\sigma=\proj{\nu}\) with a not necessarily normalized non-zero \(\ket{\nu}\). Without loss
of generality we may assume that \(\ket{\nu}/\norm{\nu}\) is part of our chosen ONB (this
follows from the <a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process">Gram-Schmidt</a> procedure). Hence
</p>

<p>
<a id="org8faeca1"></a>
\[
  \trace{\sigma} = \sum_{e} \bra{e}\proj{\nu}\ket{e}
  = \sprod{\nu}{\nu} \sprod{\nu}{\nu} / \norm{\nu}^2
  = \norm{\nu}^2 .
\]
</p>

<p>
Given a state \(\ket{\psi}\) the post measurement state after measuring \(m\) is
\(M_m\ket{\psi}/\norm{M_m\ket{\psi}}\). From the reasoning in <a href="#exercise-8.1">exercise 1</a> (that \(U\) was a
unitary operator didn't really matter there) we deduce that the corresponding density
matrix is
</p>

<p>
\[
  \frac{M_m \rho M_m^\dagger}{\norm{M_m\ket{\psi}}^2} .
\]
</p>

<p>
Using <a href="#org8faeca1">the equation</a> involving \(\sigma\) (with \(\ket{\nu}=M_m\ket{\psi}\)) we see that
\(\norm{M_m\ket{\psi}}^2=\trace{M_m\rho\,M_m^\dagger}\). Hence the post measurement state is
</p>

<p>
\[
  \frac{M_m \rho M_m^\dagger}{\trace{M_m\rho M_m^\dagger}} .
\]
</p>

<p>
The probability to measure \(m\) (and to obtain this state) is
</p>

<p>
\[
  p(m) = \norm{M_m\ket{\psi}}^2 = \trace{M_m \rho M_m^\dagger} .
\]
</p>

<p>
This concludes the exercise for pure states. Let \(\rho\) be a mixed state now. This means
that there is a decomposition
</p>

<p>
\[
  \rho = \sum_j p_j \proj{\psi_j}
\]
</p>

<p>
with strictly positive coefficients \(p_j\) such that \(\sum_jp_j=1\). The ensemble
interpretation says that having such a mixed state means that, upon measurement, one of
the pure states \(\ket{\psi_j}\) is taken at random with probability \(p_j\) and then the
measurement proceeds as in the pure state case. It is not a-priori clear that this is well
defined since the decomposition of \(\rho\) into pure states is not unique (c.f. Theorem 2.6
on page 103). But let us ignore this for the moment. We will see that the obtained
probabilities and the post measurement states are independent of the concrete
decomposition, hence the problem solves itself.
</p>

<p>
According to the ensemble interpretation the probability to measure \(m\) is
</p>

<p>
\[
  p(m) = \sum_j p(m|j) \, p_j = \sum_j \trace{M_m\proj{\psi_j} M_m^\dagger} \, p_j
  = \trace{M_m \rho M_m^\dagger} .
\]
</p>

<p>
Here
</p>

<p>
\[
  p(m|j) = \norm{M_m \ket{\psi_j}}^2 = \trace{M_m \proj{\psi_j} M_m^\dagger}
\]
</p>

<p>
is the conditioned probability to measure \(m\) if we already know that the pure state
\(\psi_j\) was chosen. Suppose we know that we measured \(m\). What is the (mixed) state in
that case? We already know that with (conditioned) probability \(p(j|m)\) the post
measurement state is
</p>

<p>
\[
  \frac{M_m\proj{\psi_j} M_m^\dagger}{p(m|j)} .
\]
</p>

<p>
But this is an ensemble of pure states! Hence, using \(p(m|j)p_j=p(m\cap\,j)=p(j|m)p(m)\),
the corresponding mixed state is
</p>

<p>
\[
  \sum_j p(j|m) \frac{M_m\proj{\psi_j} M_m^\dagger}{p(m|j)}
  = \frac{1}{p(m)} \sum_j p_j M_m\proj{\psi_j} M_m^\dagger
  = \frac{M_m\rho M_m^\dagger}{p(m)}
  = \frac{M_m\rho M_m^\dagger}{\trace{M_m\rho M_m^\dagger}} .
\]
</p>

<p>
This concludes the exercise. But let is briefly mention that in case we do <i>not</i> obtain
the outcome of the measurement the post measurement state is
</p>

<p>
<a id="orgde719ea"></a>
\[
  \sum_{m,j} p(m|j) p_j \, \frac{M_m \proj{\psi_j} M_m^\dagger}{p(m|j)}
  = \sum_m M_m \rho M_m^\dagger .
\]
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
Together with the conclusions from the actual exercise we can draw the
following additional conclusion: If now we somehow obtain the measurement result than
<a href="#orgde719ea">this sum</a> "collapses" into one of its summands (just normalized), with probability
\(\trace{M_m\rho\,M_m^\dagger}\) for each of them. That is, the measurement can be
decomposed into two parts: First the state changes to
</p>

<p>
\[
    \calE(\rho) = \sum_m \calE_m(\rho)
  \]
</p>

<p>
and then (if we obtain the measurement result) the state "collapses" into
\(\calE_m(\rho)/\trace{\calE_m(\rho)}\) for one of the \(m\) with probability
\(\trace{\calE_m(\rho)}\). So, the first part of the measurement can be expressed in terms
of quantum operations. But not the second part (since it is not deterministic and cannot
give rise to a mathematical function on density matrices).
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org2d4c5f4" class="outline-3">
<h3 id="org2d4c5f4">Exercise 8.3</h3>
<div class="outline-text-3" id="text-org2d4c5f4">
<p>
Our derivation of the operator-sum representation implicitly assumed that the input and
output spaces for the operation were the same. Suppose a composite system AB initially in
an unknown quantum state \(\rho\) is brought into contact with a composite system CD initially in
some standard state \(\ket{0}\), and the two systems interact according to a unitary interaction
\(U\). After the interaction we discard systems A and D, leaving a state \(\rho'\) of system
BC. Show that the map \(\calE(\rho)=\rho'\) satisfies
</p>

<p>
\[
  \calE(\rho) = \sum_k E_k \rho E_k^\dagger ,
\]
</p>

<p>
for some set of linear operators \(E_k\) from the state space of system AB to the state
space of system BC, and such that \(\sum_kE_k^\dagger\,E_k\).
</p>
</div>

<div id="outline-container-orge5e613a" class="outline-4">
<h4 id="orge5e613a">Proof</h4>
<div class="outline-text-4" id="text-orge5e613a">
<p>
Basically we do the same as the book for the special case of equal input and output
space. According to the exercise we have
</p>

<p>
\[
  \calE(\rho) = \ptrace{AD}{U \rho \otimes \proj{0} U^\dagger} .
\]
</p>

<p>
Let \(\{e_k\}\) be an orthonormal basis of AD. Hence
</p>

<p>
\[
  \calE(\rho) = \sum_k \bra{e_k} U \rho \otimes \proj{0} U^\dagger \ket{e_k} .
\]
</p>

<p>
Thus, defining \(E_k=\bra{e_k}U\ket{0}\), we have
</p>

<p>
\[
  \calE(\rho) = \sum_k E_k \rho E_k^\dagger .
\]
</p>

<p>
That is, \(\calE\) has the required form. We only have to show the completeness property
\(J:=\sum_kE_k^\dagger\,E_k=I_{AB}\). Note that \(J=J^\dagger\) is self-adjoint and
positive-definite. Let \(\rho\) be arbitrary and consider
</p>

<p>
\[
  1 = \ptrace{BC}{\calE(\rho)} = \sum_k \ptrace{BC}{E_k\rho E_k^\dagger}
  = \sum_k \ptrace{AB}{E_k^\dagger E_k \rho}
  = \ptrace{AB}{J^\dagger \rho} .
\]
</p>

<p>
Here we used the well-known <i>cyclicity property</i> of the trace (which also holds for
(matching) rectangular matrices). Thus
</p>

<p>
<a id="org2786d75"></a>
\[
  \forall \rho : \; \trace{(J-I)^\dagger \rho} = 0 .
\]
</p>

<p>
Here the quantification runs over all density operators (hermitian, positive definite,
trace 1).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>In case you wonder why I take the adjoint of \(J\). We have that
\(S,T\mapsto\trace{S^\dagger\,T}\) turns the matrix space \(\CC^{n\times\?n}\) into a
complex Hilbert space. See e.g. the definition of a Hilbert-Schmidt operator on
<a href="https://en.wikipedia.org/wiki/Hilbert%E2%80%93Schmidt_operator">wikipedia</a> (it is about infinite dimensional spaces but just note that in finite
dimensions every operator is a Hilbert-Schmidt operator). For this exercise it does not
directly help us since the quantification <a href="#org2786d75">above</a> is <i>not</i> over all
\(\rho\in\CC^{n\times\?n}\). But still nice to know ðŸ˜‰.</dd>
</dl>

<p>
Considering all rank-1 density matrices \(\rho=\proj{\psi}\) we deduce
</p>

<p>
\[
  \forall \ket{\psi} : \; \trace{(J-I)^\dagger \proj{\psi}} = \bra{\psi} (J-I)^\dagger \ket{\psi} = 0 .
\]
</p>

<p>
(The first equality can either be seen by the cyclicity property of the trace or by using
an ONB which involves \(\psi\) (but normalized) as one of its elements) But this can only be
true (for all normalized \(\ket{\psi}\)) if \(J=I\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-8.4" class="outline-3">
<h3 id="exercise-8.4">Exercise 8.4 (Measurement)</h3>
<div class="outline-text-3" id="text-exercise-8.4">
<p>
Suppose we have a single qubit principal system, interacting with a single qubit
environment through the transform
</p>

<p>
\[
  U = P_0 \otimes I + P_1 \otimes X
\]
</p>

<p>
where \(X\) is the usual Pauli matrix (acting on the environment), and \(P_0\equiv\proj{0}\),
\(P_1\equiv\proj{1}\) are projectors (acting on the system). Give the quantum operation for
this process, in the operator-sum representation, assuming the environment starts in the
state \(\ket{0}\).
</p>
</div>

<div id="outline-container-org4f465eb" class="outline-4">
<h4 id="org4f465eb">Solution</h4>
<div class="outline-text-4" id="text-org4f465eb">
<p>
Note that \(U\) is nothing else than the <code>CNOT</code> gate. Let us label the environment by E. One
way to define the operation elements is
</p>

\begin{align*}
  E_0 &= \bra{0_E} U \ket{0_E} = P_0 \sprod{0_E}{0_E} + P_1 \bra{0_E}X\ket{0_E} = P_0 , \\
  E_1 &= \bra{1_E} U \ket{0_E} = P_0 \sprod{1_E}{0_E} + P_1 \bra{1_E}X\ket{0_E} = P_1 .
\end{align*}

<p>
(The \(\ket{0_E}\) to the right of \(U\) comes from the initial state of the environment.)
Hence
</p>

<p>
\[
  \calE(\rho) = P_0 \rho P_0 + P_1 \rho P_1 = \begin{bmatrix} \rho_{00} & 0 \\ 0 & \rho_{11} \end{bmatrix} .
\]
</p>

<p>
That is, this operation acts like the first part of a measurement. It describes the state
after a measurement in the Z-basis if nobody tells us the measurement outcome. Once we get
the outcome the state "collapses" to one of the two summands (properly normalized of
course). The respective probabilities are \(\rho_{00}\) (for outcome \(0\)) and \(\rho_{11}\)
(for outcome \(1\)).
</p>
</div>
</div>
</div>

<div id="outline-container-org82bfaf4" class="outline-3">
<h3 id="org82bfaf4">Exercise 8.5 (Spin flips)</h3>
<div class="outline-text-3" id="text-org82bfaf4">
<p>
Just as in the previous exercise, but now let
</p>

<p>
\[
  U = \frac{1}{\sqrt{2}} \left( X \otimes I + Y \otimes X \right) .
\]
</p>

<p>
Give the quantum operation for this process, in the operator-sum representation.
</p>
</div>

<div id="outline-container-orgdba056a" class="outline-4">
<h4 id="orgdba056a">Solution</h4>
<div class="outline-text-4" id="text-orgdba056a">
<p>
First of all let us make sure that \(U\) really is unitary. We have \(U^\dagger=U\), hence
</p>

<p>
\[
  U^\dagger U = U^2 = \frac{1}{2} \left( X^2 \otimes I + Y^2 \otimes X^2 + (XY+YX)\otimes X \right) = I .
\]
</p>

<p>
Hence \(U\) is indeed unitary. One way to define the operation elements is as follows:
</p>

\begin{align*}
  E_0 &= \bra{0_E} U \ket{0_E} = X \sprod{0_E}{0_E} + Y \bra{0_E}X\ket{0_E} = X , \\
  E_1 &= \bra{1_E} U \ket{0_E} = X \sprod{1_E}{0_E} + Y \bra{1_E}X\ket{0_E} = Y .
\end{align*}

<p>
Hence
</p>

<p>
\[
  \calE(\rho) = \frac{1}{2} \left(X \rho X + Y \rho Y \right)
  = \begin{bmatrix} \rho_{11} & 0 \\ 0 & \rho_{00} \end{bmatrix} .
\]
</p>

<p>
Interpreting this in the same way as in <a href="#exercise-8.4">exercise 8.4</a> we deduce that \(\calE\) corresponds to
a spin-flip followed by a measurement (without obtaining the measurement outcome).
</p>
</div>
</div>
</div>

<div id="outline-container-orgd91e06e" class="outline-3">
<h3 id="orgd91e06e">Exercise 8.6 (Composition of quantum operations)</h3>
<div class="outline-text-3" id="text-orgd91e06e">
<p>
Suppose \(\calE\) and \(\calF\) are quantum operations on the same quantum system. Show that
the composition \(\calF\circ\calE\) is a quantum operation, in the sense that it has an
operator-sum representation. State and prove an extension of this result to the case where
\(\calE\) and \(\calF\) do not necessarily have the same input and output spaces.
</p>
</div>

<div id="outline-container-org2d3635d" class="outline-4">
<h4 id="org2d3635d">Proof</h4>
<div class="outline-text-4" id="text-org2d3635d">
<p>
Suppose
</p>

\begin{align*}
  \calE(\rho) &= \sum_i E_i \rho E_i^\dagger , \\
  \calF(\rho) &= \sum_j F_j \rho F_j^\dagger .
\end{align*}

<p>
Then
</p>

\begin{align*}
  \calF \circ \calE(\rho) = \sum_{ij} F_j E_i \rho E_i^\dagger F_j^\dagger .
\end{align*}

<p>
This suggests to use all the \(F_jE_i\) as operation elements of the composition. That
\(\calF\circ\calE\) is indeed a quantum operation now follows from
</p>

<p>
\[
  \sum_{ij} E_i^\dagger F_j^\dagger F_j E_i = \sum_i E_i^\dagger E_i = I .
\]
</p>

<p>
The proof directly generalizes (without any change) to the case where \(\calE:A\to\?B\) and
\(\calF:B\to\?C\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orga14d843" class="outline-3">
<h3 id="orga14d843">Exercise 8.7</h3>
<div class="outline-text-3" id="text-orga14d843">
<p>
Suppose that instead of doing a projective measurement on the combined principal system
and environment we had performed a general measurement described by measurement operators
\(\{M_m\}\). Find operator-sum representations for the corresponding quantum operations
\(\{\calE_m\}\) on the principal system, and show that the respective measurement
probabilities are \(\trace{\calE_m(\rho)}\).
</p>
</div>

<div id="outline-container-org0bec94a" class="outline-4">
<h4 id="org0bec94a">Solution</h4>
<div class="outline-text-4" id="text-org0bec94a">
<p>
Let \(\sigma=\sum_jq_j\proj{j}\) be the state of the environment E. The generalized
operations look as follows
</p>

<p>
\[
  \calE_m(\rho) = \ptrace{E}{M_m U \rho\otimes\sigma U^\dagger M_m^\dagger} .
\]
</p>

<p>
According to the posutulates the probability to measure \(m\), after an evolution with \(U\),
is
</p>

<p>
\[
  p(m) = \trace{M_m U \rho\otimes\sigma U^\dagger M_m^\dagger} = \trace{\calE_m(\rho)} .
\]
</p>

<p>
Here we use the property \(\trace{\ptrace{E}{A}}=\trace{A}\) of the partial trace. The
post-measurement state for the whole system is is
</p>

<p>
\[
  \frac{M_m U \rho\otimes\sigma U^\dagger M_m^\dagger}{p(m)} ,
\]
</p>

<p>
and for the principal system it is
</p>

<p>
\[
  \ptrace{E}{\frac{M_m U \rho\otimes\sigma U^\dagger M_m^\dagger}{p(m)}}
  = \frac{\calE_m(\rho)}{\trace{\calE_m(\rho)}} .
\]
</p>

<p>
It is not hard to see that for any choice of an ONB \(\{e_k\}\) on E the operators
</p>

<p>
\[
  E_{jk} = \sqrt{q_j} \bra{e_k} M_m U \ket{j}
\]
</p>

<p>
are elements for the operation \(\calE_m\), which also satisfy
\(\sum\?E_{jk}^\dagger\?E_{jk}\leq\?I\):
</p>

<p>
\[
  \sum_{jk} E_{jk}^\dagger E_{jk}
  = \sum_{jk} q_j \bra{j}U^\dagger M_m^\dagger \ket{e_k} \bra{e_k} M_m U \ket{j}
  = \sum_j q_j \bra{j}U^\dagger M_m^\dagger M_m U \ket{j}
  \leq \sum_j q_j \bra{j}U^\dagger U \ket{j}
  = \sum_j q_j = I .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org3320c65" class="outline-3">
<h3 id="org3320c65">Exercise 8.8 (Non-trace-preserving quantum operations)</h3>
<div class="outline-text-3" id="text-org3320c65">
<p>
Explain how to construct a unitary operator for a systemâ€“environment model of a
non-trace-preserving quantum operation, by introducing an extra operator, \(E_\infty\), into the
set of operation elements \(E_k\), chosen so that when summing over the complete set of \(k\),
including \(k=\infty\), one obtains \(\sum_kE_k^\dagger\?E_k=I\).
</p>
</div>

<div id="outline-container-org8e3220f" class="outline-4">
<h4 id="org8e3220f">Solution</h4>
<div class="outline-text-4" id="text-org8e3220f">
<p>
Let us define
</p>

<p>
\[
  E_\infty = \sqrt{I - \sum_k E_k^\dagger E_k} .
\]
</p>

<p>
Clearly \(E_\infty^\dagger=E_\infty\) and
</p>

<p>
\[
  \sum_k' E_k^\dagger E_k = I .
\]
</p>

<p>
Here and in the following we let \(\sum_k'\) denote the sum over all \(k\) including
\(k=\infty\). On the other hand \(\sum_k\) excludes \(k=\infty\).
</p>

<p>
As in the book consider an environment described by a Hilbert space which has a basis
\(\{\ket{e_k}\}\) (including \(k=\infty\)). Define \(U\) by
</p>

<p>
\[
  U \ket{\psi} \ket{e_0} \equiv \sum_k' E_k \ket{\psi} \ket{e_k}
\]
</p>

<p>
and unitary extension to the full system - exactly as in the book. Consider the following
projection defined on E:
</p>

<p>
\[
  P = I_E - \proj{e_\infty} .
\]
</p>

<p>
We shall prove that
</p>

<p>
\[
  \calE(\rho) = \ptrace{E}{PU \rho\otimes \proj{e_0} U^\dagger P} .
\]
</p>

<p>
In fact, the RHS equals
</p>

<p>
\[
  \ptrace{E}{\sum_{kl}' E_k \rho E_l^\dagger \otimes P \ket{e_k}\bra{e_l} P}
  = \ptrace{E}{\sum_{kl} E_k \rho E_l^\dagger \otimes \ket{e_k}\bra{e_l} }
  = \sum_{k} E_k \rho E_k^\dagger
  = \calE(\rho)
\]
</p>

<p>
as desired.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdbbc8cb" class="outline-3">
<h3 id="orgdbbc8cb">Exercise 8.9 (Measurement model)</h3>
<div class="outline-text-3" id="text-orgdbbc8cb">
<p>
If we are given a set of quantum operations \(\{\calE_m\}\) such that \(\sum_m\calE_m\) is
trace-preserving, then it is possible to construct a measurement model giving rise to this
set of quantum operations. For each \(m\), let \(E_{mk}\) be a set of operation elements for
\(\calE_m\). Introduce an environmental system, E, with an orthonormal basis \(\ket{m,k}\) in
one-to-one correspondence with the set of indices for the operation elements. Analogously
to the earlier construction, define an operator \(U\) such that
</p>

<p>
\[
  U \ket{\psi} \ket{e_0} = \sum_{mk} E_{mk} \ket{\psi} \ket{m,k} .
\]
</p>

<p>
Next, deï¬ne projectors \(P_m=\sum_k\proj{m,k}\) on the environmental system, E.  Show that
performing \(U\) on \(\rho\otimes\proj{e_0}\), then measuring \(P_m\) gives \(m\) with probability
\(\trace{\calE_m(\rho)}\), and the corresponding post-measurement state of the principal
system is \(\calE_m(\rho)/\trace{\calE_m(\rho)}\).
</p>
</div>

<div id="outline-container-org702c4f4" class="outline-4">
<h4 id="org702c4f4">Solution</h4>
<div class="outline-text-4" id="text-org702c4f4">
<p>
That \(U\) can be extended to a unitary operator can be seen as in the other cases of
constructing an environment model. We have
</p>

\begin{align*}
  \ptrace{E}{P_m U \rho \otimes \proj{e_0} U^\dagger P_m}
  &= \ptrace{E}{\sum_{m,k,l} E_{mk}\rho E_{ml}^\dagger \otimes \ket{m,k}\bra{m,l}} \\
  &= \sum_{m,k} E_{mk}\rho E_{mk}^\dagger \\
  &= \calE_m(\rho) .
\end{align*}

<p>
Hence, using \(\trace{\ptrace{E}{\ldots}}=\trace{\ldots}\), the probability to measure \(m\)
after applying \(U\) to \(\rho\otimes\proj{e_0}\) is
</p>

<p>
\[
  p(m) = \trace{P_m U \rho \otimes \proj{e_0} U^\dagger P_m} = \trace{\calE_m(\rho)} .
\]
</p>

<p>
The post-measurement state of the whole system is
</p>

<p>
\[
  \frac{P_m U \rho \otimes \proj{e_0} U^\dagger P_m}{p(m)} .
\]
</p>

<p>
Taking the partial trace of the environment yields the post-measurement state of the
principal system
</p>

<p>
\[
  \frac{\ptrace{E}{P_m U \rho \otimes \proj{e_0} U^\dagger P_m}}{p(m)}
  = \frac{\calE_m(\rho)}{\trace{\calE_m(\rho)}} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-8.10" class="outline-3">
<h3 id="exercise-8.10">Exercise 8.10</h3>
<div class="outline-text-3" id="text-exercise-8.10">
<p>
Give a proof of Theorem 8.3 based on the freedom in the operator-sum representation, as
follows. Let \(\{E_j\}\) be a set of operation elements for \(\calE\). Define a matrix
\(W_{jk}=\trace{E_j^\dagger\?E_k}\). Show that the matrix \(W\) is Hermitian and of rank at
most \(d^2\), and thus there is unitary matrix \(u\) such that \(uWu^\dagger\) is diagonal with
at most \(d^2\) non-zero entries. Use \(u\) to deï¬ne a new set of at most \(d^2\) non-zero
operation elements \(\{F_j\}\) for \(\calE\).
</p>
</div>

<div id="outline-container-orge0fdf38" class="outline-4">
<h4 id="orge0fdf38">Proof 1</h4>
<div class="outline-text-4" id="text-orge0fdf38">
<p>
The statement is a direct consequence of the proof of Kraus's Theorem as given in the book
(Theorem 8.1). Recall that the diagonalization of \(\sigma\)
</p>

<p>
\[
  \sigma = \sum_{k=1}^M \proj{s_k}
\]
</p>

<p>
is used to define the operation elements by
</p>

<p>
\[
  E_k \ket{\psi} = \braket{\tilde{\psi}}{s_k}
\]
</p>

<p>
That is, there are precisely \(M\) elements to be defined. How large can \(M\) be? Recall that
\(\sigma\) is a density matrix on the Hilbert space \(\calH_R\otimes\calH_Q\) of the joint
system \(RQ\). By assumption \(d=\dim(\calH_Q)\) and by construction
\(\dim(\calH_R)=\dim(\calH_Q)=d\). Hence
</p>

<p>
\[
  \dim(\calH_R\otimes\calH_Q) = d^2 .
\]
</p>

<p>
Hence \(\sigma\in\CC^{d^2\times\?d^2}\) and therefore \(M\leq\?d^2\). QED.
</p>
</div>
</div>

<div id="outline-container-exercise-8.10-proof-2" class="outline-4">
<h4 id="exercise-8.10-proof-2">Proof 2</h4>
<div class="outline-text-4" id="text-exercise-8.10-proof-2">
<p>
The matrix \(W\) is hermitian because
</p>

<p>
\[
  W_{kj}^* = \trace{E_k^\dagger E_j}^*
  = \trace{(E_k^\dagger E_j)^\dagger}
  = \trace{E_j^\dagger E_k}
  = W_{jk} .
\]
</p>

<p>
Let \(\calH\) be the \(d\)â€‹-dimensional Hilbert space on which the \(E_k\) operate. Recall that
</p>

<p>
\[
  A, B \mapsto \trace{A^\dagger B}
\]
</p>

<p>
is a scalar product on the \(d^2\)â€‹-dimensional space of linear operators on \(\calH\) (see
<a href="https://en.wikipedia.org/wiki/Hilbert%E2%80%93Schmidt_operator">Hilbert-Schmidt space</a>). It turns it into a Hilbert space. The claim that
\(\rank{W}\leq\?d^2\) thus follows from the following lemma (with \(N=d^2\)).
</p>

<p>
<a id="orgc2f0d08"></a>
</p>
<dl class="org-dl">
<dt>Lemma</dt><dd><p>
Let \(\{v_j\}_{j=1..M}\) be a bunch of vectors of an \(N\)â€‹-dimensional complex
Hilbert space \(V\) and define
</p>

<p>
\[
  W_{jk} = \braket{v_j}{v_k} .
  \]
</p>

<p>
Then \(\rank{W}\leq\?N\).
</p>

<dl class="org-dl">
<dt>Proof</dt><dd><p>
Let \(\{b_n\}_{n=1..N}\) be an ONB of \(V\). Hence there are unique numbers
\(A_{jn}\in\CC\) such that
</p>

<p>
\[
    v_j = \sum_{n=1}^N A_{jn} b_n .
    \]
</p>

<p>
Interpreted as a matrix we have \(A\in\CC^{M\times\?N}\), hence (the rank is always at
most the minimum of the two dimensions)
</p>

<p>
\[ \rank{A} \leq \min(M, N) \leq N . \]
</p>

<p>
Consider
</p>

<p>
\[
    W_{jk} = \braket{v_j}{v_k} = \sum_{nm} A_{jn}^* A_{km} \braket{b_n}{b_m}
    = \sum_n A_{jn}^* A_{kn}
    = (AA^\dagger)_{kj}
    \]
</p>

<p>
Hence
</p>

<p>
\[ W = \left(AA^\dagger \right)^\top \]
</p>

<p>
Recall that transposition and conjugation does not change the rank of a
matrix. Moreover \(\rank{AB}\leq\min(\rank{A},\rank{B})\) for any two matrices
\(A,B\). The last thing follows easily from the characterization of the rank as the
dimension of the image of a linear mapping. Hence
</p>

<p>
\[
    \rank{W} \leq \rank{A} \leq N .
    \]
</p>

<p>
QED.
</p></dd>
</dl></dd>
</dl>

<p>
Let \(M\) be the number of elements. Hence \(W\in\CC^{M\times\?M}\). Since \(W\) is hermitian
there is a uniatry matrix \(u\in\CC^{M\times\?M}\) such that
</p>

<p>
\[
  D = u W u^\dagger
\]
</p>

<p>
is diagonal. Observe that
</p>

<p>
\[
  D_{jk} = \sum_{mn} u_{jm} W_{mn} u_{kn}^*
  = \trace{\left(\sum_m u_{jm}^* E_m \right)^\dagger \left( \sum_n u_{kn}^* E_n \right)} .
\]
</p>

<p>
Hence defining \(F_k=\sum_nu_{kn}^*E_n\) we have
</p>

<p>
\[
  D_{jk} = \trace{F_j^\dagger F_k} .
\]
</p>

<p>
We note two things:
</p>

<ul class="org-ul">
<li>Since \(D\) is diagonal the \(F_j\) are actual orthogonal with respect to the
Hilbert-Schmidt scalar product.</li>
<li>Since \(\rank{D}=\rank{W}\leq\?d^2\) only at most \(d^2\) of the \(F_j\) are non-zero
(\(\trace{F^\dagger\?F}=0\) implies \(F=0\)).</li>
</ul>

<p>
This concludes the proof. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org40b0861" class="outline-3">
<h3 id="org40b0861">Exercise 8.11</h3>
<div class="outline-text-3" id="text-org40b0861">
<p>
Suppose \(\calE\) is a quantum operation mapping a \(d\)â€‹-dimensional input space to a
\(d'\)â€‹-dimensional output space. Show that \(\calE\) can be described using a set of at most
\(dd'\) operation elements \(\{E_k\}\).
</p>
</div>

<div id="outline-container-org8ca4153" class="outline-4">
<h4 id="org8ca4153">Proof</h4>
<div class="outline-text-4" id="text-org8ca4153">
<p>
With a minor adaption we can reduce this to <a href="#exercise-8.10-proof-2">one of the proofs</a> of <a href="#exercise-8.10">exercise 8.10</a>. Let
</p>

<p>
\[
  d_1 = \max(d, d') .
\]
</p>

<p>
Then \(E_k\in\CC^{d\times\?d'}\). By padding with zeros we can interpret the \(E_k\) as
elements of a \(dd'\)â€‹-dimensional subspace \(V\) of \(\CC^{d_1\times\?d_1}\). Note that this
does not affect the definition of \(W\).
</p>

<p>
Now the proof of the special case \(d=d'\) goes through as is. The crucial thing to note is
that the <a href="#orgc2f0d08">lemma</a> has to be applied with \(N=dd'\) and the just defined Hilbert space \(V\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc84dc38" class="outline-3">
<h3 id="orgc84dc38"><span class="todo WIP">WIP</span> Exercise 8.12</h3>
<div class="outline-text-3" id="text-orgc84dc38">
<p>
Why can we assume that \(O\) has determinant \(1\) in the decomposition (8.93)?
</p>

<p>
<a id="org6f1e598"></a>
</p>
<dl class="org-dl">
<dt>Remark</dt><dd>In <i>a sense</i> my solution below solves the exercise. But I have the vague
feeling that it is not meant like that. Playing around with examples I have the
impression that \(\det(M)\geq0\) just holds always. At the moment I can only prove this
for a special case (see <a href="#exercise-8.16">exercise 8.16</a>). I do not even know if it is hard to prove. I
have the feeling that it should not be so hard, but I still do not see it.</dd>
</dl>
</div>

<div id="outline-container-org46c9e6d" class="outline-4">
<h4 id="org46c9e6d">Maybe not a solution</h4>
<div class="outline-text-4" id="text-org46c9e6d">
<p>
As a real orthogonal matrix \(O\) has \(\det(O)=\pm1\). To see this recall that the
determinant is the product of all eigenvalues which are <i>complex</i> number of modulus 1 for
an orthogonal matrix (which is unitary if interpreted as a complex matrix). But the
determinant of a real matrix is real, hence only \(\pm1\) is possible for their product.
</p>

<p>
If the determinant is already \(1\) we are done. Otherwise just replace \(O\) by \(-O\) and \(S\)
by \(-S\). Of course this we destroy the property that \(S\) is positive.
</p>
</div>
</div>
</div>

<div id="outline-container-org32160dd" class="outline-3">
<h3 id="org32160dd">Exercise 8.13</h3>
<div class="outline-text-3" id="text-org32160dd">
<p>
Show that unitary transformations correspond to rotations of the Bloch sphere.
</p>
</div>

<div id="outline-container-org8bf8874" class="outline-4">
<h4 id="org8bf8874">Solution</h4>
<div class="outline-text-4" id="text-org8bf8874">
<p>
Probably the idea is to prove it via the findings of the section (probably using the
formulas for \(M_{jk}\) and \(c_k\)). Why else would this problem be in this chapter? But I
have not succeeded in doing so.
</p>

<p>
On the other hand we already know that claim and used it in earlier chapters. Therefore I
only sketch the proof. Essentially the problem is equivalent to <a href="chapter_4.html#exercise-4-6">exercise 4.6</a>. To see this
recall that every unitary operator is equal to some rotation \(R_{\hat{n}}(\theta)\) around
some axis and some angle - up to a global phase. I have also made a small discussion for
the (easy) step to generalize the statement of the exercise to density matrix in <a href="chapter_4.html#orgd4d3d64">chapter
4</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb2e34c2" class="outline-3">
<h3 id="orgb2e34c2">Exercise 8.14</h3>
<div class="outline-text-3" id="text-orgb2e34c2">
<p>
Show that \(\det(S)\) (From the polar decomposition of \(M=OS\)) need not be positive.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>I assume that <i>positive</i> means <i>strictly greater than zero</i> here. Sometimes
zero is included for positivity so it is always a bit unclear what is meant. There are
two reasons to see it this way:

<ul class="org-ul">
<li><p>
The <i>polar decomposition</i> explicitly states that there is an orthogonal matrix \(O\) and
a <i>positive</i> matrix \(S\) (Moreover \(S\) is unique and \(O\) is unique on the support of
\(S\)). Coincidentally here we already have a case were <i>positive</i> actually means that
\(0\) is included, because it is defined as
</p>

<p>
\[ \forall\ket{\psi}\neq0: \; \bra{\psi} S \ket{\psi} \geq 0 . \]
</p>

<p>
In particular \(S=0\), or more generally that the kernel of \(S\) is non-trivial, is a
possibility.
</p>

<p>
But <i>positivity</i> implies \(\det(S)\geq0\). Hence \(0\) can be the only violation of being
"positive". Hence the strict interpretation of "positive" in this exercise. A loop
hole would be that the exercise is somehow meant in some other way going away from the
polar decomposition.
</p></li>
<li>The second reason is that I believe that \(\det(M)\geq0\) always holds. See also my
<a href="#org6f1e598">remark</a> in exercise 8.12. If this is true I do not see any way to interpret the
exercise in a way such that <i>not positive</i> means <i>strictly negative</i>.</li>
</ul></dd>
</dl>
</div>

<div id="outline-container-orgd389060" class="outline-4">
<h4 id="orgd389060">Solution</h4>
<div class="outline-text-4" id="text-orgd389060">
<p>
For the <i>bit-flip</i> (\(E_0=\sqrt{p}I\), \(E_1=\sqrt{1-p}X\)) we have
</p>

<p>
\[
  M = \diag(1, 2p-1, 2p-1)
\]
</p>

<p>
(and \(c=0\)). See chapter 8.3.3 or look into my <a href="#org2846d0c">sage code</a>. Clearly for \(p=1/2\) we have
\(\det(M)=0\). In that case \(S=\sqrt{M^\dagger\?M}=M\) (and you could choose \(O=I\)). Hence
also \(\det(S)=0\).
</p>
</div>
</div>
</div>

<div id="outline-container-org70ec5de" class="outline-3">
<h3 id="org70ec5de">Exercise 8.15</h3>
<div class="outline-text-3" id="text-org70ec5de">
<p>
Suppose a projective measurement is performed on a single qubit in the basis \(\ket{+}\),
\(\ket{-}\), where \(\ket{\pm}=(\ket{0}\pm\ket{1})/\sqrt{2}\). In the event that we are
ignorant of the result of the measurement, the density matrix evolves according to the
equation
</p>

<p>
\[
  \rho \mapsto \calE(\rho) = \proj{+}\rho\proj{+} + \proj{-}\rho\proj{-} .
\]
</p>

<p>
Illustrate this transformation on the Bloch sphere.
</p>
</div>

<div id="outline-container-orgf23442b" class="outline-4">
<h4 id="orgf23442b">Solution</h4>
<div class="outline-text-4" id="text-orgf23442b">
<p>
We reduce this to a known problem by transforming the operation into a phase-flip. This
has the advantage that we already know what it does in the Bloch-sphere, and even if not,
it is an easier problem since we can work in the standard basis (and know for example how
the matrices of the Pauli matrices look like in that basis).
</p>

<p>
Let \(H=(X+Z)/\sqrt{2}\) be the Hadamard transform (note that \(H^\dagger=H\) and
\(H^2=1\)). Recall that it swaps \(X\) and \(Z\) as well their eigenspace projectors
(\(\ket{\pm}\) are the eigenvectors of \(X\)). Hence
</p>

<p>
\[
  \calE'(\rho) = H \calE(H\rho H) H = \proj{0}\rho\proj{0} + \proj{1}\rho\proj{1} .
\]
</p>

<p>
Note that \(\calE'\) is just the phase flip and we already know what it is. In the Bloch
sphere it corresponds to a projection onto the z-axis (see chapter 8.3.3):
</p>

<p>
\[
  M' = \diag(0, 0, 1), \; c' = 0 .
\]
</p>

<p>
In the Bloch-sphere interpretation of unitary operator \(H\) acts as a rotation around
\((\hat{x}+\hat{z})/\sqrt{2}\) by 180Â°. It swaps \(\hat{x}\) and \(\hat{z}\) and negates
\(\hat{y}\), that is, as a rotation in the Bloch sphere \(\rho\mapsto\?H\rho\?H\) is given by
this matrix:
</p>

<p>
\[
  T = \begin{bmatrix}
    0 &  0 & 1 \\
    0 & -1 & 0 \\
    1 &  0 & 0 \end{bmatrix} .
\]
</p>

<p>
Hence the following describes \(\calE\):
</p>

<p>
\[
  M = TM'T = \diag(1, 0, 0), \; c = Tc' = 0 .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-8.16" class="outline-3">
<h3 id="exercise-8.16">Exercise 8.16</h3>
<div class="outline-text-3" id="text-exercise-8.16">
<p>
The graphical method for understanding single qubit quantum operations was derived for
trace-preserving quantum operations. Find an explicit example of a non-trace-preserving
quantum operation which cannot be described as a deformation of the Bloch sphere, followed
by a rotation and a displacement.
</p>
</div>

<div id="outline-container-org7df9de8" class="outline-4">
<h4 id="org7df9de8">Solution</h4>
<div class="outline-text-4" id="text-org7df9de8">
<p>
Before delivering an example I find it instructive to discover what violations are even
possible from dropping the trace preservation property. Hence the solution is divided into
two parts.
</p>
</div>

<div id="outline-container-org66cd2af" class="outline-5">
<h5 id="org66cd2af">What does still hold?</h5>
<div class="outline-text-5" id="text-org66cd2af">
<p>
Let \(E\) be an <i>arbitrary</i> linear operator on \(\CC^2\) and let us consider the following
quantum operation
</p>

<p>
\[
  \calE(\rho) = E \rho E^\dagger .
\]
</p>

<p>
Note that <i>physicality</i> (\(\trace{\calE(\rho)}\leq1\)) might be violated for some \(\rho\) but
for this exercise physicality is not really relevant. It could always be restored by
multiplication with a small \(\varepsilon\?>\?0\).
</p>

<p>
Note that from Kraus' theorem we know that an arbitrary single-qubit operation needs up to
four operation elements (c.f. <a href="#exercise-8.10">exercise 8.10</a>). We try to generalize some of our findings at
the end. But for now let us only consider the one-element case.
</p>

<p>
Normally \(\calE\) only acts on density operators, that is, operators of the form
</p>

<p>
\[
  \rho = 1 + x X + y Y + z Z ,
\]
</p>

<p>
where \(x,y,z\in\RR\). <b>For notational convenience we left out the factor \(1/2\).</b> It does
not really matter for our purposes. Note that the space of such matrices is a
three-dimensional <i>real-affine</i> subspace of \(\CC^{2\times2}\equiv\CC^4\). We already know
from the book (see also <a href="#chapter-8-bloch-M-c">my calculations</a> above) that trace-preserving operations map this
space into an real-affine subspace of \(\CC^{2\times2}\). Fixing \(I\) as the origin of these
spaces the resulting mapping is real-affine-linear (not sure how to say it correctly).
</p>

<p>
It simplifies matters to consider the larger (four-dimensional) real <i>linear</i> (without the
<i>affine</i>) subspace \(S\) consisting of the following matrices:
</p>

<p>
\[
  \rho = e + x X + y Y + z Z ,
\]
</p>

<p>
where \(e,x,y,z\in\RR\). Note that <i>any</i> matrix in \(\CC^{2\times2}\) can be written like that
but with <i>complex</i> coefficients (indeed: \(I,X,Y,Z\) is an ONB with respect to the scalar
product \(A,B\mapsto\trace{A^\dagger\?B}\)). In particular \(E\) can be written as
</p>

<p>
\[
  E = sI + uX + vY + wZ
\]
</p>

<p>
for \(s,u,v,w\in\CC\). Let us prove the following Lemma.
</p>

<dl class="org-dl">
<dt>Lemma</dt><dd>Any quantum operation (trace-preserving or not) acts as a <i>real</i>-linear map
from \(S\) to itself.
<dl class="org-dl">
<dt>Proof</dt><dd><p>
Let us conveniently write \(\rho=(e,x,y,z)\) in the basis \((I,X,Y,Z)\). We have
</p>

<p>
\[
    X\rho Y = (-\ii z, y, x, \ii e) \text{ and } Y\rho X = (\ii z, y, x, -\ii e) .
    \]
</p>

<p>
Certainly you can see the pattern here and generalize it to the other two
Pauli-operator pairs. Moreover
</p>

<p>
\[
    X\rho X = (e, x, -y, -z) ,
    \]
</p>

<p>
and analogously for the other two Pauli-operators. Hence
</p>

<p>
\[ \rho\mapsto\?uX\rho\?u^*X = (\chi e, \chi x, -\chi y, -\chi z) \]
</p>

<p>
where \(\chi=\abs{u}^2\). Hence this type of transformation is <i>real</i>-linear. On the
other hand it is easy to see that
</p>

<p>
\[
    uX \rho v^*Y + vY \rho u^* X = (-\beta z, \alpha y, \alpha x, \beta e)
    \]
</p>

<p>
where \(\alpha=2\Re(u^*v)\) and \(\beta=\ii\?uv^*-\ii\?u^*v=2\Im(u^*v)\). Hence this
transformation is also real-linear. Observe that
</p>

<p>
\[
    E \rho E^\dagger
    \]
</p>

<p>
can be decomposed into a sum of transformations similar to the proceeding ones. Hence
it is real linear too. Since a quantum operation is a sum of such one-element
operations it follows that any quantum operation is real linear. QED.
</p></dd>
</dl></dd>
</dl>


<p>
Clearly a map is trace-preserving if it maps the affine subspace described by \(e=1\) into
itself (works for any affine subspace defined by setting \(e\) to a non-zero
constant). Hence, we derived in a slightly different way the conclusion that
trace-preserving quantum operations correspond to mappings within the Bloch-space.
</p>

<p>
It would be interesting to <i>characterize</i> what maps are possible. I believe they are
characterized by \(\det(M)\geq0\) (where \(M:\RR^4\to\RR^4\) for the non-trace-preserving
maps). At least for single-element operations we can use sage to verify that the
determinant is always non-negative:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgd408979"><span class="org-variable-name">E</span> <span class="org-operator">=</span> s<span class="org-operator">*</span>Id <span class="org-operator">+</span> u<span class="org-operator">*</span>X <span class="org-operator">+</span> v<span class="org-operator">*</span>Y <span class="org-operator">+</span> w<span class="org-operator">*</span>Z
<span class="org-variable-name">M</span> <span class="org-operator">=</span> make_qop1d_matrix_4d([E])
factor(det(M))
</pre>
</div>

<pre class="example">
(s^2 - u^2 - v^2 - w^2)^2*(conjugate(s)^2 - conjugate(u)^2 - conjugate(v)^2 - conjugate(w)^2)^2
</pre>


<p>
So for \(\calE(\rho)=E\rho\?E^\dagger\) with an arbitrary \(E=s+uX+vY+wZ\) we have
</p>

<p>
\[
  \det(M) = \abs{s^2-u^2-v^2-w^2}^4 .
\]
</p>

<p>
In principle the most general operation can be constructed from four single operation
elements (see <a href="#exercise-8.10">exercise 8.10</a>). However the symbolic determinant as computed by <code>sage</code> is
too complicated to see a pattern (or to use <code>factor</code>).
</p>
</div>
</div>

<div id="outline-container-org132eb46" class="outline-5">
<h5 id="org132eb46">Example</h5>
<div class="outline-text-5" id="text-org132eb46">
<p>
We have seen in the first part of the solution that non-trace-preserving operation can at
least be interpreted in \(\RR^4\). I also conjectured that this representation has
non-negative determinant. For trace preserving operations this would imply that the
determinant with respect to \(\RR^3\) is also positive.
</p>

<p>
The following is an example for a non-trace-preserving operation with negative determinant
with respect to \(\RR^3\):
</p>

<p>
\[
  E_0 = I, \quad E_1 = X + \ii Y .
\]
</p>

<p>
Indeed, for \(\rho=(e,x,y,z)\) with respect to the Pauli basis \((I,X,Y,Z)\) (recall \(e=1\) for
density matrices) we have
</p>

<p>
\[
  \calE(\rho) = (3e-2z,x,y,2e-z) .
\]
</p>

<p>
The following sage code "proves" it:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">E0</span> <span class="org-operator">=</span> Id
<span class="org-variable-name">E1</span> <span class="org-operator">=</span> X <span class="org-operator">+</span> i<span class="org-operator">*</span>Y
<span class="org-variable-name">rho</span> <span class="org-operator">=</span> e<span class="org-operator">*</span>Id <span class="org-operator">+</span> x<span class="org-operator">*</span>X <span class="org-operator">+</span> y<span class="org-operator">*</span>Y <span class="org-operator">+</span> z<span class="org-operator">*</span>Z

qop1d([E0, E1], rho)
</pre>
</div>

<pre class="example">
(3*e - 2*z, x, y, 2*e - z)
</pre>


<p>
If we project this into the three dimensional Bloch-space the corresponding matrix is
\(\diag(1,1,-1)\), which has a negative determinant. Hence it cannot be represented as a
deformation of the Bloch sphere, followed by a rotation and a displacement. Otherwise the
determinant would be non-negative (as is the case in \(\RR^4\)).
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2b46975" class="outline-3">
<h3 id="org2b46975">Exercise 8.17</h3>
<div class="outline-text-3" id="text-org2b46975">
<p>
Verify (8.101) as follows. Define
</p>

<p>
\[
  \calE(A) = \frac{A + XAX + YAY + ZAZ}{4} ,
\]
</p>

<p>
and show that
</p>

<p>
\[
  \calE(I) = I; \quad \calE(X) = \calE(Y) = \calE(Z) = 0 .
\]
</p>

<p>
Now use the Bloch sphere representation for single qubit density matrices to verify
(8.101).
</p>
</div>

<div id="outline-container-orga61ab05" class="outline-4">
<h4 id="orga61ab05">Solution</h4>
<div class="outline-text-4" id="text-orga61ab05">
<p>
This is almost to simple to justify but let me try my best. The claim \(\calE(I)=I\) follows
from \(X^2=Y^2=Z^2=I\). That \(\calE(N)=0\) for any Pauli matrix \(N\) follows from the fact
that \(NMN=-M\) if \(M\) and \(N\) are different Pauli matrices and \(NMN=N\) otherwise.
</p>

<p>
Finally, that \(\calE(\rho)=I/2\) for any density matrix follows from linearity of \(\calE\)
and the fact that any density matrix can be written as
</p>

<p>
\[
  \rho = \frac{1}{2} (I + x X + y Y + z Z)
\]
</p>

<p>
for \(x,y,z\in\RR\) (see <a href="chapter_2.html#exercise-2.72">exercise 2.72</a>).
</p>
</div>
</div>
</div>

<div id="outline-container-orgda649b1" class="outline-3">
<h3 id="orgda649b1">Exercise 8.18</h3>
<div class="outline-text-3" id="text-orgda649b1">
<p>
For \(k\geq1\) show that \(\trace{\rho^k}\) is never increased by the action of the
depolarizing channel.
</p>
</div>

<div id="outline-container-orgd950299" class="outline-4">
<h4 id="orgd950299">Proof</h4>
<div class="outline-text-4" id="text-orgd950299">
<p>
Recall that in a suitable orthonormal basis every density matrix is represented by a
diagonal matrix
</p>

<p>
\[
  \diag(q_1,\ldots,q_d)
\]
</p>

<p>
with \(\sum_jq_j=1\) and \(q_j\geq0\). Hence
</p>

<p>
\[
  \trace{\rho^k} = f_k(q)
\]
</p>

<p>
where
</p>

<p>
\[
  f_k(q) = \sum_{j=1}^d q_j^k .
\]
</p>

<p>
Observe that \(f_k\) is a strictly convex function, that is
</p>

<p>
\[
  f_k(\lambda q + (1-\lambda) q') < \lambda f_k(q) + (1-\lambda) f_k(q')
\]
</p>

<p>
for all \(\lambda\in(0,1)\) and \(q\neq\?q'\) (and \(\sum_jq_j=1\) and \(q_j\geq0\), and similarly
for \(q'\)). This follows from the convexity of the scalar valued function \(x\mapsto\?x^k\),
which in turn follows from the positivity of the second derivatives (on the domain of
definition). By the method of <a href="https://en.wikipedia.org/wiki/Lagrange_multiplier">Lagrange multipliers</a> we easily see that
</p>

<p>
\[
  q^\min = (1/d,\ldots,1/d)
\]
</p>

<p>
is the unique minimum of \(f_k\). Now we are prepared to prove the claim. In fact:
</p>

<p>
\[
  \trace{\calE(\rho)} = f_k(pq^\min + (1-p)q) \leq p f_k(q^\min) + (1-p) f_k(q)
  \leq f_k(q) = \trace{\rho} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orge50c21c" class="outline-3">
<h3 id="orge50c21c">Exercise 8.19</h3>
<div class="outline-text-3" id="text-orge50c21c">
<p>
Find an operator-sum representation for a generalized depolarizing channel acting on a
\(d\)â€‹-dimensional Hilbert space.
</p>
</div>

<div id="outline-container-org4cfd3d4" class="outline-4">
<h4 id="org4cfd3d4">Solution</h4>
<div class="outline-text-4" id="text-org4cfd3d4">
<p>
We will define \(d^2\) operation elements
</p>

<p>
\[
  E_{mn} = \frac{1}{d} P_m Q_n \text{ for } m,n \in \{0,1,\ldots,d-1\}
\]
</p>

<p>
which implement the operation \(\calE(\rho)=I/d\). Hence by scaling with \(\sqrt{p}\) and
adding an additional element \(\sqrt{1-p}I\) we can implement the depolarizing channel. In
the following let \(\rho=\sum_{ij}\rho_{ij}\ket{i}\bra{j}\). For \(n\in\{0,\ldots,d-1\}\)
define
</p>

<p>
\[
  Q_n \ket{j} = e^{2\pi\ii nj/d} \ket{j} .
\]
</p>

<p>
Observe that
</p>

<p>
\[
  \sum_n Q_n \ket{j}\bra{k} Q_n^\dagger = d \delta_{jk} .
\]
</p>

<p>
Hence
</p>

<p>
\[
  \rho' = \frac{1}{d} \, \sum_n Q_n \rho Q_n^\dagger = \sum_j \rho_{jj} \proj{j} .
\]
</p>

<p>
Next, for \(n\in\{0,\ldots,d-1\}\) define
</p>

<p>
\[
  P_n\ket{j} = \sum_j \ket{n+j} ,
\]
</p>

<p>
where the sum \(n+j\) is interpreted modulo \(d\). Hence the \(P_n\) are cyclic permutations.
</p>

<p>
\[
  \frac{1}{d} \sum_n P_n \rho' P_n^\dagger
  = \frac{1}{d} \sum_{jn} \rho_{jj} \ket{n+j}\braket{j}{j}\bra{n+j}
  = \frac{1}{d} I .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-8.20" class="outline-3">
<h3 id="exercise-8.20">Exercise 8.20 (Circuit model for amplitude damping)</h3>
<div class="outline-text-3" id="text-exercise-8.20">
<p>
Show that the circuit in Figure 8.13 models the amplitude damping quantum operation, with
\(\sin(\theta/2)^2=\gamma\).
</p>

<pre class="example">
                 â”Œâ”€â”€â”€â”
rho_in: â”€â”€â”€â”€â– â”€â”€â”€â”€â”¤ X â”œ
        â”Œâ”€â”€â”€â”´â”€â”€â”€â”â””â”€â”¬â”€â”˜
   |0&gt;: â”¤ Ry(Î¸) â”œâ”€â”€â– â”€â”€
        â””â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>


<div id="outline-container-org7c03079" class="outline-4">
<h4 id="org7c03079">Solution</h4>
<div class="outline-text-4" id="text-org7c03079">
<p>
Let \(B'\) be the action of the circuit:
</p>

\begin{align*}
  B' &= (I \otimes P_0 + X \otimes P_1) \cdot (P_0 \otimes I + P_1 \otimes R_y(\theta)) \\
  &= P_0 \otimes P_0 + P_1 \otimes P_0 R_y(\theta) + XP_0 \otimes P_1 + XP_1 \otimes P_1 R_y(\theta) .
\end{align*}

<p>
Let \(\ket{\psi}=a\ket{0}+b\ket{1}\). Then
</p>

<p>
\[
  B' \ket{\psi}\ket{0} = a \ket{00} + bc\ket{10} + 0 + bs\ket{01}
  = a\ket{00} + b(c\ket{10} + s\ket{01}) ,
\]
</p>

<p>
where \(c=\cos(\theta/2)\) and \(s=\sin(\theta/2)\). Thus
</p>

\begin{align*}
  E_0 \ket{\psi} = \bra{0_E} B' \ket{\psi}\ket{0_E} &= a\ket{0} + bc\ket{1} \\
  E_1 \ket{\psi} = \bra{1_E} B' \ket{\psi}\ket{0_E} &= bs\ket{0} \\
\end{align*}

<p>
In other words, using \(s=\sqrt{\gamma}\) and \(c=\sqrt{1-\gamma}\), we have
</p>

\begin{align*}
  E_0 &= \begin{bmatrix} 1 & 0 \\ 0 & \sqrt{1-\gamma} \end{bmatrix} , \\
  E_1 &= \begin{bmatrix} 0 & \sqrt{\gamma} \\ 0 & 0 \end{bmatrix} .
\end{align*}

<p>
This is as desired.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfa8963e" class="outline-3">
<h3 id="orgfa8963e">Exercise 8.21 (Amplitude damping of a harmonic oscillator)</h3>
<div class="outline-text-3" id="text-orgfa8963e">
<p>
Suppose that our principal system, a harmonic oscillator, interacts with an environment,
modeled as another harmonic oscillator, through the Hamiltonian
</p>

<p>
\[
  H = \chi (a^\dagger b + a b^\dagger)
\]
</p>

<p>
where \(a\) and \(b\) are the annihilation operators for the respective harmonic oscillators,
as deï¬ned in Section 7.3.
</p>

<ol class="org-ol">
<li><p>
Using \(U=\exp(-\ii\?H\tau)\), denoting the eigenstates of \(b^\dagger\?b\) as \(\ket{k_b}\),
and selecting the vacuum state \(\ket{0_b}\) as the initial state of the environment, show
that the operation elements \(E_k=\bra{k_b}U\ket{0_b}\) are found to be
</p>

<p>
\[
   E_k = \sum_{n=k}^\infty \sqrt{\binom{n}{k}} \sqrt{(1-\gamma)^{n-k}\gamma^k} \ket{n-k}\ket{n} ,
   \]
</p>

<p>
where \(\gamma=1-\cos(\chi\tau)^2\) is the probability of loosing a single quantum of
energy, and states such as \(\ket{n}\) are eigenstates of \(a^\dagger\?a\).
</p></li>
<li>Show that the operation elements \(E_k\) define a trace-preserving quantum operation.</li>

<li value="Remark">I am not really sure why it is <i>this</i> formula for \(H\). From the text I would
have expected \(H=\chi(a^\dagger\?b-ab^\dagger)\). But it doesn't matter for this exercise, both work.</li>
</ol>
</div>

<div id="outline-container-org54454c2" class="outline-4">
<h4 id="org54454c2">Proof of part 1</h4>
<div class="outline-text-4" id="text-org54454c2">
<p>
Recall a <a href="https://en.wikipedia.org/wiki/Baker%E2%80%93Campbell%E2%80%93Hausdorff_formula#An_important_lemma_and_its_application_to_a_special_case_of_the_Baker%E2%80%93Campbell%E2%80%93Hausdorff_formula">lemma</a> related to the Baker-Campbell-Hausdorff formula and Lie-Algebras:
</p>

<p>
\[
  e^{\lambda G} A e^{-\lambda G} = \sum_n \frac{\lambda^n}{n!} [(G)^n, A] ,
\]
</p>

<p>
where \([(G)^n,A]\) is the \(n\)â€‹-fold commutator. We will apply it to
\(G=a^\dagger\?b+ab^\dagger\) and \(A=a\). We have
</p>

<p>
\[
  [G, a] = -b \text{ and } [G, b] = -a .
\]
</p>

<p>
In particular \([(G)^2,A]=A\) for \(A\in\{a,b\}\). Hence (with \(\lambda=-\ii\chi\tau\),
and abbreviating \(\theta=\chi\tau\))
</p>

<p>
\[
  U a U^\dagger = \sum_n \frac{\theta^n}{n!} c_n
\]
</p>

<p>
where
</p>

<p>
\[
  c_n = \begin{cases} i^n a & \text{if } n \text{ is even.} \\ i^n b & \text{else.} \end{cases} .
\]
</p>

<p>
Thus, using the Taylor expansion of \(\sin\) and \(\cos\), we get
</p>

<p>
\[
  U a U^\dagger = \cos(\theta) a  + \sin(\theta) b .
\]
</p>

<p>
In the following let us abbreviate \(c=\cos(\theta)\) and \(s=\sin(\theta)\). Observe
\(s^2=\gamma\) and \(c^2=1-\gamma\). Using the formula for \(UaU^\dagger\) we obtain
</p>

<p>
\[
  U \ket{n_a, 0_b} = \frac{1}{\sqrt{n!}} \, U (a^\dagger)^n \ket{0_a, 0_b}
  = \frac{1}{\sqrt{n!}} \, (ca^\dagger+sb^\dagger)^n U \ket{0_a, 0_b}
  = \frac{1}{\sqrt{n!}} \, (ca^\dagger+sb^\dagger)^n \ket{0_a, 0_b} .
\]
</p>

<p>
Since \(a\) and \(b\) commute we can use the binomial formula to obtain
</p>

<p>
\[
  U \ket{n_a, 0_b} = \frac{1}{\sqrt{n!}} \sum_n \binom{n}{k} (ca^\dagger)^{n-k} (sb^\dagger)^k \ket{0_a,0_b}
  = \sum_{n\geq k} \sqrt{\binom{n}{k}} c^{n-k} s^k \ket{(n-k)_a,k_b} ,
\]
</p>

<p>
which is the claim of part 1. QED.
</p>
</div>
</div>

<div id="outline-container-org4727fe3" class="outline-4">
<h4 id="org4727fe3">Proof of part 2</h4>
<div class="outline-text-4" id="text-org4727fe3">
<p>
This can be proved in very abstract terms. We just have to use that
\(E_k=\bra{k_b}U\ket{0_b}\) where \(U\) is unitary (on the combined system) and
\(\{\ket{k_b}\}\) is an ONB on the environment. In fact (denoting by \(Q\) the principal
system)
</p>

<p>
\[
  \sum_k E_k^\dagger E_k = \sum_k \bra{0_b} U^\dagger \proj{k_b} U \ket{0_b}
  = \bra{0_b} U^\dagger U \ket{0_b} = I_Q .
\]
</p>

<p>
This identity characterizes trace-preserving operations. QED.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
It wouldn't be hard to directly verify the claim using the closed formula for
\(E_k\) from this concrete example. Writing
\(a_{nk}=\sqrt{\binom{n}{k}(1-\gamma)^{n-k}\gamma^k}\) the claim essentially follows from the binomial formula
</p>

<p>
\[
  \sum_{k=0}^n a_{nk}^2 = ((1-\gamma) + \gamma)^n = 1 .
  \]
</p></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-exercise-8.22" class="outline-3">
<h3 id="exercise-8.22">Exercise 8.22 (Amplitude damping of single qubit density matrix)</h3>
<div class="outline-text-3" id="text-exercise-8.22">
<p>
For the general single qubit state
</p>

<p>
\[
  \rho = \begin{bmatrix} a & b \\ b^* & c \end{bmatrix} .
\]
</p>

<p>
show that amplitude damping leads to
</p>

<p>
\[
  \calE_{AD}(\rho) = \begin{bmatrix}
    1 - (1-\gamma)(1-a) & b\sqrt{1-\gamma} \\
    b^*\sqrt{1-\gamma}  & c(1-\gamma) \end{bmatrix} .
\]
</p>
</div>

<div id="outline-container-orgd1fdeed" class="outline-4">
<h4 id="orgd1fdeed">Solution</h4>
<div class="outline-text-4" id="text-orgd1fdeed">
<p>
The claim essentially follows from this small sage script
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">E0</span> <span class="org-operator">=</span> matrix.diagonal([1, sqrt(1<span class="org-operator">-</span>g)])
<span class="org-variable-name">E1</span> <span class="org-operator">=</span> matrix([[0, sqrt(g)], [0, 0]])

<span class="org-variable-name">a</span>, <span class="org-variable-name">c</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'a c'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
<span class="org-variable-name">b</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'b'</span>, domain<span class="org-operator">=</span><span class="org-string">'complex'</span>)

<span class="org-variable-name">rho</span> <span class="org-operator">=</span> matrix([
    [a, b],
    [b.conjugate(), c],
])

<span class="org-variable-name">A</span> <span class="org-operator">=</span> simplify(E0<span class="org-operator">*</span>rho<span class="org-operator">*</span>E0.H <span class="org-operator">+</span> E1<span class="org-operator">*</span>rho<span class="org-operator">*</span>E1.H)

<span class="org-keyword">assert</span> A <span class="org-operator">==</span> matrix([
    [               c<span class="org-operator">*</span>g <span class="org-operator">+</span> a, b<span class="org-operator">*</span>sqrt(1<span class="org-operator">-</span>g)],
    [sqrt(1<span class="org-operator">-</span>g)<span class="org-operator">*</span>conjugate(b), c<span class="org-operator">*</span>(1<span class="org-operator">-</span>g)]
])
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
The upper left corner looks different to what was stated in the exercise. But using
\(a+c=1\) equality is easily verified.
</p>
</div>
</div>
</div>

<div id="outline-container-org1594616" class="outline-3">
<h3 id="org1594616">Exercise 8.23 (Amplitude damping of dual-rail qubits)</h3>
<div class="outline-text-3" id="text-org1594616">
<p>
Suppose that a single qubit state is represented by using two qubits, as
</p>

<p>
\[
  \ket{\psi} = a \ket{01} + b \ket{10} .
\]
</p>

<p>
Show that \(\calE_{AD}\otimes\calE_{AD}\) applied to this state gives a process which can be
described by the operation elements
</p>

\begin{align*}
  E_0^{\mathrm{dr}} &= \sqrt{1-\gamma} I, \\
  E_1^{\mathrm{dr}} &= \sqrt{\gamma} \ket{00}\bra{01}, \\
  E_2^{\mathrm{dr}} &= \sqrt{\gamma} \ket{00}\bra{10},
\end{align*}

<p>
that is, either nothing (\(E_0^{\mathrm{dr}}\)) happens to the qubit, or the qubit is
transformed (\(E_1^{\mathrm{dr}}\), \(E_2^{\mathrm{dr}}\)) into the state \(\ket{00}\), which is
orthogonal to \(\ket{\psi}\). This is a simple error-detection code, and is also the basis
for the robustness of the â€˜dual-railâ€™ qubit discussed in Section 7.4.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
The original exercise statement contained a small error. It claimed that only
two operation elements are needed: \(E_0^{\mathrm{dr}}\) and
\(E_1^{\mathrm{dr}}+E_2^{\mathrm{dr}}\). This is incorrect.
</p>

<p>
Moreover the formula for \(E_0^{\mathrm{dr}}\) needs a proper interpretation. But we will
make it precise in the solution below.
</p></dd>
</dl>
</div>

<div id="outline-container-orga0eec43" class="outline-4">
<h4 id="orga0eec43">Proof</h4>
<div class="outline-text-4" id="text-orga0eec43">
<p>
Let us abbreviate \(c=\sqrt{1-\gamma}\) and \(s=\sqrt{\gamma}\). Recall the operation elements
of \(\calE_{AD}\):
</p>

<p>
\[
  E_0 = \begin{bmatrix} 1 & 0 \\ 0 & c \end{bmatrix}, \quad
  E_1 = \begin{bmatrix} 0 & s \\ 0 & 0 \end{bmatrix}.
\]
</p>

<p>
A set of operation elements for \(\calE_{AD}\otimes\calE_{AD}\) is given by the four
elements \(\{E_{ij}:=E_i\otimes\?E_j\}\) which we will write down in the following:
</p>

<p>
\[
  E_{00} = \begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & c & 0 & 0 \\
    0 & 0 & c & 0 \\
    0 & 0 & 0 & c^2 \end{bmatrix}
\]
and
</p>

<p>
\[
  E_{01} = \begin{bmatrix}
    0 & s & 0 & 0 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & sc \\
    0 & 0 & 0 & 0 \end{bmatrix}
\]
</p>

<p>
and
</p>

<p>
\[
  E_{10} = \begin{bmatrix}
    0 & 0 & s & 0 \\
    0 & 0 & 0 & sc \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 \end{bmatrix}
\]
</p>

<p>
and
</p>

<p>
\[
  E_{11} = \begin{bmatrix}
    0 & 0 & 0 & s^2 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 \end{bmatrix} .
\]
</p>

<p>
Here the rows and columns correspond to the basis
</p>

<p>
\[ (\ket{00},\ket{01},\ket{10},\ket{11}) \]
</p>

<p>
in that order. Observe that all four operation elements leave the subspace spanned by the
first three basis elements invariant. This is important since \(\ket{\psi}\) lives in that
subspace. <b>With respect to this subspace</b> we have
</p>

\begin{align*}
  E_{00} &= \proj{00} + c(\proj{01} + \proj{10}) , \\
  E_{01} &= s \ket{00}\bra{01} , \\
  E_{10} &= s \ket{00}\bra{10} , \\
  E_{11} &= 0 .
\end{align*}

<p>
In particular we only need three elements and we have \(E_1^{\mathrm{dr}}=E_{01}\) and
\(E_2^{\mathrm{dr}}=E_{10}\). Moreover \(E_{00}\) corresponds to \(cI\) if we understand \(I\) to
be the identity on the subspace spanned by \(\ket{01}\) and \(\ket{10}\), which makes sense
since \(\ket{\psi}\) even lives in that space. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc3391c8" class="outline-3">
<h3 id="orgc3391c8">Exercise 8.24 (Spontaneous emission is amplitude damping)</h3>
<div class="outline-text-3" id="text-orgc3391c8">
<p>
A single atom coupled to a single mode of electromagnetic radiation undergoes spontaneous
emission, as was described in Section 7.6.1. To see that this process is just amplitude
damping, take the unitary operation resulting from the Jaynesâ€“Cummings interaction,
Equation (7.77), with detuning \(\delta=0\), and give the quantum operation resulting from
tracing over the field.
</p>
</div>

<div id="outline-container-org2495641" class="outline-4">
<h4 id="org2495641">Solution</h4>
<div class="outline-text-4" id="text-org2495641">
<p>
The Jaynes-Cummings interaction is <i>essentially</i> given by
</p>

<p>
\[
  H = \delta Z + g(a^\dagger \sigma_- + a \sigma_+) ,
\]
</p>

<p>
where \(Z\), \(\sigma_\pm=X\mp\ii\?Y\) act on the two-level atom and \(a\), \(a^\dagger\) on the
field (see e.g. equation (7.71)). In the basis \((\ket{00},\ket{01},\ket{10})\) (the right
qubit is the atom) the Hamiltonian looks as follows:
</p>

<p>
\[
  H = \begin{bmatrix}
    \delta & 0 & 0 \\
    0 & -\delta & g \\
    0 & g & \delta \end{bmatrix} .
\]
</p>

<p>
Let \(U=\exp(-\ii\?H\tau/2)\) and define \(c=\cos(g\tau)\), \(s=\sin(g\tau)\). For \(\delta=0\) we
have
</p>

<p>
\[
  U = \begin{bmatrix}
    1 & 0 & 0 \\
    0 & c & -\ii s \\
    0 & -\ii s & c \end{bmatrix} .
\]
</p>

<p>
Let \(\rho_E=\proj{0}\) be the state of the field - the environment - with zero
photons. Then the following clearly describes spontaneous emission:
</p>

<p>
\[
  \calE(\rho) = \ptrace{E}{U \rho_E\otimes\rho U^\dagger} .
\]
</p>

<p>
We have to show that this is actually amplitude damping.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">theta</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'theta'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
<span class="org-variable-name">b</span>, <span class="org-variable-name">b1</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'b b1'</span>, domain<span class="org-operator">=</span><span class="org-string">'complex'</span>)

<span class="org-variable-name">c</span> <span class="org-operator">=</span> cos(theta)
<span class="org-variable-name">s</span> <span class="org-operator">=</span> sin(theta)

<span class="org-comment-delimiter"># </span><span class="org-comment">NOTE: we add a trivial action on |11&gt;. The point of this is solely to be able to</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">calculate the partial trace below. The function we use only accepts matrices with</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">dimensions being a power of 2 (more precisely: Hilbert spaces described by qubits). If a</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">state would actually be equal to |11&gt; the Jaynes-Cummings interaction would not leave it</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">invariant. But we can use this as a mathematical trick since the three-dimensional</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">subspace we consider contains everything we need and is left invariant by the</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">interaction.</span>
<span class="org-variable-name">U</span> <span class="org-operator">=</span> matrix([
    [1,    0,    0, 0],
    [0,    c, <span class="org-operator">-</span>i<span class="org-operator">*</span>s, 0],
    [0, <span class="org-operator">-</span>i<span class="org-operator">*</span>s,    c, 0],
    [0,    0,    0, 1],
])

<span class="org-comment-delimiter"># </span><span class="org-comment">An arbitrary mixed state (as input for the operation).</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">b1 is actually conjugate(b) but this looks ugly and we do not need it.</span>
<span class="org-variable-name">rho</span> <span class="org-operator">=</span> matrix([
    [p, b],
    [b1, 1<span class="org-operator">-</span>p],
])

<span class="org-variable-name">M</span> <span class="org-operator">=</span> U <span class="org-operator">*</span> kron(P0, rho) <span class="org-operator">*</span> U.H

<span class="org-comment-delimiter"># </span><span class="org-comment">TODO: reimplement for sage</span>
<span class="org-keyword">from</span> chapter_2 <span class="org-keyword">import</span> ptrace
<span class="org-keyword">from</span> sympy <span class="org-keyword">import</span> Matrix

<span class="org-variable-name">M</span> <span class="org-operator">=</span> Matrix(M)
<span class="org-variable-name">T</span> <span class="org-operator">=</span> ptrace(M, [1]) <span class="org-comment-delimiter"># </span><span class="org-comment">bits are counted from the right.</span>
T
</pre>
</div>

<pre class="example">
Matrix([
[p - (p - 1)*sin(theta)**2,           b*cos(theta)],
[            b1*cos(theta), -(p - 1)*cos(theta)**2]])
</pre>


<p>
Comparing this with the statement of <a href="#exercise-8.22">exercise 8.22</a> we see that this is indeed amplitude
damping with \(\gamma=s^2=\sin(g\tau)^2\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgef1b665" class="outline-3">
<h3 id="orgef1b665">Exercise 8.25</h3>
<div class="outline-text-3" id="text-orgef1b665">
<p>
If we deï¬ne the temperature \(T\) of a qubit by assuming that in equilibrium the
probabilities of being in the \(\ket{0}\) and \(\ket{1}\) states satisfy a Boltzmann
distribution, that is \(p_0=e^{-E_0/k_BT}/\mathcal{Z}\) and \(p_1=e^{-E_1/k_BT}/\mathcal{Z}\),
where \(E_0\) is the energy of the state \(\ket{0}\), \(E_1\) the energy of the state \(\ket{1}\),
and \(\mathcal{Z}=e^{-E_0/k_BT}+e^{-E_1/k_BT}\), what temperature describes the state
\(\rho_\infty\)?
</p>
</div>

<div id="outline-container-org7b80989" class="outline-4">
<h4 id="org7b80989">Solution</h4>
<div class="outline-text-4" id="text-org7b80989">
<p>
By convention we typically assume \(E_0\?<\?E_1\) (and we assume those values to be given
constants). Note that this is equivalent to \(p_0\?>\?1/2\). The limit case \(E_0=E_1\)
corresponds to \(p_0=1/2\). It is easy to see that
</p>

<p>
\[
  p_0 = \frac{1}{1 + \exp(-(E_1-E_0)/k_BT)}
\]
</p>

<p>
This can be used to get a formula for \(T\) in terms of \(p=p_0\):
</p>

<p>
\[
  T = \frac{E_1 - E_0}{k_B \log(p/(1-p))} .
\]
</p>

<p>
This is the temperature of a state \(\rho=p\proj{0}+(1-p)\proj{1}\). We have the following
edge cases:
</p>

<p>
\[
  T(p=1) = \lim_{p\to1} T(p) = 0, \quad T(p=1/2) = \lim_{p\to1/2} T(p) = \infty .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-orgf6f50d9" class="outline-3">
<h3 id="orgf6f50d9">Exercise 8.26 (Circuit model for phase damping)</h3>
<div class="outline-text-3" id="text-orgf6f50d9">
<p>
Show that the circuit in Figure 8.15 can be used to model the phase damping quantum
operation, provided \(\theta\) is chosen appropriately.
</p>

<pre class="example">

rho_in: â”€â”€â”€â”€â– â”€â”€â”€â”€
        â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   |0&gt;: â”¤ Ry(Î¸) â”œ
        â””â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>


<div id="outline-container-org8879dc1" class="outline-4">
<h4 id="org8879dc1">Proof</h4>
<div class="outline-text-4" id="text-org8879dc1">
<p>
This is similar to <a href="#exercise-8.20">exercise 8.20</a> - just simpler. Let \(B\) be the operation of the circuit:
</p>

<p>
\[
  B = P_0 \otimes I + P_1 \otimes R_y(\theta) .
\]
</p>

<p>
Let \(\ket{\psi}=a\ket{0}+b\ket{1}\). Then
</p>

<p>
\[
  B\ket{\psi}\ket{0_E} = a \ket{00} b\ket{1} R_y(\theta)\ket{0}
  = a\ket{00} + b(c\ket{10} + s\ket{11}) ,
\]
</p>

<p>
where \(c=\cos(\theta)\) and \(s=\sin(\theta)\). From here we get
</p>

\begin{align*}
  E_0\ket{\psi} &= \bra{0_E} B \ket{\psi}\ket{0_E} = a \ket{0} + bc\ket{1} , \\
  E_1\ket{\psi} &= \bra{1_E} B \ket{\psi}\ket{0_E} = bs \ket{1} .
\end{align*}

<p>
In other words:
</p>

<p>
\[
  E_0 = \begin{bmatrix} 1 & 0 \\ 0 & c \end{bmatrix}, \quad
  E_1 = \begin{bmatrix} 0 & 0 \\ 0 & s \end{bmatrix},
\]
</p>

<p>
which is phase damping (at least for e.g. \(\theta\in[0,\pi/2]\)) - as desired. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-8.27" class="outline-3">
<h3 id="exercise-8.27">Exercise 8.27 (Phase damping = phase flip channel)</h3>
<div class="outline-text-3" id="text-exercise-8.27">
<p>
Give the unitary transformation which relates the operation elements of (8.127)â€“(8.128) to
those of (8.129)â€“(8.130); that is, find \(u\) such that \(\tilde{E}_k=\sum_ju_{kj}E_j\).
</p>

<p>
For reference:
</p>

<p>
\[
  E_0 = \begin{bmatrix} 1 & 0 \\ 0 & \sqrt{1-\lambda} \end{bmatrix} , \;
  E_1 = \begin{bmatrix} 0 & 0 \\ 0 & \sqrt{\lambda} \end{bmatrix} .
\]
</p>

<p>
and \(\tilde{E}_0=\sqrt{\alpha}I\), \(\tilde{E}_1=\sqrt{1-\alpha}Z\).
</p>
</div>

<div id="outline-container-orgad310c4" class="outline-4">
<h4 id="orgad310c4">Solution 1</h4>
<div class="outline-text-4" id="text-orgad310c4">
<p>
In the following I prove
</p>

<p>
<a id="orgd64e204"></a>
</p>
\begin{align*}
  \tilde{E}_0 &= \sqrt{\alpha} E_0 + \sqrt{1-\alpha} E_1 , \\
  \tilde{E}_1 &= \sqrt{1-\alpha} E_0 - \sqrt{\alpha} E_1 ,
\end{align*}

<p>
and briefly show how to come up with precisely this ansatz. Recall that the action of
phase damping is given by
</p>

<p>
\[
  \?\begin{bmatrix} p & b \\ b^* & q \end{bmatrix}
  \mapsto \begin{bmatrix} p & \sqrt{1-\lambda}\,b \\ \sqrt{1-\lambda}\,b^* & q \end{bmatrix} .
\]
</p>

<p>
Phase flip is given by
</p>

<p>
\[
  \?\begin{bmatrix} p & b \\ b^* & q \end{bmatrix}
  \mapsto \begin{bmatrix} p & (2\alpha-1)b \\ (2\alpha-1)b^* & q \end{bmatrix} .
\]
</p>

<p>
Hence there is a bijection \([0,1]\to[1/2,1]\) given by
</p>

<p>
<a id="orgaff1f18"></a>
\[ \alpha=(1+\sqrt{1-\lambda})/2 \]
</p>

<p>
which maps between phase damping and "half of" all phase flips. This already shows that
phase damping is just phase flip and we already have a formula for \(\alpha\). Hence there
must be a unitary matrix \(u\) such that
</p>

\begin{align*}
  \tilde{E}_0 &= u_{00} E_0 + u_{01} E_1 , \\
  \tilde{E}_1 &= u_{10} E_0 + u_{11} E_1 .
\end{align*}

<p>
By inspecting the matrices it is clear that we <i>must</i> have \(u_{00}=\sqrt{\alpha}\) and
\(u_{10}=\sqrt{1-\alpha}\). Since the matrix \(u\) is unitary we also must have
\(\abs{u_{01}}=\sqrt{1-\alpha}\) and \(\abs{u_{11}}=\sqrt{\alpha}\). Since everything else is
real we directly conclude that \(u_{10}\) and \(u_{11}\) have to be real too. By looking at
the \(11\) entries of the operation elements we directly see that \(u_{01}\) must be
positive. Hence by (e.g.) unitarity of \(u\) we deduce that \(u_{11}\) must be negative. Hence
the only possible \(u\) is the one implicitly given in the <a href="#orgd64e204">above equation</a>.
</p>

<p>
Since we already know that \(u\) must exist and we also showed that it is unique the
<a href="#orgd64e204">mentioned equation</a> follows.
</p>
</div>
</div>

<div id="outline-container-orgdc136b5" class="outline-4">
<h4 id="orgdc136b5">Solution 2</h4>
<div class="outline-text-4" id="text-orgdc136b5">
<p>
This is not really a second solution but more like a consistency check for the first
solution (we all make mistakes so it is best practice to double check things from time to
time).
</p>

<p>
The <a href="#orgd64e204">claim</a> we have to prove is equivalent to:
</p>

\begin{align*}
  \sqrt{\alpha} &= \sqrt{\alpha} \sqrt{1-\lambda} + \sqrt{1-\alpha} \sqrt{\lambda} , \\
  -\sqrt{1-\alpha} &= \sqrt{1-\alpha} \sqrt{1-\lambda} - \sqrt{\alpha} \sqrt{\lambda} .
\end{align*}

<p>
In principle there would be four equations (one for each diagonal entry and each
phase-flip element) but the other two are just trivial. Let us abbreviate
\(c=\sqrt{1-\lambda}\) and \(s=\sqrt{\lambda}\). Note that \(c,s\in[0,1]\) and \(c^2+s^2=1\). The
first equation is equivalent to
</p>

<p>
\[
  \sqrt{\alpha} = \sqrt{\alpha} c + \sqrt{1-\alpha} s .
\]
</p>

<p>
Before we go on, recall <a href="#orgaff1f18">this formula</a> \(2\alpha=1+c\). It suffices to show that twice the
square of the RHS is \(2\alpha=1+c\) (squaring only hides the sign but we already see that
both sides are positive). Let us check this:
</p>

\begin{align*}
  2(\sqrt{\alpha} \, c + \sqrt{1-\alpha} \, s)^2 &= (\sqrt{1+c} \, c + \sqrt{1-c} \, s)^2 \\
  &= (1+c)c^2 + (1-c)s^2 + 2\sqrt{1-c^2} \, sc \\
  &= 1 + c(c^2+s^2) \\
  &= 1 + c .
\end{align*}

<p>
This is as desired. The second equation
</p>

<p>
\[
  -\sqrt{1-\alpha} = \sqrt{1-\alpha} c - \sqrt{\alpha} s .
\]
</p>

<p>
can also be shown by showing that twice the square of the RHS is equal to
\(2(1-\alpha)=1-c\) (the sign makes no problem since the RHS is at most \(\sqrt{1-\alpha}\)
and this only if \(c=1\), \(s=0\) which implies \(\alpha=1\), a special case easily treated
separately). Let us also check this:
</p>

\begin{align*}
  2(\sqrt{1-\alpha} \, c - \sqrt{\alpha} \, s)^2 &= (\sqrt{1-c} \, c - \sqrt{1+c} \, s)^2 \\
  &= (1-c)c^2 + (1+c)s^2 - 2\sqrt{1-c^2} \, sc \\
  &= 1 - c(c^2+s^2) \\
  &= 1 - c .
\end{align*}
</div>
</div>
</div>

<div id="outline-container-orgf135d62" class="outline-3">
<h3 id="orgf135d62">Exercise 8.28 (One <code>CNOT</code> phase damping model circuit)</h3>
<div class="outline-text-3" id="text-orgf135d62">
<p>
Show that a single <code>CNOT</code> gate can be used as a model for phase damping, if we let the
initial state of the environment be a mixed state, where the amount of damping is
determined by the probability of the states in the mixture.
</p>
</div>

<div id="outline-container-org91eee04" class="outline-4">
<h4 id="org91eee04">Solution</h4>
<div class="outline-text-4" id="text-org91eee04">
<p>
As an intermediate step let us find a solution involving a <code>CZ</code> gate instead of a <code>CNOT</code>
gate. It is relatively intuitive how to do this if we recall that phase damping is just
phase flip (<a href="#exercise-8.27">exercise 8.27</a>)
</p>

<pre class="example">

               rho_in: â”€â– â”€
                        â”‚
p|0&gt;&lt;0| + (1-p)|1&gt;&lt;1|: â”€â– â”€

</pre>


<p>
Here <code>CZ</code> gate is to be interpreted as having its control at the environment (it is
symmetric of course but it helps to imagine it that way). The environment is in the mixed state
</p>

<p>
\[ \rho_E = p\proj{0} + (1-p)\proj{1} \]
</p>

<p>
which activates the <code>CZ</code> with probability \(1-p\) and does nothing otherwise. A similar
construction was done for the deploarizing channel in figure 8.12. To <i>rigorously</i> prove
that this actually implements the phase flip let \(U\) be the <code>CZ</code> gate and consider
</p>

\begin{align*}
  \ptrace{E}{U \rho\otimes\rho_E U^\dagger}
  &= p \, \ptrace{E}{U \rho\otimes P_0 U^\dagger} + (1-p) \, \ptrace{E}{U \rho\otimes P_1 U^\dagger} \\
  &= p \, \ptrace{E}{\rho\otimes P_0} + (1-p) \, \ptrace{E}{(Z\rho Z)\otimes P_1} \\
  &= p \, \rho + (1 - p) \, Z\rho Z .
\end{align*}

<p>
Hence the above circuit implements phase flip. By <a href="#exercise-8.27">exercise 8.27</a> we know that setting
\(p=(1+\sqrt{1-\lambda})/2\) (c.f. <a href="#orgaff1f18">solution</a> of that exercise) is phase damping with
parameter \(\lambda\).
</p>


<p>
Using the Hadamard gate and \(HXH=Z\) the circuit can be converted to a cicuit using a
<code>CNOT</code>:
</p>

<pre class="example">

               rho_in: â”€â”€â”€â”€â”€â”€â”€â– â”€â”€â”€â”€â”€â”€â”€
                       â”Œâ”€â”€â”€â”â”Œâ”€â”´â”€â”â”Œâ”€â”€â”€â”
p|0&gt;&lt;0| + (1-p)|1&gt;&lt;1|: â”¤ H â”œâ”¤ X â”œâ”¤ H â”œ
                       â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜
</pre>


<p>
Note that we actually do not need the second Hadamard gate since it only acts on the
environment <i>after</i> the interaction took place. That is, the following circuit implements
the same operation:
</p>

<pre class="example">

               rho_in: â”€â”€â”€â”€â”€â”€â”€â– â”€â”€
                       â”Œâ”€â”€â”€â”â”Œâ”€â”´â”€â”
p|0&gt;&lt;0| + (1-p)|1&gt;&lt;1|: â”¤ H â”œâ”¤ X â”œ
                       â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜
</pre>


<p>
The Hadamard gate maps between the eigenbasis \((\ket{0},\ket{1})\) of \(Z\) and the
eigenbasis \((\ket{0},\ket{1})\) of \(X\). Hence the following circuit still implements phase
damping:
</p>

<pre class="example">

               rho_in: â”€â”€â– â”€â”€
                       â”Œâ”€â”´â”€â”
p|+&gt;&lt;+| + (1-p)|-&gt;&lt;-|: â”¤ X â”œ
                       â””â”€â”€â”€â”˜
</pre>


<p>
That is, the environment is in the state \(p\proj{+}+(1-p)\proj{-}\) and the <code>CNOT</code> gate has
its target there.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdfce80f" class="outline-3">
<h3 id="orgdfce80f">Exercise 8.29 (Unitality)</h3>
<div class="outline-text-3" id="text-orgdfce80f">
<p>
A quantum process \(\calE\) is unital if \(\calE(I)=I\). Show that the depolarizing and phase
damping channels are unital, while amplitude damping is not.
</p>
</div>

<div id="outline-container-org1daaceb" class="outline-4">
<h4 id="org1daaceb">Solution</h4>
<div class="outline-text-4" id="text-org1daaceb">
<p>
This is a straightforward exercise. So let us mainly mention one thing. Some formulas like
this one for the depolarizing channel
</p>

<p>
\[
  \calE_{DC}(\rho) = p d\inv I  + (1-p)\rho
\]
</p>

<p>
only holds for <i>density</i> matrices. In that case we have to plug in \(d\inv\?I\) and not \(I\):
</p>

<p>
\[
  \calE_{DC}(d\inv I) = (p + (1-p)) d\inv I = d\inv I .
\]
</p>

<p>
For the phase damping let us show the claim on the (slightly) more general phase flip
operation (<a href="#exercise-8.27">exercise 8.27</a>). We use the a formula based on operation elements where the
above remark does not apply:
</p>

<p>
\[
  \calE_{PF}(I) = p I^3 + (1-p) ZIZ = p I + (1-p) I = I .
\]
</p>

<p>
Finally consider amplitude damping with \(E_0=\diag(1,c)\) and \(E_1=s\ket{0}\bra{1}\) where
\(c,s\geq0\) with \(c^2+s^2=1\) (moreover we assume that \(c\neq1\) to avoid the identity
operation which is indeed unital):
</p>

<p>
\[
  \calE_{AD}(I) = E_0E_0^\dagger + E_1E_1^\dagger = \diag(1,c^2) + \diag(s^2, 0) = \diag(1+s^2,c^2) \neq I
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org2fab00c" class="outline-3">
<h3 id="org2fab00c">Exercise 8.30 (\(T_2\leq2T_1\))</h3>
<div class="outline-text-3" id="text-org2fab00c">
<p>
The \(T_2\) phase coherence relaxation rate is just the exponential decay rate of the
off-diagonal elements in the qubit density matrix, while \(T_1\) is the decay rate of the
diagonal elements (see Equation (7.144)). Amplitude damping has both nonzero \(T_1\) and \(T_2\)
rates; show that for amplitude damping \(T_2=2T_1\). Also show that if amplitude and phase
damping are both applied then \(T_2\leq2T_1\).
</p>
</div>

<div id="outline-container-orga112131" class="outline-4">
<h4 id="orga112131">Proof</h4>
<div class="outline-text-4" id="text-orga112131">
<p>
Recall the general equation for the relaxation from (7.144):
</p>

<p>
\[
  \?\begin{bmatrix}
    (p-p_0) e^{-t/T_1} + p_0 & b e^{-t/T_2} \\
    b^* e^{-t/T_2} & (p_0-p) e^{-t/T_1} + (1-p_0)
  \?\end{bmatrix} .
\]
</p>

<p>
From <a href="#exercise-8.22">exercise 8.22</a> we know
</p>

<p>
\[
  \calE_{AD}(\rho) = \?\begin{bmatrix}
    1 + (1-\gamma)(p-1) & b \sqrt{1-\gamma} \\
    b^* \sqrt{1-\gamma} & (1-p) (1-\gamma)
  \?\end{bmatrix} .
\]
</p>

<p>
This clearly corresponds to \(p_0=1\), \(T_2=2T_1\) and an unspecified \(t>0\). If we apply
phase damping in addition we get
</p>

<p>
\[
  \calE_{PD}\circ\calE_{AD}(\rho) = \?\begin{bmatrix}
    1 + (1-\gamma)(p-1) & b \sqrt{(1-\lambda)(1-\gamma)} \\
    b^* \sqrt{(1-\lambda)(1-\gamma)} & (1-p) (1-\gamma)
  \?\end{bmatrix} .
\]
</p>

<p>
This clearly only makes the \(T_2\)â€‹-relaxation faster. In other words \(T_2\) gets
smaller. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org0e87c94" class="outline-3">
<h3 id="org0e87c94"><span class="todo TODO">TODO</span> Exercise 8.31 (Exponential sensitivity to phase damping)</h3>
<div class="outline-text-3" id="text-org0e87c94">
<p>
Using (8.126), show that the element \(\rho_{nm}=\bra{n}\rho\ket{m}\) in the density matrix of a harmonic
oscillator decays exponentially as \(e^{-\lambda(n-m)^2}\) under the effect of phase damping, for some
constant \(\lambda\).
</p>
</div>
</div>

<div id="outline-container-org3a90467" class="outline-3">
<h3 id="org3a90467">Exercise 8.32</h3>
<div class="outline-text-3" id="text-org3a90467">
<p>
Explain how to extend quantum process tomography to the case of non-trace-preserving
quantum operations, such as arise in the study of measurement.
</p>
</div>

<div id="outline-container-orgc5caae9" class="outline-4">
<h4 id="orgc5caae9">Solution</h4>
<div class="outline-text-4" id="text-orgc5caae9">
<p>
The procedure explained in the book does not rely on the fact that the operation is
trace-preserving. The only occasion it appeared was when it was mentioned that \(\chi\) has
\(d^4-d^2\) free parameters. In the non-trace-preserving case the \(-d^2\) goes away.
</p>
</div>
</div>
</div>

<div id="outline-container-org8d3478b" class="outline-3">
<h3 id="org8d3478b">Exercise 8.33 (Specifying a quantum process)</h3>
<div class="outline-text-3" id="text-org8d3478b">
<p>
Suppose that one wished to completely specify an arbitrary single qubit operation \(\calE\)
by describing how a set of points on the Bloch sphere \(\{\vec{r}_k\}\) transform under
\(\calE\). Prove that the set must contain at least four points.
</p>
</div>

<div id="outline-container-orgd6b5a7b" class="outline-4">
<h4 id="orgd6b5a7b">Proof</h4>
<div class="outline-text-4" id="text-orgd6b5a7b">
<p>
First of all recall that the bloch sphere description only applies to trace-preserving
operations (<a href="#exercise-8.16">exercise 8.16</a>). Therefore let us add the additional resctriction that the
operation has to be trace preserving.
</p>

<p>
The claim almost follows from the fact that trace-preserving operations act like affine
maps in the (three-dimensional) Bloch-space. But it is well known that an affine map on a
\(d\)â€‹-dimensional space needs exactly \(d+1\) affine-linearly independent points to be
specified. I say "almost" because not every affine map corresponds to a quantum operation
(at least I think so). But it still serves as good justification because we have already
seen that quantum operations give rise to several non-trivial affine maps.
</p>

<p>
We show that every map (on the Bloch-space) of the form
</p>

<p>
<a id="org38b9a36"></a>
\[
  \vec{x} \mapsto RD \vec{x} + \vec{c} ,
\]
</p>

<p>
for any rotation matrix \(R\) (orthogonal and determinant plus one), diagonal matrix \(D\)
with diagonal entries in \(0\?<\?d_i\?<\?1-\gamma\), and any vector \(\vec{c}\) with
\(\norm{\vec{c}}\leq\gamma\) corresponds to a quantum operation. Here \(0\leq\gamma\?<\?1\) is
an arbitrary parameter. There are more affine maps possible but this is sufficient for our
purpose.
</p>

<p>
Note that e.g. mirroring at the \(z=0\) plane (a negative determinant map) and the mentioned
affine maps together generate the group of all invertible affine maps (this is related to
the polar decomposition of matrices). Hence it is not hard to see that even if we restrict
the space of possible maps to maps of the <a href="#org38b9a36">above form</a> we need at least four points.
</p>

<p>
Now let us justify the above <a href="#org38b9a36">claim</a>. Any rotation \(\vec{x}\mapsto\?R\vec{x}\) is possible by
unitary evolution (keyword: Pauli rotations). The depolarizing channel implements
\(\vec{x}\mapsto\alpha\vec{x}\) for any \(\alpha\in(0,1)\). The phase flip can implement an
operation which shrinks the x- and y-dimension by the same factor. In the same way a
similar shrinkage of any pair of axes is possible. Hence a mapping
\(\vec{x}\mapsto\?D\vec{x}\) is possible where the diagonal entries just have to satisfy
\(0\?<\?d_i\?<\?1\).
</p>

<p>
Finally amplitude damping together with a rotation can be used to realize a non-trivial
\(\vec{c}\). Note that amplitude damping also shrinks everything, but not more than by a factor
\(1-\gamma\). This is the reason why we impose the condition \(0\?<\?d_i\?<\?1-\gamma\) on the
realizability of the diagonal entries. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org2813bd9" class="outline-3">
<h3 id="org2813bd9">Exercise 8.34 (Process tomography for two qubits)</h3>
<div class="outline-text-3" id="text-org2813bd9">
<p>
Show that the \(\chi_2\) describing the black box operations on two qubits can be expressed
as
</p>

<p>
\[
  \chi_2 = \Lambda_2 \sigma \Lambda_2 ,
\]
</p>

<p>
where \(\Lambda_2=\Lambda\otimes\Lambda\), \(\Lambda\) is as deï¬ned in Box 8.5, and \(\sigma\) is a
block matrix of 16 measured density matrices,
</p>

<p>
\[
  \sigma = P^\top \left( \sum_{mn} \rho_{mn}\otimes\rho'_{mn} \right)  P
\]
</p>

<p>
where \(\rho'_{nm}=\calE(\rho_{nm})\), \(\rho_{nm}=T_n\proj{00}T_m\), \(T_1=I\otimes\?I\),
\(T_2=I\otimes\?X\), \(T_3=X\otimes\?I\), \(T_4=X\otimes\?X\), and
\(P=I\otimes[(\rho_{00}+\rho_{12}+\rho_{21}+\rho_{33})\otimes\?I]\) is a permutation matrix.
</p>

<dl class="org-dl">
<dt>Remarks</dt><dd><ul class="org-ul">
<li>The formula for sigma is equivalent to the one in the book. I find it to be more
concise. It follows from the fact that the \(\rho_{mn}\) are matrices with zeros every
except at the position \((m,n)\).</li>
<li><p>
I <i>think</i> that there is a tiny error in this exercise. I think one should use \(P\) to
conjugate \(\Lambda_2\) so that the formula is as follows:
</p>

<p>
\[
    \chi_2 = P \Lambda_2 P R' P \Lambda_2 P = P \Lambda_2 \sigma \Lambda_2 P ,
    \]
</p>

<p>
where \(R'\) is the same as \(\sigma\) but without conjugating with \(P\).
</p></li>
</ul></dd>
</dl>
</div>

<div id="outline-container-org7ee8b9c" class="outline-4">
<h4 id="org7ee8b9c">Proof</h4>
<div class="outline-text-4" id="text-org7ee8b9c">
<p>
I will slightly deviate from the exercise (but still solve it) to get a better insight
into what is going on. I will change the exercise in the following way:
</p>

<ul class="org-ul">
<li>I consider \(d\geq1\) qubits - generalizing the statement (and actually making it easier to grasp).</li>
<li>I define a slightly different \(\Lambda_d\) avoiding the \(P\).</li>
</ul>

<p>
The task can be reduced to <a href="#chapter-8-process-tomography-single-qubit">the case</a> \(d=1\) which I already proved in the introduction to
this chapter. I reuse the notation from there so please have a look. Let
</p>

<p>
\[
  \calE(\rho) = \sum_{mn} \chi_{mn} K_m \rho K_n ,
\]
</p>

<p>
where \(K_m=\bigotimes_{x=0}^{d-1}N_{m_x}\). Our task is to find \(\chi\). Let
</p>

<p>
\[
  \tilde{\Lambda}_d = \frac{1}{2^d} \sum_a \bigotimes_{x=0}^{d-1} L_{a_x} \otimes \bigotimes_{x=0}^{d-1} R_{a_x} .
\]
</p>

<p>
Then
</p>

<p>
\[
  \tilde{\Lambda}_d R' \tilde{\Lambda}_d = \frac{1}{4^d} \sum_{mnab} \chi_{mn}
    \left[\bigotimes_{x=0}^{d-1} L_{a_x} P_{i_xj_x} L_{b_x} \right]
    \otimes
    \left[\bigotimes_{x=0}^{d-1} R_{a_x} N_{m_x} P_{i_xj_x} N_{n_x} R_{b_x}  \right]
\]
</p>

<p>
But the RHS is just the tensorized version of a <a href="#orgd24d882">formula</a> for the case \(d=1\). Hence the LHS
must equal \(\chi\) (note that the tensor-product must be in the right order to not get a
permuted version of \(\chi\)).
</p>

<p>
To see why the permuation matrix \(P\) is necessary in the context of the exercise let us
again consider the case \(d=2\). Here we have
</p>

\begin{align*}
  \Lambda_2 &= \sum_a L_{a_1} \otimes R_{a_1} \otimes L_{a_0} \otimes R_{a_0} , \\
  \tilde{\Lambda}_2 &= \sum_a L_{a_1} \otimes L_{a_0} \otimes R_{a_1} \otimes R_{a_0} .
\end{align*}

<p>
Hence we see that only the two middle operators are swapped. This is the purpose of the
permuation. We could also leave out the permuation and just replace \(\tilde{\Lambda}_2\) by
\(\Lambda_2\), but in that case we would get a permuted version of \(\chi\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf7e4cb2" class="outline-3">
<h3 id="orgf7e4cb2">Exercise 8.35 (Process tomography example)</h3>
<div class="outline-text-3" id="text-orgf7e4cb2">
<p>
Consider a one qubit black box of unknown dynamics \(\calE_1\). Suppose that the following
four density matrices are obtained from experimental measurements, performed according to
Equations (8.173)â€“(8.176):
</p>

\begin{align*}
  \rho_1' &= \begin{bmatrix} 1 & 0 \\ 0 & 0 \end{bmatrix} , \\
  \rho_2' &= \begin{bmatrix} 0 & \sqrt{1-\gamma} \\ 0 & 0 \end{bmatrix} , \\
  \rho_3' &= \begin{bmatrix} 0 & 0 \\ \sqrt{1-\gamma} & 0 \end{bmatrix} , \\
  \rho_4' &= \begin{bmatrix} \gamma & 0 \\ 0 & 1-\gamma \end{bmatrix} .
\end{align*}

<p>
where \(\gamma\) is a numerical parameter. From an independent study of each of these
inputâ€“output relations, one could make several important observations: the ground state
\(\ket{0}\) is left invariant by \(\calE_1\), the excited state \(\ket{1}\) partially decays to
the ground state, and superposition states are damped. Determine the \(\chi\) matrix for
this process.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>I wonder why we should stop at computing the chi matrix. Anyway, let us extend
the exercise by the requirement to also compute operation elements for this operation.</dd>
</dl>
</div>

<div id="outline-container-orge0db7bc" class="outline-4">
<h4 id="orge0db7bc">Solution 1</h4>
<div class="outline-text-4" id="text-orge0db7bc">
<p>
Let us first set up two routines to compute \(\beta\) and \(\lambda\). We specialize those to
the single qubit case. Moreover we use the basis \((\rho_j)=(P_0, P_0X, XP_0,XP_0X)\) (where
\(P_0=\proj{0}\)) for the space where the density matrices live.
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org1d05ba2"><span class="org-keyword">def</span> <span class="org-function-name">compute_beta_835</span>(Es: <span class="org-builtin">list</span>[matrix]):
    <span class="org-doc">"""Compute beta for single qubit and specific choice of basis of input matrix space."""</span>
    <span class="org-variable-name">rho</span> <span class="org-operator">=</span> [P0, P0<span class="org-operator">*</span>X, X<span class="org-operator">*</span>P0, X<span class="org-operator">*</span>P0<span class="org-operator">*</span>X] <span class="org-comment-delimiter"># </span><span class="org-comment">basis</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">As suggested in the text we flatten the space of 4x4 matrices to a 16-dimensional</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">vector. This turns beta into a 16x16 matrix.</span>
    <span class="org-variable-name">beta</span> <span class="org-operator">=</span> matrix.zero(16)

    <span class="org-keyword">for</span> m, n <span class="org-keyword">in</span> product(<span class="org-builtin">range</span>(4), <span class="org-builtin">range</span>(4)):
        <span class="org-keyword">for</span> j, k <span class="org-keyword">in</span> product(<span class="org-builtin">range</span>(4), <span class="org-builtin">range</span>(4)):
            <span class="org-variable-name">rho_prime</span> <span class="org-operator">=</span> Es[m] <span class="org-operator">*</span> rho[j] <span class="org-operator">*</span> Es[n].H
            <span class="org-variable-name">beta</span>[j<span class="org-operator">+</span>4<span class="org-operator">*</span>k, m<span class="org-operator">+</span>4<span class="org-operator">*</span>n] <span class="org-operator">=</span> trace(rho[k].H <span class="org-operator">*</span> rho_prime)

    <span class="org-keyword">return</span> beta


<span class="org-keyword">def</span> <span class="org-function-name">compute_lambda_835</span>(rho_prime):
    <span class="org-doc">"""Compute lambda for single qubit and specific choice of basis of input matrix</span>
<span class="org-doc">    space."""</span>
    <span class="org-variable-name">rho</span> <span class="org-operator">=</span> [P0, P0<span class="org-operator">*</span>X, X<span class="org-operator">*</span>P0, X<span class="org-operator">*</span>P0<span class="org-operator">*</span>X] <span class="org-comment-delimiter"># </span><span class="org-comment">basis</span>

    <span class="org-variable-name">lam</span> <span class="org-operator">=</span> [<span class="org-constant">None</span> <span class="org-keyword">for</span> _ <span class="org-keyword">in</span> <span class="org-builtin">range</span>(16)]

    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(4):
        <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(4):
            <span class="org-variable-name">lam</span>[j<span class="org-operator">+</span>4<span class="org-operator">*</span>k] <span class="org-operator">=</span> trace(rho[k].H <span class="org-operator">*</span> rho_prime[j])

    <span class="org-keyword">return</span> vector(lam)


<span class="org-keyword">def</span> <span class="org-function-name">toMatrix_835</span>(vec):
    <span class="org-doc">"""Convert a flattened 4x4 matrix back to matrix representation."""</span>
    <span class="org-keyword">return</span> matrix(SR, 4, 4, <span class="org-keyword">lambda</span> m,n: vec[m<span class="org-operator">+</span>4<span class="org-operator">*</span>n])
</pre>
</div>

<p>
The following code computes \(\chi\). As a basis for the operation elements we use the
\(\tilde{E}_j\) as in box 8.5: \((I,X,-\ii\?Y,Z)\).
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgb0c4d2a"><span class="org-variable-name">rho_prime_835</span> <span class="org-operator">=</span> [
    matrix([
        [1, 0],
        [0, 0],
    ]),
    matrix([
        [0, sqrt(1<span class="org-operator">-</span>g)],
        [0, 0],
    ]),
    matrix([
        [0, 0],
        [sqrt(1<span class="org-operator">-</span>g), 0],
    ]),
    matrix([
        [g, 0],
        [0, 1<span class="org-operator">-</span>g],
    ]),
]

<span class="org-comment-delimiter"># </span><span class="org-comment">E-tilde as basis for beta as in box 8.5:</span>
<span class="org-variable-name">beta_835</span> <span class="org-operator">=</span> compute_beta_835([Id, X, <span class="org-operator">-</span>i<span class="org-operator">*</span>Y, Z])
<span class="org-variable-name">kappa_835</span> <span class="org-operator">=</span> beta_835.pseudoinverse()
<span class="org-keyword">assert</span> beta_835 <span class="org-operator">==</span> beta_835 <span class="org-operator">*</span> kappa_835 <span class="org-operator">*</span> beta_835, <span class="org-string">"kappa is pseudoinverse of beta"</span>

<span class="org-variable-name">lam_835</span> <span class="org-operator">=</span> compute_lambda_835(rho_prime_835)
<span class="org-variable-name">chi_835</span> <span class="org-operator">=</span> toMatrix_835(kappa_835 <span class="org-operator">*</span> lam_835)
</pre>
</div>

<p>
Let us print \(\chi\):
</p>

<div class="org-src-container">
<pre class="src src-sage">chi_835
</pre>
</div>

<pre class="example">
[-1/4*g + 1/2*sqrt(-g + 1) + 1/2                               0                               0                           1/4*g]
[                              0                           1/4*g                          -1/4*g                               0]
[                              0                          -1/4*g                           1/4*g                               0]
[                          1/4*g                               0                               0 -1/4*g - 1/2*sqrt(-g + 1) + 1/2]
</pre>


<p>
To obtain the operation elements we have to diagonalize \(\chi\).
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">D</span>, <span class="org-variable-name">U</span> <span class="org-operator">=</span> chi_835.eigenmatrix_right()
<span class="org-builtin">print</span>(f<span class="org-string">"D (diagonalized chi matrix) = </span><span class="org-constant">\n</span>{D}<span class="org-string">"</span>)
<span class="org-builtin">print</span>(f<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">U (columns contain eigenvectors) = </span><span class="org-constant">\n</span>{U}<span class="org-string">"</span>)
</pre>
</div>

<pre class="example" id="org21cf0d6">
D (diagonalized chi matrix) =
[-1/2*g + 1          0          0          0]
[         0          0          0          0]
[         0          0          0          0]
[         0          0          0      1/2*g]

U (columns contain eigenvectors) =
[                          1                           1                           0                           0]
[                          0                           0                           1                           1]
[                          0                           0                           1                          -1]
[-(g + 2*sqrt(-g + 1) - 2)/g  (g - 2*sqrt(-g + 1) - 2)/g                           0                           0]
</pre>

<p>
There are only two non-zero eigenvalues of the chi-matrix:
</p>

<p>
\[
  d_0 = 1 - \frac{g}{2}, \quad d_3 = \frac{g}{4} .
\]
</p>

<p>
The corresponding normalized eigenvectors are
</p>

<p>
\[
  u_0 = (1, 0, 0, r)/\sqrt{1+r^2}, \quad u_3 = (0, 1, -1, 0)/\sqrt{2} ,
\]
</p>

<p>
where \(r=g\inv(1-\sqrt{1-g})^2\). This implies the following operation elements:
</p>

\begin{align*}
  E_0 &= \sqrt{\frac{1-\frac{g}{2}}{1+r^2}} \, (I + rZ) , \\
  E_3 &= \frac{\sqrt{g}}{2} \, (X + \ii Y) .
\end{align*}

<div class="org-src-container">
<pre class="src src-sage" id="org78917bc"><span class="org-variable-name">r</span> <span class="org-operator">=</span> (1<span class="org-operator">/</span>g)<span class="org-operator">*</span>(1<span class="org-operator">-</span>sqrt(1<span class="org-operator">-</span>g))<span class="org-operator">^</span>2
<span class="org-variable-name">op835</span> <span class="org-operator">=</span> make_operation([sqrt(1<span class="org-operator">-</span>g<span class="org-operator">/</span>2)<span class="org-operator">*</span>(Id<span class="org-operator">+</span>r<span class="org-operator">*</span>Z)<span class="org-operator">/</span>sqrt(1<span class="org-operator">+</span>r<span class="org-operator">^</span>2), sqrt(g)<span class="org-operator">*</span>(X<span class="org-operator">+</span>i<span class="org-operator">*</span>Y)<span class="org-operator">/</span>2])
</pre>
</div>

<p>
Let us briefly verify that this operation indeed implements the desired operation:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">rho</span> <span class="org-operator">=</span> [P0, P0<span class="org-operator">*</span>X, X<span class="org-operator">*</span>P0, X<span class="org-operator">*</span>P0<span class="org-operator">*</span>X]
<span class="org-keyword">assert</span> op835(rho[0]) <span class="org-operator">==</span> rho_prime_835[0]
<span class="org-keyword">assert</span> op835(rho[1]) <span class="org-operator">==</span> rho_prime_835[1]
<span class="org-keyword">assert</span> op835(rho[2]) <span class="org-operator">==</span> rho_prime_835[2]
<span class="org-keyword">assert</span> op835(rho[3]) <span class="org-operator">==</span> rho_prime_835[3]
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>

<div id="outline-container-org71c66eb" class="outline-4">
<h4 id="org71c66eb">Solution 2</h4>
<div class="outline-text-4" id="text-org71c66eb">
<p>
In box 8.5 another way to compute the chi-matrix was suggested. It is based on a matrix
\(\Lambda\):
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org53ec298"><span class="org-variable-name">Lambda1</span> <span class="org-operator">=</span> (kron(Z, Id) <span class="org-operator">+</span> kron(X, X)) <span class="org-operator">/</span> 2
</pre>
</div>

<p>
In addition we need the following utility functions. The first one computes the matrix
</p>

<p>
\[
  R' := \begin{bmatrix} \rho_1' & \rho_2' \\ \rho_3' & \rho_4' \end{bmatrix} .
\]
</p>

<p>
It utilizes the fact that this matrix is just \(\sum_j\rho_j\otimes\rho_j'\) for our
specific choice of \((\rho_j)\). The second one just implements the formula (see (8.179))
</p>

<p>
\[
  \chi = \Lambda R' \Lambda .
\]
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org3bced9f"><span class="org-keyword">def</span> <span class="org-function-name">compute_rho_prime_matrix_835</span>(rho_primes):
    <span class="org-variable-name">rhos</span> <span class="org-operator">=</span> [P0, P0<span class="org-operator">*</span>X, X<span class="org-operator">*</span>P0, X<span class="org-operator">*</span>P0<span class="org-operator">*</span>X]
    <span class="org-variable-name">lam</span> <span class="org-operator">=</span> matrix.zero(4)

    <span class="org-keyword">for</span> rho, rho_prime <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(rhos, rho_primes):
        <span class="org-variable-name">lam</span> <span class="org-operator">+=</span> kron(rho, rho_prime)

    <span class="org-keyword">return</span> lam


<span class="org-keyword">def</span> <span class="org-function-name">compute_chi_via_Lambda_835</span>(rho_primes):
    <span class="org-keyword">return</span> Lambda1 <span class="org-operator">*</span> compute_rho_prime_matrix_835(rho_primes) <span class="org-operator">*</span> Lambda1
</pre>
</div>

<p>
So let us compute \(\chi\):
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org44e2b93"><span class="org-comment-delimiter"># </span><span class="org-comment">Take rho_prime_835 from solution 1:</span>
<span class="org-variable-name">chi_835_2</span> <span class="org-operator">=</span> compute_chi_via_Lambda_835(rho_prime_835)
</pre>
</div>

<p>
Let us do a quick check that we got the same thing as in the first solution. Note that
this is only possible because we used the same bases for the operation elements
(\((I,X,-\ii\?Y,Z)\)) and the matrix space where the density matrices live
(\((P_0,P_0X,XP_0,XP_0X)\)). Otherwise the number might be completely different of course.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> chi_835 <span class="org-operator">==</span> chi_835_2
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
The rest is the same as in the first solution.
</p>
</div>
</div>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1.90 (<a href="https://orgmode.org">Org</a> mode 9.6.10)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>