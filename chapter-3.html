<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 3</title><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 3</h1>\[
\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\]
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8e20947">Setup</a>
<ul>
<li><a href="#orgdbedb32">Python Libraries</a></li>
<li><a href="#org43ce79a">Turing Machines</a></li>
</ul>
</li>
<li><a href="#orgfa6f8e7"><span class="todo WIP">WIP</span> Exercises</a>
<ul>
<li><a href="#orgfbfdc96"><span class="todo TODO">TODO</span> Exercise 3.1 (Non-computable processes in Nature)</a></li>
<li><a href="#org3cd04be">Exercise 3.2 (Turing numbers)</a></li>
<li><a href="#orgecfa514">Exercise 3.3 (Turing machine to reverse a bit string)</a></li>
<li><a href="#orgd5a77e5">Exercise 3.4 (Turing machine to add modulo 2)</a></li>
<li><a href="#org11e1c94">Exercise 3.5 (Halting problem with no inputs)</a></li>
<li><a href="#org23909f3">Exercise 3.6 (Probabilistic halting problem)</a></li>
<li><a href="#org6c76350">Exercise 3.7 (Halting oracle)</a></li>
<li><a href="#orgacde60c">Exercise 3.8 (Universality of <code>NAND</code>)</a></li>
<li><a href="#orgdd21c41"><span class="todo SKIP">SKIP</span> Exercises 3.9-3.14</a></li>
<li><a href="#orgbb0d5dc">Exercise 3.15</a></li>
<li><a href="#org11a5355"><span class="todo TODO">TODO</span> Exercise 3.16 (Hard-to-compute functions exist)</a></li>
<li><a href="#org1d99f6a">Exercise 3.17</a></li>
<li><a href="#org7331953">Exercise 3.18</a></li>
<li><a href="#orgb3f4fa4">Exercise 3.19</a></li>
<li><a href="#org1eb29a3">Exercise 3.20 (Euler's theorem)</a></li>
<li><a href="#orge26a447">Exercise 3.21 (Transitive property of reduction)</a></li>
<li><a href="#org96a7f2d">Exercise 3.22</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8e20947" class="outline-2">
<h2 id="org8e20947">Setup</h2>
<div class="outline-text-2" id="text-org8e20947">
</div>
<div id="outline-container-orgdbedb32" class="outline-3">
<h3 id="orgdbedb32">Python Libraries</h3>
<div class="outline-text-3" id="text-orgdbedb32">
<div class="org-src-container">
<pre class="src src-python" id="org7fdc003"><span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> Literal, NewType, Optional
<span class="org-keyword">from</span> collections.abc <span class="org-keyword">import</span> Callable

<span class="org-keyword">from</span> utils <span class="org-keyword">import</span> TermColor
</pre>
</div>
</div>
</div>

<div id="outline-container-org43ce79a" class="outline-3">
<h3 id="org43ce79a">Turing Machines</h3>
<div class="outline-text-3" id="text-org43ce79a">
</div>
<div id="outline-container-org0403883" class="outline-4">
<h4 id="org0403883">Introduction</h4>
<div class="outline-text-4" id="text-org0403883">
<p>
In this section we define a class <code>TuringMachine</code> which empowers us to execute a turing program like
this one:
</p>

<pre class="example" id="turing-program-constant-one">
# This program computes the function f(n)=1.
# Example: input="▶1001", output="▶1".
(S,▶,A,▶,+) # S is the start state
(A,0,A,■,+)
(A,1,A,■,+)
(A,■,B,■,-)
(B,■,B,■,-)
(B,▶,C,▶,+)
(C,■,H,1,0) # H is the halt state
</pre>

<p>
Below we initialize a turing machine <code>my_tm</code> from the above source code:
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgc662ca4"><span class="org-variable-name">my_tm</span> = TuringMachine.fromSource(source, start_state=<span class="org-string">"S"</span>, halt_state=<span class="org-string">"H"</span>)
<span class="org-variable-name">my_tm.LOG_LEVEL</span> = 3
<span class="org-variable-name">my_tm.COLORED_LOG</span> = <span class="org-constant">False</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">set to false since listing below does not support colors</span>

<span class="org-variable-name">result</span> = my_tm.run(<span class="org-string">"&#9654;0"</span>)
<span class="org-keyword">print</span>(f<span class="org-string">"\nresult = '{result}'"</span>)
</pre>
</div>

<p>
Setting <code>LOG_LEVEL=3</code> makes the Turing machine print certain informations for each step of
execution. The result can be seen in the following listing (with <code>COLORED_LOG=True</code> this would be
even more informative). Note that in theory the tape is infinite. We realize this by dynamically
allocating new blank cells whenever we want to access a cell not already allocated (we roughly
double the tape size in that case).
</p>

<pre class="example">

Executing step 1
tape = '▶0'
state='S', symbol='▶', head_position=0
source line = 2: (S,▶,A,▶,+) # S is the start state

Executing step 2
tape = '▶0'
state='A', symbol='0', head_position=1
source line = 3: (A,0,A,■,+)

Executing step 3
tape = '▶■■■■'
state='A', symbol='■', head_position=2
source line = 5: (A,■,B,■,-)

Executing step 4
tape = '▶■■■■'
state='B', symbol='■', head_position=1
source line = 6: (B,■,B,■,-)

Executing step 5
tape = '▶■■■■'
state='B', symbol='▶', head_position=0
source line = 7: (B,▶,C,▶,+)

Executing step 6
tape = '▶■■■■'
state='C', symbol='■', head_position=1
source line = 8: (C,■,H,1,0) # H is the halt state

Execution took 6 steps.

result = '▶1'
</pre>
</div>
</div>

<div id="outline-container-orgfab405f" class="outline-4">
<h4 id="orgfab405f">Implementation</h4>
<div class="outline-text-4" id="text-orgfab405f">
<p>
First we introduce some useful types. We represent the state by strings since this <i>allows</i> for
readable or at least mnemonic state names. This would not be possible had we used integers. The
<code>SourceMap</code> is responsible for connecting each parsed line of the turing program with its original
from the source-string/file. It is the reason why in the <a href="#orgc662ca4">listing above</a> the <code>TuringMachine</code> instance
can refer to its source (see the line starting with <code>source line =</code>).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org995c32f"><span class="org-variable-name">Char</span> = NewType(<span class="org-string">"Char"</span>, <span class="org-builtin">str</span>)  <span class="org-comment-delimiter"># </span><span class="org-comment">better than nothing, represents a letter from the alphabet</span>
<span class="org-variable-name">State</span> = NewType(<span class="org-string">"State"</span>, <span class="org-builtin">str</span>)
<span class="org-variable-name">Move</span> = Literal[-1, 0, +1]
<span class="org-variable-name">TuringProgLine</span> = <span class="org-builtin">tuple</span>[State, Char, State, Char, Move]  <span class="org-comment-delimiter"># </span><span class="org-comment">(s,c,s',c',m)</span>
<span class="org-variable-name">TuringProgram</span> = <span class="org-builtin">list</span>[TuringProgLine]

<span class="org-variable-name">SourceMap</span> = <span class="org-builtin">list</span>[<span class="org-builtin">tuple</span>[<span class="org-builtin">int</span>, <span class="org-builtin">str</span>]]
<span class="org-variable-name">TuringParser</span> = Callable[[<span class="org-builtin">str</span>], [<span class="org-builtin">tuple</span>[TuringProgram, SourceMap | <span class="org-constant">None</span>]]]
</pre>
</div>

<p>
<a href="#org7779ceb">Below</a> follows the implementation of the <code>TuringMachine</code>. The logging functionality bloats the
implementation a bit. But it you ignore this the implementation is very simple and straightforward
to understand (IMHO).
</p>

<p>
Note that the <code>__init__</code> method takes the program as an already parsed list of tuples
(<code>TuringProgram</code>). The canonical way to create a <code>TuringMachine</code> is to use the <code>fromSource</code> factory
method. Among other things you can optionally provide a custom parser. This might be beneficial to
introduce syntactic sugar. For example the code snippit
</p>

<pre class="example">
(a,0,a,0,+)
(a,1,a,1,+)
(a,2,a,2,+)
(a,3,a,3,+)
(a,4,a,4,+)
(a,5,a,5,+)
</pre>

<p>
might seem somewhat verbose. Probably this would be nicer syntax:
</p>

<pre class="example">
(a,0|1|2|3|4|5,a,$,+)  # "$" meaning: take the original
# or even (if this is the intended meaning)
(a,*,a,$,+)  # "*" meaning: match all
</pre>

<p>
Another reason to use a custom parser would be to circumvent some restrictions of the default
parser. For example the default parser treats the symbols <code>#</code>, <code>,</code>, <code>(</code>, <code>)</code> in a special way. In
particular, those cannot be used as characters on the tape.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org7779ceb"><span class="org-keyword">class</span> <span class="org-type">TuringMachine</span>:
    <span class="org-doc">"""Given a turing program produces the corresponding turing machine."""</span>
    BLANK: <span class="org-variable-name">Char</span> = <span class="org-string">"&#9632;"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Special symbol for the blank cell. Is used when tape dynamically grows.</span>
    <span class="org-variable-name">MAX_STEPS</span> = 1000000  <span class="org-comment-delimiter"># </span><span class="org-comment">Abort after running this many steps</span>
    <span class="org-variable-name">LOG_LEVEL</span> = 0  <span class="org-comment-delimiter"># </span><span class="org-comment">Set greater 0 for a chatty execution</span>
    <span class="org-variable-name">COLORED_LOG</span> = <span class="org-constant">True</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">Turn of if environment does not support colors</span>
    <span class="org-variable-name">SOURCE_LINE_OFFSET</span> = 0  <span class="org-comment-delimiter"># </span><span class="org-comment">SourceMap assumes that source file start with line 0. Adjust this here.</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, program: TuringProgram,
                 start_state: State = <span class="org-string">"START"</span>, halt_state: State = <span class="org-string">"HALT"</span>,
                 source_map: Optional[SourceMap] = <span class="org-constant">None</span>):
        <span class="org-keyword">self</span>._start_state = start_state
        <span class="org-keyword">self</span>._halt_state = halt_state
        <span class="org-keyword">self</span>._program = program
        <span class="org-keyword">self</span>._source_map = source_map

        <span class="org-keyword">assert</span> source_map <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">or</span> <span class="org-builtin">len</span>(source_map) == <span class="org-builtin">len</span>(program), <span class="org-string">"Invalid source_map"</span>

        <span class="org-keyword">self</span>._state = <span class="org-constant">None</span>
        <span class="org-keyword">self</span>._head_position: <span class="org-builtin">int</span> = <span class="org-constant">None</span>
        <span class="org-keyword">self</span>._tape: <span class="org-builtin">list</span>[Char] = []  <span class="org-comment-delimiter"># </span><span class="org-comment">gets input during execution</span>
        <span class="org-keyword">self</span>._step_count = <span class="org-constant">None</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">Only relevant for logging:</span>
        <span class="org-keyword">self</span>._index_width = <span class="org-builtin">len</span>(<span class="org-builtin">str</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>._program)-1))

    @<span class="org-builtin">classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">fromSource</span>(cls, source: <span class="org-builtin">str</span>,
                   start_state: State = <span class="org-string">"START"</span>, halt_state: State = <span class="org-string">"HALT"</span>,
                   parser: TuringParser = parse_turing_program) -&gt; <span class="org-string">"TuringMachine"</span>:
        <span class="org-doc">"""Create a turing machine from a source string. You can provide a custom parser."""</span>
        <span class="org-variable-name">program</span>, <span class="org-variable-name">source_map</span> = parser(source)
        <span class="org-keyword">return</span> TuringMachine(program,
                             start_state=start_state, halt_state=halt_state,
                             source_map=source_map)

    <span class="org-keyword">def</span> <span class="org-function-name">run</span>(<span class="org-keyword">self</span>, tape_input: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-doc">"""Run the TM and return what is on the tape after it halts."""</span>
        <span class="org-keyword">self</span>._state = <span class="org-keyword">self</span>._start_state
        <span class="org-keyword">self</span>._head_position = 0
        <span class="org-keyword">self</span>._tape = <span class="org-builtin">list</span>(tape_input)
        <span class="org-keyword">self</span>._step_count = 0

        <span class="org-keyword">while</span> <span class="org-keyword">self</span>._state != <span class="org-keyword">self</span>._halt_state:
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>._step_count &gt; <span class="org-keyword">self</span>.MAX_STEPS:
                <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"Turing machine takes too long. Aborting."</span>)
            <span class="org-keyword">self</span>._step_count += 1
            <span class="org-keyword">self</span>._log(2, f<span class="org-string">"\nExecuting step {self._step_count}"</span>)
            <span class="org-keyword">self</span>._run_one_step()

        <span class="org-keyword">self</span>._log(1, f<span class="org-string">"\nExecution took {self._step_count} steps."</span>)

        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._tape_content.strip(<span class="org-keyword">self</span>.BLANK)

    @<span class="org-builtin">property</span>
    <span class="org-keyword">def</span> <span class="org-function-name">_line_no_width</span>(<span class="org-keyword">self</span>):  <span class="org-comment-delimiter"># </span><span class="org-comment">only relevant for logging</span>
        <span class="org-keyword">return</span> <span class="org-constant">None</span> <span class="org-keyword">if</span> <span class="org-keyword">self</span>._source_map <span class="org-keyword">is</span> <span class="org-constant">None</span> \
            <span class="org-keyword">else</span> <span class="org-builtin">len</span>(<span class="org-builtin">str</span>(<span class="org-keyword">self</span>._source_map[-1][0] + <span class="org-keyword">self</span>.SOURCE_LINE_OFFSET - 1))

    <span class="org-keyword">def</span> <span class="org-function-name">_log</span>(<span class="org-keyword">self</span>, level, *args, **kwargs):
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.LOG_LEVEL &gt;= level:
            <span class="org-keyword">print</span>(*args, **kwargs)

    <span class="org-keyword">def</span> <span class="org-function-name">_run_one_step</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-keyword">self</span>._log(3, f<span class="org-string">"tape = '{self._colored_tape_content}'"</span>)
        <span class="org-variable-name">current_line</span> = <span class="org-keyword">self</span>._current_program_line

        <span class="org-keyword">if</span> current_line <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">RED</span>, <span class="org-variable-name">ENDC</span> = (TermColor.RED, TermColor.ENDC) <span class="org-keyword">if</span> <span class="org-keyword">self</span>.COLORED_LOG <span class="org-keyword">else</span> (<span class="org-string">""</span>, <span class="org-string">""</span>)
            <span class="org-keyword">self</span>._log(2, f<span class="org-string">"{RED}No matching program line - halting{ENDC}"</span>)
            <span class="org-keyword">self</span>._state = <span class="org-keyword">self</span>._halt_state
            <span class="org-keyword">return</span>

        <span class="org-variable-name">index</span>, <span class="org-variable-name">current_line</span> = current_line
        <span class="org-keyword">self</span>._log(4, f<span class="org-string">"program line = {index:{self._index_width}}: {current_line}"</span>)

        <span class="org-keyword">if</span> <span class="org-keyword">self</span>._source_map <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">line_no</span>, <span class="org-variable-name">source_line</span> = <span class="org-keyword">self</span>._source_map[index]
            <span class="org-variable-name">line_no</span> += <span class="org-keyword">self</span>.SOURCE_LINE_OFFSET
            <span class="org-keyword">self</span>._log(3, f<span class="org-string">"source line = {line_no:{self._line_no_width}}: {source_line}"</span>)

        <span class="org-variable-name">s1</span>, <span class="org-variable-name">c1</span>, <span class="org-variable-name">m</span> = current_line[2:]

        <span class="org-keyword">self</span>._state = s1
        <span class="org-keyword">self</span>._head_symbol = c1
        <span class="org-comment-delimiter"># </span><span class="org-comment">avoid negative positions:</span>
        <span class="org-keyword">self</span>._head_position = <span class="org-builtin">max</span>(<span class="org-keyword">self</span>._head_position + m, 0)

    @<span class="org-builtin">property</span>
    <span class="org-keyword">def</span> <span class="org-function-name">_tape_content</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-keyword">return</span> <span class="org-string">""</span>.join(<span class="org-keyword">self</span>._tape)

    @<span class="org-builtin">property</span>
    <span class="org-keyword">def</span> <span class="org-function-name">_colored_tape_content</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-keyword">self</span>._enlarge_tape_if_necessary()
        <span class="org-variable-name">text</span> = <span class="org-keyword">self</span>._tape_content
        <span class="org-variable-name">pos</span> = <span class="org-keyword">self</span>._head_position
        <span class="org-variable-name">GREEN</span>, <span class="org-variable-name">ENDC</span> = (TermColor.GREEN, TermColor.ENDC) <span class="org-keyword">if</span> <span class="org-keyword">self</span>.COLORED_LOG <span class="org-keyword">else</span> (<span class="org-string">""</span>, <span class="org-string">""</span>)
        <span class="org-keyword">return</span> text[:pos] + GREEN + text[pos] + ENDC + text[pos+1:]

    @<span class="org-builtin">property</span>
    <span class="org-keyword">def</span> <span class="org-function-name">_current_program_line</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">tuple</span>[<span class="org-builtin">int</span>, TuringProgLine]:
        <span class="org-variable-name">s0</span>, <span class="org-variable-name">c0</span> = <span class="org-keyword">self</span>._state, <span class="org-keyword">self</span>._head_symbol
        <span class="org-keyword">self</span>._log(2, f<span class="org-string">"state='{s0}', symbol='{c0}', head_position={self._head_position}"</span>)
        <span class="org-keyword">for</span> i, line <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(<span class="org-keyword">self</span>._program):
            <span class="org-variable-name">s</span>, <span class="org-variable-name">c</span> = line[:2]
            <span class="org-keyword">if</span> s0 == s <span class="org-keyword">and</span> c0 == c:
                <span class="org-keyword">return</span> i, line

        <span class="org-keyword">return</span> <span class="org-constant">None</span>

    @<span class="org-builtin">property</span>
    <span class="org-keyword">def</span> <span class="org-function-name">_head_symbol</span>(<span class="org-keyword">self</span>) -&gt; Char:
        <span class="org-keyword">self</span>._enlarge_tape_if_necessary()
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._tape[<span class="org-keyword">self</span>._head_position]

    <span class="org-type">@_head_symbol.setter</span>
    <span class="org-keyword">def</span> <span class="org-function-name">_head_symbol</span>(<span class="org-keyword">self</span>, new_symbol) -&gt; Char:
        <span class="org-keyword">self</span>._enlarge_tape_if_necessary()  <span class="org-comment-delimiter"># </span><span class="org-comment">just being paranoid</span>
        <span class="org-keyword">self</span>._tape[<span class="org-keyword">self</span>._head_position] = new_symbol

    <span class="org-keyword">def</span> <span class="org-function-name">_enlarge_tape_if_necessary</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-doc">"""Call this to ensure that our finite tape can actually be accessed at head position."""</span>
        <span class="org-variable-name">pos</span> = <span class="org-keyword">self</span>._head_position
        <span class="org-keyword">while</span> pos &gt;= <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._tape):  <span class="org-comment-delimiter"># </span><span class="org-comment">only one loop usually suffices</span>
            <span class="org-variable-name">some_blanks</span> = [<span class="org-keyword">self</span>.BLANK] * (1 + <span class="org-builtin">len</span>(<span class="org-keyword">self</span>._tape))
            <span class="org-keyword">self</span>._tape += some_blanks  <span class="org-comment-delimiter"># </span><span class="org-comment">double tape size</span>
</pre>
</div>

<p>
Finally, the default parser:
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgd6176e3"><span class="org-keyword">def</span> <span class="org-function-name">parse_turing_program_line</span>(line: <span class="org-builtin">str</span>) -&gt; TuringProgLine | <span class="org-constant">None</span>:
    <span class="org-doc">"""Parse a single line of the form `(s,c,s',c',m)` (up to comments).</span>

<span class="org-doc">    Empty or comment lines are ignored by returning `None`."""</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Remove comments and leading/trailing whitespace</span>
    <span class="org-variable-name">line</span> = line[:line.find(<span class="org-string">'#'</span>)].strip()
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(line) == 0:
        <span class="org-keyword">return</span> <span class="org-constant">None</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">line comment or empty line</span>

    <span class="org-variable-name">line</span> = line.strip().lstrip(<span class="org-string">"("</span>).rstrip(<span class="org-string">")"</span>)
    <span class="org-variable-name">s0</span>, <span class="org-variable-name">c0</span>, <span class="org-variable-name">s1</span>, <span class="org-variable-name">c1</span>, <span class="org-variable-name">m</span> = line.split(<span class="org-string">","</span>)
    <span class="org-variable-name">m</span> = +1 <span class="org-keyword">if</span> m == <span class="org-string">"+"</span> <span class="org-keyword">else</span> m  <span class="org-comment-delimiter"># </span><span class="org-comment">for convinience ...</span>
    <span class="org-variable-name">m</span> = -1 <span class="org-keyword">if</span> m == <span class="org-string">"-"</span> <span class="org-keyword">else</span> m  <span class="org-comment-delimiter"># </span><span class="org-comment">... allow shortcuts for +1, -1</span>
    <span class="org-variable-name">m</span> = <span class="org-builtin">int</span>(m)
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(c0) == 1, f<span class="org-string">"Expected character got '{c0}'."</span>
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(c1) == 1, f<span class="org-string">"Expected character got '{c1}'."</span>
    <span class="org-keyword">assert</span> m <span class="org-keyword">in</span> [-1, 0, +1], f<span class="org-string">"Forbidden head movement: {m}."</span>

    <span class="org-keyword">return</span> s0, c0, s1, c1, m


<span class="org-keyword">def</span> <span class="org-function-name">parse_turing_program</span>(source: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">tuple</span>[TuringProgram, SourceMap]:
    <span class="org-doc">"""Parses the source of a turing program line by line."""</span>
    program: <span class="org-variable-name">TuringProgram</span> = []
    source_map: <span class="org-builtin">list</span>[<span class="org-builtin">int</span>] = []

    <span class="org-variable-name">lines</span> = source.split(<span class="org-string">"\n"</span>)
    <span class="org-keyword">for</span> line_no, line <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(lines):
        <span class="org-keyword">try</span>:
            <span class="org-variable-name">parsed_line</span> = parse_turing_program_line(line)
        <span class="org-keyword">except</span> <span class="org-type">Exception</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Probably good enough for such a simple language:</span>
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Could not parse line {line_no}: '{line}'"</span>)

        <span class="org-keyword">if</span> parsed_line <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            program.append(parsed_line)
            source_map.append((line_no, line))

    <span class="org-keyword">return</span> program, source_map
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfa6f8e7" class="outline-2">
<h2 id="orgfa6f8e7"><span class="todo WIP">WIP</span> Exercises</h2>
<div class="outline-text-2" id="text-orgfa6f8e7">
</div>
<div id="outline-container-orgfbfdc96" class="outline-3">
<h3 id="orgfbfdc96"><span class="todo TODO">TODO</span> Exercise 3.1 (Non-computable processes in Nature)</h3>
<div class="outline-text-3" id="text-orgfbfdc96">
<p>
How might we recognize that a process in Nature computes a function not computable by a Turing
machine?
</p>
</div>
</div>

<div id="outline-container-org3cd04be" class="outline-3">
<h3 id="org3cd04be">Exercise 3.2 (Turing numbers)</h3>
<div class="outline-text-3" id="text-org3cd04be">
<p>
Show that single-tape Turing machines can each be given a number from the list \(1,2,3,\ldots\) in
such a way that the number uniquely specifies the corresponding machine. We call this number the
Turing number of the corresponding Turing machine. (<i>Hint</i>: Every positive integer has a unique
prime factorization \(p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}\), where \(p_i\) are distinct prime numbers,
and \(a_1,a_2,\ldots,a_k\) are non-negative integers.)
</p>
</div>

<div id="outline-container-orgb686d52" class="outline-4">
<h4 id="orgb686d52">Proof</h4>
<div class="outline-text-4" id="text-orgb686d52">
<p>
For simplicity we assume that the state space and the alphabet are fixed for all Turing machines we
consider (one could easily relax this constraint without complicating the encoding). Hence we need
to encode the start state, the halt state and the program into a single number. This is sufficient
to describe the Turing Machine. We follow the proposal to use prime numbers for that. Therefore let
us enumerate the prime numbers starting by \(2\): \(p_1=2\), \(p_2=3\), &#x2026;, \(p_5=11\), &#x2026; .
</p>

<p>
This procedure is certainly not the most efficient one but it serves the purpose to show that all
Turing machines (satsifying a specific definition/architecture) can be <i>effectively</i>
enumerated. That is, there is an <i>algorithm</i> (which could potentially run on a Turing machine),
which assigns numbers to each Turing machine. Moreover this assignment is invertible and the inverse
mapping (numbers to Turing machines) can be computed by an <i>algorithm</i> too.
</p>

<p>
Let us identify the states \(S\) and the elements of the alphabet \(\Gamma\) with integers:
</p>

<p>
\[
  S = \{0, 1, 2, \ldots\} ; \quad \Gamma = \{0, 1, 2, \ldots\} .
\]
</p>

<p>
Moreover, we encode the possible movements by \(\{0,1,2\}\), meaning <i>left</i>, <i>stay</i>, <i>right</i> in that
order. We encode the start state \(s\in\NN\) and the halt state \(h\in\NN\) by
</p>

<p>
\[
  p_1^s \text{ and } p_2^h .
\]
</p>

<p>
The \(i\)​-th program line
</p>

<p>
\[
  (q_i,c_i,q'_i,c'_i,m_i) \in \NN^4\times\{0,1,2\}
\]
</p>

<p>
can be encoded by
</p>

<p>
\[
  l_i = p_{5i+3}^{q_i} \, p_{5i+4}^{c_i} \, p_{5i+5}^{q'_i} \, p_{5i+6}^{c'_i} \, p_{5i+7}^{m_i} .
\]
</p>

<p>
The whole program is then encoded by the product \(\Pi_il_i\) and the Turing machine itself by
\(p_1^s\,p_2^h\,\Pi_il_i\). Since prime factorization of integers is unique, this encoding is
invertible and hence the Turing machine can be recovered from this (potentially large) number. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgecfa514" class="outline-3">
<h3 id="orgecfa514">Exercise 3.3 (Turing machine to reverse a bit string)</h3>
<div class="outline-text-3" id="text-orgecfa514">
<p>
Describe a Turing machine which takes a binary number \(x\) as input, and outputs the bits of \(x\) in
reverse order. (Hint: In this exercise and the next it may help to use a multi-tape Turing machine
and/or symbols other than ▶, 0, 1, and the blank.)
</p>
</div>

<div id="outline-container-org00ddd5f" class="outline-4">
<h4 id="org00ddd5f">Solution</h4>
<div class="outline-text-4" id="text-org00ddd5f">
<p>
We use a single tape together with and additional symbol "□", which we call <i>white blank</i> in the
following.
</p>

<p>
Assume that the input tape starts with the left-end-marker "▶" followed by the number \(x\) in
binary. All other cells should be blank. As an example, for \(x=13\) the input tape should look like
that:
</p>

<pre class="example" id="exercise-3.3-input-tape">
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 1 │ 0 │ 1 │   │   │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
</pre>

<p>
Note that the empty tape is not allowed - there should always be at least one digit. The Turing
machine should halt with only the reversed bitstring at the beginning of the tape. In the example
above:
</p>

<pre class="example" id="exercise-3.3-output-tape">
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │   │   │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
</pre>

<p>
The idea of the algorithm is as follows (the white blanks <code>□</code> simplify the implementation):
</p>

<dl class="org-dl">
<dt>1. Reverse the string, but shifted</dt><dd><code>▶1011■■■■■</code> → <code>▶□□□□1101■</code></dd>
<dt>2. Shift the reversed string to the correct position</dt><dd><code>▶□□□□1101■</code> → <code>▶1101□□□□■</code></dd>
<dt>3. Remove trailing white blanks</dt><dd><code>▶1101□□□□■</code> → <code>▶1101■■■■■</code></dd>
</dl>

<p>
Step-by-step the first part does the following. What we call <i>step</i> is actually several steps for
the Turing machine (since the head can only move by one position at a time). We remark already here
that the last displayed cell, containing a blank (always), is very important as an end-marker for
the second step of the algorithm.
</p>

<pre class="example" id="exercise-3.3-how-algorithm-works-1">
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │   │   │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 1 │ 0 │ □ │ 1 │   │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 1 │ □ │ □ │ 1 │ 0 │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ □ │ □ │ □ │ 1 │ 0 │ 1 │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ □ │ □ │ □ │ □ │ 1 │ 0 │ 1 │ 1 │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
</pre>

<p>
The second part of the algorithm does this:
</p>

<pre class="example" id="exercise-3.3-how-algorithm-works-2">
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ □ │ □ │ □ │ □ │ 1 │ 0 │ 1 │ 1 │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ □ │ □ │ □ │ □ │ 0 │ 1 │ 1 │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ □ │ □ │ □ │ □ │ 1 │ 1 │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ □ │ □ │ □ │ □ │ 1 │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │ □ │ □ │ □ │ □ │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
</pre>

<p>
Finally the third part acts like this:
</p>

<pre class="example" id="exercise-3.3-how-algorithm-works-3">
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │ □ │ □ │ □ │ □ │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │ □ │ □ │ □ │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │ □ │ □ │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │ □ │   │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬
│ ▶ │ 1 │ 0 │ 1 │ 1 │   │   │   │   │   │ ...
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴
</pre>

<p>
In the following we present a <a href="#org255181b">Turing program</a> which does exactly this. Don't worry, most of the
program is just comments - explaining how it works, and at the same time giving a kind of
<i>inline-proof</i> that the program is correct in the sense that it "does what we want".
</p>

<p>
To best understand the inline-proof read the following explanations:
</p>
<ul class="org-ul">
<li>The program consists of set of source <i>blocks</i> - kind of subroutines of the program.</li>
<li>Each block is a sequence of program lines without any intermediate <i>empty lines</i> (line comments
are OK).</li>
<li>Each block has one or more <i>entry</i> lines (marked by a comment <code># entry</code>). If a block is entered we
require that we start at one of these lines - everything else is considered an error (does not
happen if the program as a whole is correct).</li>
<li>Each block has one ore more <i>exit</i> lines (marked by a comment <code># exit</code>). Each block must guarantee
that upon entering another block (or halting) we do this via one of these lines.</li>
<li>Each block has <i>pre-conditions</i>. These are sets of statements that we require to hold immediately
before the first line of the block is executed (each time a block is "called"). If we enter a
block but the pre-conditions do not hold we call this <i>undefined behavior</i>. We require that our
program never runs into undefined behavior.</li>
<li>Each block has <i>post-conditions</i>. These are sets of statements that we require to hold immediately
after we "return" from the block. The block must ensure that these statements hold.</li>
<li>Each block has zero or more <i>successor blocks</i>. Upon exiting the block it is guaranteed that we
must enter one if these successor blocks. This info helps navigating the code, since there are
usually only very few succesor blocks for each block.</li>
</ul>

<pre class="example" id="exercise-3.3-solution-source">
# Turing program to reverse a string of bits (0s and 1s):
#   - input  : "▶a...z■..." where a...z is a string of 0s and 1s
#     followed by at least length-of(a..z)+1 blanks (this is important).
#   - output : "▶z...a■..." where z...a is the reversed string.
# The head starts and finishes at "▶".

# Note: in the following we assume that the input string is non-empty to simplify
# the analysis of the *generic* case. But it is easy to check that this corner case
# also works. This is more or less an accident as you can see by the fact that we rely
# on the fact that (by our definition) a Turing machine halts if no matching line is
# found.

#
##
### Part 1: Map ▶a...z■...■ to ▶□...□z...a
##
#

# In part 1 the tape always contains "▶" followed by a bitstring A, followed
# by a series W of *white* blanks (special markers), followed by a bitstring B.
# Initially B and W are empty and A is the input string. At the end A is empty,
# W is at its place, and B contains the reversed string.

# B1: At the beginning we just step into A
# Pre-Conditions:
#   - tape content is "▶" followed by A, followed by blanks
#   - A is non-empty, W and B are empty
#   - Head is at "▶"
# Post-Conditions:
#   - Head is at the beginning of A
#   - tape content is unchanged (by the action of this block)
# Successor Blocks: B1.
(START,▶,a,▶,+) # entry and exit

# B2: Move the head to the end of A
# Pre-Conditions:
#   - Head is inside A,
#   - A is followed by at least one blank.
# Post-Conditions:
#   - Head is at last bit of A (points at 0 or 1)
#   - tape content is unchanged
# Successor Blocks: B3
(a,0,a,0,+) # entry
(a,1,a,1,+) # entry
(a,■,b,■,-) # exit

# B3: Special case if B still empty: Move the last bit of A one step to the right.
# Pre-Conditions:
#   - Head is at last bit of A
#   - B is empty, A is followed by blanks
# Post-Conditions:
#   - Last bit of A replaced by *white* blank and moved one step to right;
#   - B consists of one bit;
#   - Head is inside W
# Successor Blocks: B4
(b,0,b0,□,+) # entry
(b,1,b1,□,+) # entry
(b0,■,c,0,-) # exit
(b1,■,c,1,-) # exit

# B4: Traverse to the left over a series of white blanks
# Pre-Conditions:
#   - Head is inside W
#   - B is non-empty (but A might be empty)
# Post-Conditions:
#   - Head is at the last bit of A or at "▶" if A is empty
# Successor Blocks: B5, B7
(c,□,c,□,-) # entry and exit

# B5: Move the right-most bit of A to the end of B.
# Pre-Conditions:
#   - A and B are non-empty
#   - Head is at the last bit of A
# Post-Conditions:
#   - Head is inside B
# Successor Blocks: B6
(c,0,c0,□,+) # entry
(c,1,c1,□,+) # entry
# Move over the white blanks and then past the end of B:
(c0,□,c0,□,+)
(c0,0,c0,0,+)
(c0,1,c0,1,+)
(c1,□,c1,□,+)
(c1,0,c1,0,+)
(c1,1,c1,1,+)
# Append the remembered bit to the end of B
(c0,■,d,0,-) # exit
(c1,■,d,1,-) # exit

# B6: Go from B (back) to the white blanks
# Pre-Conditions:
#   - Head is inside B
# Post-Condition:
#   - Head is inside W
# Successor Blocks: B4
(d,0,d,0,-) # entry
(d,1,d,1,-) # entry
(d,□,c,□,-) # exit

#
##
### Part 2: Map ▶□...□z...a to ▶z...a□...□
##
#

# In part 2 the tape always contains "▶" followed by a bitstring C, followed
# by a series W of *white* blanks, followed by a bitstring B.
# Initially C is empty and B is the reversed input string. At the end B is empty,
# W is at its place, and C contains the left-shifted version of B.

# B7: Entrypoint for part 2 of the algorithm. Move into W.
# Pre-Conditions:
#   - Every bit of A was replaced by white blanks - now W
#   - B is reversed version of the initial value of A (and non-empty)
#   - Head is at ▶
# Post-Conditions:
#   - Head is at first white blank - in W
#   - tape content is unchanged
# Successor Blocks: B8
(c,▶,e,▶,+) # entry and exit

# B8: Traverse to the right over a series of white blanks
# Pre-Conditions:
#   - Head is inside W
# Post-Conditions:
#   - Head is at the end of B or at the first blank (after B)
# Successor Blocks: B9, B10
(e,□,e,□,+) # entry and exit

# B9: Erase the first bit of B and append it to C
# Pre-Conditions:
#   - Head is at first bit of B (which is non-empty)
# Post-Conditions:
#   - Bit was replaced by white blank and appended to end of C
#     or put directly after "▶" if C is empty
#   - Head is past the end of C, points to a white blank (inside W)
# Successor Blocks: B8
(e,0,f0,□,-) # entry
(e,1,f1,□,-) # entry
(f0,□,f0,□,-)
(f1,□,f1,□,-)
# Reaching end of C or ▶ if C is empty
(f0,▶,g0,▶,+)
(f0,0,g0,0,+)
(f0,1,g0,1,+)
(f1,▶,g1,▶,+)
(f1,0,g1,0,+)
(f1,1,g1,1,+)
# Append the remembered bit
(g0,□,e,0,+) # exit
(g1,□,e,1,+) # exit

#
##
### Part 3: Map ▶z...a□...□ to ▶z...a
##
#

# This just removes the trailing *white* blanks.

# B10: Remove the trailing white blanks
# Pre-Conditions:
#   - The tape contains the desired result (C) but followed by some white blanks
#   - Head is at the last of the white blanks
# Post-Conditions:
#   - The white blanks are all removed (replaced by blanks)
#   - Head is at "▶"
#   - Turing Machine is in halting state
# Successor Blocks: None (halts upon exit)
(e,■,h,■,-) # entry
(h,□,h,■,-)
(h,0,h,0,-)
(h,1,h,1,-)
(h,▶,HALT,▶,0) # exit
</pre>

<p>
Let the theory behind and plug this program into our python implementation of a (universal)
<code>TuringMachine</code>. The variable <code>source_tp_ex_3_3</code> contains the contents of the <a href="#org255181b">above listing</a>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org2b5e278"><span class="org-variable-name">tm</span> = TuringMachine.fromSource(source_tp_ex_3_3)

<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;011"</span>) == <span class="org-string">"&#9654;110"</span>, <span class="org-string">"test exercise-3.3-1"</span>
<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;101011"</span>) == <span class="org-string">"&#9654;110101"</span>, <span class="org-string">"test exercise-3.3-2"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">If something else is on the tape, then we need at least n+1 blanks</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">(n=length-of-string) after the string. Trying the following with less</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">blanks would fail:</span>
<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;001&#9632;&#9632;&#9632;&#9632;xyz"</span>) == <span class="org-string">"&#9654;100&#9632;&#9632;&#9632;&#9632;xyz"</span>, <span class="org-string">"test exercise-3.3-3"</span>
<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;1"</span>) == <span class="org-string">"&#9654;1"</span>, <span class="org-string">"test exercise-3.3-4"</span>
<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;"</span>) == <span class="org-string">"&#9654;"</span>, <span class="org-string">"test exercise-3.3-4"</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">corner case!</span>

<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
PASSED
</pre>


<p>
These basic tests yield an alternative root of trust into the program. You are invited to try out
<code>tm</code> yourself. If configured appropirately it can also print each step it does.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd5a77e5" class="outline-3">
<h3 id="orgd5a77e5">Exercise 3.4 (Turing machine to add modulo 2)</h3>
<div class="outline-text-3" id="text-orgd5a77e5">
<p>
Describe a Turing machine to add two binary numbers \(x\) and \(y\) modulo 2. The numbers are
input on the Turing machine tape in binary, in the form \(x\), followed by a single blank,
followed by a \(y\). If one number is not as long as the other then you may assume that it
has been padded with leading 0s to make the two numbers the same length.
</p>
</div>

<div id="outline-container-org6a189d9" class="outline-4">
<h4 id="org6a189d9">Solution</h4>
<div class="outline-text-4" id="text-org6a189d9">
<p>
The idea of the <a href="#org9d0f6b2">program</a> can be seen in the following example, adding <code>x=000</code> and <code>y=111</code>.
</p>

<dl class="org-dl">
<dt>1. prepare input</dt><dd><code>▶00■11■■</code> → <code>▶00□11□■</code></dd>
<dt>2. update x inplace</dt><dd><ul class="org-ul">
<li><code>▶00□11□■</code> → <code>▶■0□11□■</code> → <code>▶■0□□1□■</code> → <code>▶10□□1□■</code></li>
<li><code>▶10□□1□■</code> → <code>▶1■□□1□■</code> → <code>▶1■□□□□■</code> → <code>▶11□□□□■</code></li>
</ul></dd>
<dt>3. cleanup and halt</dt><dd><code>▶11□□□□■</code> → <code>▶11■■■■■</code></dd>
</dl>

<p>
In the first stage we replace the blank cell in the gap between \(x\) and \(y\) and the cell
after \(y\) by a white blank. This simplifies the Turing program. In the first step of the
second stage we memorize the first bit of \(x\) (a zero <code>0</code> here) and go to the right until
we find the first bit of \(y\). We add this to our memorized bit of \(x\), replace it by a
white blank and transport back the result to the marked location (the blank). Now we
repeat the procedure with the next bit - and so on. Finally we have to replace the white
blanks by ordinary blanks and move the head back to the beginning.
</p>

<pre class="example" id="turing-program-ex-3-4">
# Turing machine to add modulo 2
#   - input  : "▶xxx■yyy■■..." where xxx and yyy are strings of 0s and 1s of equal length
#     followed by at least 2 blanks. x and y can be empty.
#   - output : "▶zzz■..." where zzz is the bitwise sum of xxx and yyy, followed by at
#     least n+2 blanks, where n is the length of x (and also of y).
# The head starts and finishes at "▶".

# (A)
# Prepare the input by marking the gap between x and y and the cell after y with white
# blanks (□)
(START,▶,prepare-gap,▶,+)
(prepare-gap,0,prepare-gap,0,+)
(prepare-gap,1,prepare-gap,1,+)
(prepare-gap,■,prepare-end,□,+)  # we assume only one gap cell!
(prepare-end,0,prepare-end,0,+)
(prepare-end,1,prepare-end,1,+)
(prepare-end,■,search-start,□,-)  # note: after that, head cell contains no ■
# Successors: (B)

# (B)
# Search the start marker ▶
(search-start,0,search-start,0,-)
(search-start,1,search-start,1,-)
(search-start,□,search-start,□,-)
(search-start,▶,begin-update-next-bit,▶,+)
# Successors: (C), (D)

# (C)
# Memorize next bit of x by a state, and its position by marking it with a
# blank cell.
(begin-update-next-bit,0,memorize-0,■,+)
(begin-update-next-bit,1,memorize-1,■,+)
# Successors: (E), (F)

# (D)
# Final steps:
#   - replace all the □ (we wrote ourselves) by ■
#   - move the head back to ▶,
#   - and halt!
(begin-update-next-bit,□,cleanup,■,+)
(cleanup,□,cleanup,■,+)
(cleanup,■,finalize,■,-)  # here we need that the input is followed by 2 blanks
(finalize,■,finalize,■,-)
(finalize,0,finalize,0,-)
(finalize,1,finalize,1,-)
(finalize,▶,HALT,▶,0)
# Successors: None (halts)

# (E)
# Traverse the rest of x (which might be empty)
(memorize-0,0,memorize-0,0,+)
(memorize-0,1,memorize-0,1,+)
(memorize-1,0,memorize-1,0,+)
(memorize-1,1,memorize-1,1,+)
# Successors: (F)

# (F)
# Traverse the gap between x and y (y is not empty here since initially it had the
# same length as x)
(memorize-0,□,memorize-0y,□,+)
(memorize-1,□,memorize-1y,□,+)
(memorize-0y,□,memorize-0y,□,+)
(memorize-1y,□,memorize-1y,□,+)
# Successors: (G)

# (G)
# Memorize the bitwise sum of the two corresponding bits
(memorize-0y,0,memorize-sum-0,□,-)
(memorize-0y,1,memorize-sum-1,□,-)
(memorize-1y,0,memorize-sum-1,□,-)
(memorize-1y,1,memorize-sum-0,□,-)
# Successors: (H)

# (H)
# Now we know the sum - transport it leftward
(memorize-sum-0,0,memorize-sum-0,0,-)
(memorize-sum-0,1,memorize-sum-0,1,-)
(memorize-sum-0,□,memorize-sum-0,□,-)
(memorize-sum-1,0,memorize-sum-1,0,-)
(memorize-sum-1,1,memorize-sum-1,1,-)
(memorize-sum-1,□,memorize-sum-1,□,-)
# Successors: (I)

# (I)
# Write the result to the marked position in x
(memorize-sum-0,■,begin-update-next-bit,0,+)
(memorize-sum-1,■,begin-update-next-bit,1,+)
# Successors: (C), (D)
</pre>

<p>
We conclude with a small demo:
</p>

<div class="org-src-container">
<pre class="src src-python" id="org1fd92c5"><span class="org-variable-name">tm</span> = TuringMachine.fromSource(source_tp_ex_3_4)

<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;0&#9632;1"</span>) == <span class="org-string">"&#9654;1"</span>
<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;010&#9632;111"</span>) == <span class="org-string">"&#9654;101"</span>
<span class="org-keyword">assert</span> tm.run(<span class="org-string">"&#9654;0111001&#9632;1101011"</span>) == <span class="org-string">"&#9654;1010010"</span>
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
PASSED
</pre>
</div>
</div>
</div>
<div id="outline-container-org11e1c94" class="outline-3">
<h3 id="org11e1c94">Exercise 3.5 (Halting problem with no inputs)</h3>
<div class="outline-text-3" id="text-org11e1c94">
<p>
Show that given a Turing machine \(M\) there is no algorithm to determine whether \(M\) halts
when the input to the machine is a blank tape.
</p>
</div>

<div id="outline-container-org9b48d42" class="outline-4">
<h4 id="org9b48d42">Proof</h4>
<div class="outline-text-4" id="text-org9b48d42">
<p>
This problem can easily be reduced the version of the halting problem from Box 3.2. In
fact, for any turing machine \(M\) (expressed in terms of its program) we consider the
turing machine \(M'\) which first writes the Turing number of \(M\) to the tape and then
proceeds as \(M\).
</p>

<p>
Note that the mapping \(M\mapsto M'\) can be effectively computed (by an algorithm). But we
do not need this fact here - just nice to know.
</p>

<p>
Clearly \(M'\) halts upon the empty tape iff \(M\) halts upon its Turing number being on the
tape. Hence, this variant of the halting problem can not be computed effectively
either. QED.
</p>
</div>
</div>
</div>
<div id="outline-container-org23909f3" class="outline-3">
<h3 id="org23909f3">Exercise 3.6 (Probabilistic halting problem)</h3>
<div class="outline-text-3" id="text-org23909f3">
<p>
Suppose we number the probabilistic Turing machines using a scheme similar to that found
in Exercise 3.2 and define the probabilistic halting function \(h_p(x)\) to be \(1\) if
machine \(x\) halts on input of \(x\) with probability at least \(1/2\) and \(0\) if machine \(x\)
halts on input of \(x\) with probability less than \(1/2\). Show that there is no
probabilistic Turing machine which can output \(h_p(x)\) with probability of correctness
strictly greater than \(1/2\) for all \(x\).
</p>
</div>

<div id="outline-container-orgb615675" class="outline-4">
<h4 id="orgb615675">Proof</h4>
<div class="outline-text-4" id="text-orgb615675">
<p>
The reasoning from Box 3.2 applies here too.
</p>

<p>
Assume that there is a Turing machine <code>HALT</code> which, for all inputs \(x\), halts and returns
\(h_p(x)\) with probability \(p_x>1/2\). This implies that with probability <i>at most</i>
\(1-p_x<1/2\) it returns the wrong result or does not halt.
</p>

<p>
Define <code>TURING</code> in the same way as in Box 3.2 and let \(t\) be its Turing number. If
\(h_p(t)=1\) we have <code>y=HALT(t)</code> with probability \(p_t>1/2\). But the latter means that
<code>TURING(t)</code> loops forever with a probability \(p_t>1/2\) which implies \(h_p(t)=0\) -
contradiction. On the other hand \(h_p(t)=0\) also leads to a contradiction. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org6c76350" class="outline-3">
<h3 id="org6c76350">Exercise 3.7 (Halting oracle)</h3>
<div class="outline-text-3" id="text-org6c76350">
<p>
Suppose a black box is made available to us which takes a non-negative integer \(x\) as
input, and then outputs the value of \(h(x)\), where \(h\) is the halting function defined in
Box 3.2. This type of black box is sometimes known as an <i>oracle</i> for the halting
problem. Suppose we have a regular Turing machine which is augmented by the power to call
the oracle. One way of accomplishing this is to use a two-tape Turing machine, and add an
extra program instruction to the Turing machine which results in the oracle being called,
and the value of \(h(x)\) being printed on the second tape, where \(x\) is the current
contents of the second tape. It is clear that this model for computation is more powerful
than the conventional Turing machine model, since it can be used to compute the halting
function. Is the halting problem for this model of computation undecidable? That is, can a
Turing machine aided by an oracle for the halting problem decide whether a program for the
Turing machine with oracle will halt on a particular input?
</p>
</div>

<div id="outline-container-org45a84a7" class="outline-4">
<h4 id="org45a84a7">Solution</h4>
<div class="outline-text-4" id="text-org45a84a7">
<p>
This follows directly from the argument in Box 3.2. In fact, the argument does not impose
any restrictions on the model of computation except that at least <i>some</i> things are
possible. So the answer is <i>no</i>. There is no such algorithm in this enhanced model of
computation. More generally, any enhancements of the "usual" model of computation (in
terms of added oracles which compute certain previously uncomputable functions) does
suffer from the lack of a halting algorithm (implementable inside the model itself).
</p>

<p>
On the other hand <i>weak</i> models of computation may allow the existence of a halting
algorithm. Particularly simple is the case of a programming language which just has
branching (<code>if ... then ... else ... end</code>) as the only control structure (in particular no
loops). In that case, any algorithm halts and the halting algorithm can be implemented in
a trivial way.
</p>
</div>
</div>
</div>
<div id="outline-container-orgacde60c" class="outline-3">
<h3 id="orgacde60c">Exercise 3.8 (Universality of <code>NAND</code>)</h3>
<div class="outline-text-3" id="text-orgacde60c">
<p>
Show that the <code>NAND</code> gate can be used to simulate the <code>AND</code>, <code>XOR</code>, and <code>NOT</code> gates,
provided wires, ancilla bits and <code>FANOUT</code> are available.
</p>
</div>

<div id="outline-container-org717e02d" class="outline-4">
<h4 id="org717e02d">Proof</h4>
<div class="outline-text-4" id="text-org717e02d">
<p>
Let us denote the <code>NAND</code> operation by \(\barwedge\). Recall that \(x\barwedge y=\neg(x\land
y)\). In the following we give one way to implement each of the three gates:
</p>

<ul class="org-ul">
<li><code>NOT</code>: $&not; x = &not; x &or; 0 = x \barwedge 1 .$</li>
<li><code>AND</code>: $x &and; y = &not; (x \barwedge y) = (x \barwedge y) \barwedge 1 .$</li>
<li><code>OR</code>: $ x &or; y = &not; x \barwedge &not; y = (x \barwedge 1) \barwedge (y \barwedge 1) .$</li>
</ul>

<p>
QED.
</p>
</div>
</div>
</div>
<div id="outline-container-orgdd21c41" class="outline-3">
<h3 id="orgdd21c41"><span class="todo SKIP">SKIP</span> Exercises 3.9-3.14</h3>
<div class="outline-text-3" id="text-orgdd21c41">
<p>
I skip these exercises since they are too simple <i>and</i> too many.
</p>
</div>
</div>
<div id="outline-container-orgbb0d5dc" class="outline-3">
<h3 id="orgbb0d5dc">Exercise 3.15</h3>
<div class="outline-text-3" id="text-orgbb0d5dc">
<p>
Suppose an \(n\) element list is sorted by applying some sequence of compare-and-swap
operations to the list. There are \(n!\) possible initial orderings of the list. Show that
after \(k\) of the compare-and-swap operations have been applied, at most \(2^k\) of the
possible initial orderings will have been sorted into the correct order. Conclude that
\(\Omega(n\log(n))\) compare-and-swap operations are required to sort all possible initial
orderings into the correct order.
</p>
</div>

<div id="outline-container-orgeab2668" class="outline-4">
<h4 id="orgeab2668">Proof</h4>
<div class="outline-text-4" id="text-orgeab2668">
<p>
First, let us note that starting from an orderd sequence of numbers, like \(1,2,\ldots,n\)
applying at most \(k\) compare-and-swap operations we can generate at most \(2^k\)
sequences. From this statement easily follows the first part of the exercise since sorting
is just the reverse of this "shuffling-procedure".
</p>

<p>
In fact, we can see this by mathematical induction:
</p>

<dl class="org-dl">
<dt>case \(k=0\)</dt><dd>Clearly we generate <i>exactly</i> one sequence in that case.</dd>
<dt>induction step \(k+1\leftarrow k\)</dt><dd>Assume the statement holds for \(k\) and consider
\(k+1\). We know that after <i>at most</i> \(k\) steps we get at most \(2^k\) sequences. If we
<i>optionally</i> add another step we can at most double that number!</dd>
</dl>

<p>
This proves the first part. Therefore, to be able to sort all \(n!\) permutations we need at
least a number \(k_n\) of steps which necessarily satisfies
</p>

<p>
\[
  2^{k_n} \geq n! .
\]
</p>

<p>
By a <i>very weak</i> version of <a href="https://en.wikipedia.org/wiki/Stirling%27s_approximation">Stirlings Formula</a> we have
</p>

<p>
\[
  \log(n!) = \Omega(n\log(n)) .
\]
</p>

<p>
By taking the logarithm of the first inequality and plugging in the second inequality we
get \(k_n=\Omega(n\log(n))\). QED.
</p>

<p>
Just for completeness, here is a short proof of the our very weak Stirling-type
inequality:
</p>

<p>
\[
  \log(n!) = \sum_{k=1}^n \log(k) \geq \sum_{k > n/e} \log(k)
  \geq (n-\lfloor ne^{-1} \rfloor)(\log(n) - 1)
  = \Omega(n\log(n)) .
\]
</p>

<p>
Note that \(\log(n!)\leq n\log(n)\) is even easier to see. Hence we actually have proven
that \(\log(n!)=\Omega(n\log(n))\).
</p>
</div>
</div>
</div>
<div id="outline-container-org11a5355" class="outline-3">
<h3 id="org11a5355"><span class="todo TODO">TODO</span> Exercise 3.16 (Hard-to-compute functions exist)</h3>
<div class="outline-text-3" id="text-org11a5355">
<p>
Show that there exist Boolean functions on \(n\) inputs which require at least \(2^n/\log(n)\)
logic gates to compute.
</p>
</div>
</div>

<div id="outline-container-org1d99f6a" class="outline-3">
<h3 id="org1d99f6a">Exercise 3.17</h3>
<div class="outline-text-3" id="text-org1d99f6a">
<p>
Prove that a polynomial-time algorithm for finding the factors of a number \(m\) exists if
and only if the factoring decision problem is in <code>P</code>.
</p>
</div>

<div id="outline-container-orgb112d78" class="outline-4">
<h4 id="orgb112d78">Proof</h4>
<div class="outline-text-4" id="text-orgb112d78">
<p>
It is clear that a polynomial-time algorithm for finding the factors of a number suffices
to solve the decision problem in polynomial time. Thus we only have to proof one direction
of the equivalence.
</p>

<p>
Let \((x,t)\mapsto\mathrm{factp}(x,t)\) be a polynomial time (in the number of bits of \(x\))
algorithm to solve the decision problem. We have to prove that in this case a
polynomial-time algorithm for finding the factors exists.
</p>

<p>
We first give an algorithm to compute the <i>smallest</i> divisor of \(x\). The function takes
<code>factp</code> as a callback. It solves a slightly more general problem to have a cleaner
statement what the function does. See the docstring for the details:
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgde35d11"><span class="org-keyword">def</span> <span class="org-function-name">find_largest_if_not</span>(x: <span class="org-builtin">int</span>, factp: Callable[[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>], <span class="org-builtin">bool</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-doc">"""Find the largest integer 1&lt;=d&lt;=x such that factp(x, l) is false.</span>
<span class="org-doc">    Return 1 if none exists.</span>

<span class="org-doc">    Preconditions:</span>
<span class="org-doc">      - x &gt;= 1</span>
<span class="org-doc">      - factp(x, l) is defined for l=1,...,x</span>
<span class="org-doc">      - If factp(x, l) is true for some l then so is factp(x, l+1)</span>
<span class="org-doc">      - Either factp(x, l) is true of all l&gt;sqrt(x) or it is always false.</span>

<span class="org-doc">    In case of the factor problem factp(x, l) is true if x has a non-trivial divisor strictly</span>
<span class="org-doc">    smaller than l.</span>

<span class="org-doc">    Note: The third precondition is stricter than needed but it is satisfied for the</span>
<span class="org-doc">    factor problem."""</span>
    <span class="org-keyword">if</span> x == 1:  <span class="org-comment-delimiter"># </span><span class="org-comment">corner case</span>
        <span class="org-keyword">return</span> 1

    <span class="org-comment-delimiter"># </span><span class="org-comment">Find the smallest power of two for which factp is true (if it exists)</span>
    <span class="org-variable-name">k</span> = 1
    <span class="org-keyword">while</span> <span class="org-keyword">not</span> factp(x, 2**k):
        <span class="org-variable-name">k</span> = k + 1
        <span class="org-keyword">if</span> 2**k &gt; x:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Here x is prime if factp is decides the Factor problem. In the general case</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">we rely on the third precondition here!</span>
            <span class="org-keyword">return</span> x

    <span class="org-comment-delimiter"># </span><span class="org-comment">Here x is not prime if factp decides the Factor problem.</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">d *will* be the smallest number with the desired property. Right now only the left</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">most bit is correct. The following loop builds up d bit by bit.</span>
    <span class="org-variable-name">d</span> = 2**(k-1)

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(k-2, -1, -1):
        <span class="org-variable-name">d1</span> = d + 2**i
        <span class="org-keyword">if</span> factp(x, d1):
            <span class="org-variable-name">d</span> = d  <span class="org-comment-delimiter"># </span><span class="org-comment">just for explicity</span>
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">d</span> = d1

    <span class="org-keyword">return</span> d
</pre>
</div>

<p>
Let \(n=O(\log(x))\) be the number of bits of \(x\). Let \(f(n)=\Omega(n)\) be a function such
that <code>factp</code> runs in \(O(f(n))\) steps. Note that all <i>basic</i> arithmetic operations, within
the above function are (theoretically) \(O(n)\) since the numbers involved are not larger
then \(2x\) and we only add or multiply by the very peculiar number two which works nice
with binary numbers (we could easily avoid the powers of two but I kept them for
readability).
</p>

<p>
This algorithm calls <code>factp</code> around \(O(n)\) times and hence runs in \(O(nf(n))\)
steps. Clearly the number \(x\) has at most \(\log_2(x)=O(n)\) factors. Hence it suffices to
call this procedure \(O(n)\) times to compute all factors in \(O(n^2f(n))\) steps. QED,
</p>

<p>
Let us do a tiny non-systematic experiment - just having some fun with the above
algorithm.  To generate the primes I used <a href="https://bigprimes.org/">bigprimes.org</a> which claims to generate <i>true</i>
primes with high probability. On the other hand, note that we do not really use the fact
that these numbers are prime (due to our fake implementation of <code>factp</code>):
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgbd3dcc5"><span class="org-comment-delimiter"># </span><span class="org-comment">We assume that the first prime in each tuple is the smallest</span>
<span class="org-variable-name">prime_tuples</span> = [
  (34129,
   63907),
  (7081163707,
   8680787539),
  (6388797743,
   6725672819,
   6388797743),
  (53935348593314365769,
   90916509983980640933),
  (312242331938588645593029053519,
   75189371683335785392960817804971969),
  (85885984977628802697002710823722671231249625512539,
   173202242859416728004553100028078327188834835916135376079867),
  (16454682855571279030686449830860047,
   26432071998531033907383391746862621,
   68404929161253247874640503692598161,
   77570673742199569337801762624138099,
   80645260483118874221181403055241113),
]

<span class="org-keyword">for</span> primes <span class="org-keyword">in</span> prime_tuples:
    <span class="org-variable-name">x</span> = <span class="org-builtin">reduce</span>((<span class="org-keyword">lambda</span> a, b: a*b), primes, 1)
    <span class="org-variable-name">count_calls_to_factp</span> = 0

    <span class="org-keyword">def</span> <span class="org-function-name">factp_fake</span>(x, l):
        <span class="org-keyword">global</span> count_calls_to_factp
        <span class="org-variable-name">count_calls_to_factp</span> += 1
        <span class="org-keyword">return</span> l &gt; primes[0]

    <span class="org-keyword">assert</span> find_largest_if_not(x, factp_fake) == primes[0]
    <span class="org-keyword">print</span>(f<span class="org-string">"Called factp {count_calls_to_factp} times for "</span>\
    f<span class="org-string">"{x.bit_length()} bit number with {len(primes)} prime factors."</span>)
</pre>
</div>

<pre class="example">
Called factp 31 times for 32 bit number with 2 prime factors.
Called factp 65 times for 66 bit number with 2 prime factors.
Called factp 65 times for 98 bit number with 3 prime factors.
Called factp 131 times for 132 bit number with 2 prime factors.
Called factp 195 times for 214 bit number with 2 prime factors.
Called factp 331 times for 363 bit number with 2 prime factors.
Called factp 227 times for 576 bit number with 5 prime factors.
</pre>


<p>
As expected, the number of calls to <code>factp</code> is roughly the number of bits of <code>x</code>. The
worst case is when the number is a product of nearly equal prime numbers (of course, <code>x</code>
being prime is even worse but this case is excluded above). If this is not the case the
required number of calls can be much smaller.
</p>
</div>
</div>
</div>

<div id="outline-container-org7331953" class="outline-3">
<h3 id="org7331953">Exercise 3.18</h3>
<div class="outline-text-3" id="text-org7331953">
<p>
Prove that if <code>coNP</code> is unequal to <code>NP</code> then <code>P</code> is unequal to <code>NP</code>.
</p>
</div>

<div id="outline-container-orgcd3ae3e" class="outline-4">
<h4 id="orgcd3ae3e">Proof</h4>
<div class="outline-text-4" id="text-orgcd3ae3e">
<p>
So we assume that <code>coNP</code> is unequal to <code>NP</code>. There are two possible cases (both can be
true at the same time of course):
</p>

<ol class="org-ol">
<li>There is a language \(L\) in <code>NP</code> which is not in <code>coNP</code>.</li>
<li>There is a language \(L\) in <code>coNP</code> which is not in <code>NP</code>.</li>
</ol>

<p>
Furthermore note that <code>P</code> is part of the interection of <code>NP</code> and <code>coNP</code>. Hence in both
cases \(L\) cannot be in <code>P</code>. Thus in case 1 we immediately get the claim. We are left with
case 2.
</p>

<p>
But case 2 is not hard either. Just consider the language
</p>

<p>
\[ L^c = \{s\in\Sigma^*; s\notin L\} . \]
</p>

<p>
<i>Any</i> Turing machine solving either of the languages - with our without wittness - can be reused
for the other language, you just have to switch the "interpretation" of the two output
states (yes/no). In case a wittness is used the wittness can be reused too.
</p>

<p>
Two things follows from that: If there were a Turing machine solving either language in
polynomial time, it would also solve the other language in polynomial time. Because we are
in case 2, non of these languages is in <code>P</code>. On the other hand \(L^c\) is in <code>NP</code> by the
above argument (Turing machine with wittness). Hence <code>NP</code> contains a language (\(L^c\))
which is not in <code>P</code>. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb3f4fa4" class="outline-3">
<h3 id="orgb3f4fa4">Exercise 3.19</h3>
<div class="outline-text-3" id="text-orgb3f4fa4">
<p>
The <code>REACHABILITY</code> problem is to determine whether there is a path between two specified
vertices in a graph. Show that <code>REACHABILITY</code> can be solved using \(O(n^2)\) operations if the
graph has \(n\) vertices. Use the solution to show that it is possible to decide whether
a graph is connected in \(O(n^3)\) operations.
</p>

<p>
Remark: The exercise statement deviates from the book, see <a href="https://www.michaelnielsen.org/qcqi/errata/errata/errata.html">errata</a>.
</p>
</div>

<div id="outline-container-org87631a3" class="outline-4">
<h4 id="org87631a3">Proof</h4>
<div class="outline-text-4" id="text-org87631a3">
<p>
Let \(m\) be the number of edges of the graph. Note that \(m=O(n^2)\). We show the more
informative bound \(O(m)\) for the first statement and \(O(nm)\) for the second. Note that for
unconnected graphs \(m\) might be much smaller than \(n\). Even \(m=0\) is possible which is a
bit annoying when writing \(O(nm)\), in that case we interpret the latter as \(O(n)\) - sorry
for the abuse of notation!
</p>

<p>
Let us first prove the second part. The connectedness of a graph can be checked as
follows. Take any vertex <code>A</code> and then check if it is connected to any of the other \(n-1\)
vertices. If the answer is always "yes" the graph is connected, otherwise it is not. Since
we called the <code>REACHABILITY</code> subroutine \(n-1\) times this needs \(O(nm)\) operations -
assuming the subroutine, as we have to prove, needs \(O(m)\) operations.
</p>

<p>
Let us turn our attention to <code>REACHABILITY</code> of two vertices <code>A</code> and <code>B</code>.
</p>

<p>
Preliminaries: The algorithm to be described uses two colors, <i>green</i> and <i>red</i>, to color
the edges of the graph. One way to implement such operations without modifying the data
structure holding the graph is to build up a copy of the graph in terms of a modified data
structure where this is possible. This can be done in \(O(\max(n,m))\) operations. It can
even be done in \(O(m)\) steps if the auxiliary data structure is build up on the fly - just
representing the connected region around <code>A</code> as we explore it. For simplicity of
exposition we just assume that the original data structure supports these operations.
</p>

<p>
When we say we <i>toggle</i> the color of an edge we mean that red gets green and green gets
red.
</p>

<p>
Now we are in the position to describe the algorithm. First let us fix the pre- and
post-conditions:
</p>

<ul class="org-ul">
<li>Precondition: The input is a graph with all edges being green.</li>
<li>Post condition: All edges are green (again), more generally the graph is not modified in
any way. It returns the correct answer to the problem.</li>
</ul>

<p>
And here is how the algorithm operates:
</p>

<ul class="org-ul">
<li>(I) Initialize a set <code>pending_nodes</code> with just one element <code>A</code>.</li>
<li>(L) Loop over the following until <code>pending_nodes</code> is empty:
<ul class="org-ul">
<li>(L1) Take a vertex <code>V</code> from <code>pending_nodes</code> and remove it from the set.</li>
<li>(L2) Look at each edge of <code>V</code> and toggle its color.</li>
<li>(L3) Consider all vertices connected to <code>V</code> via red nodes and add them to
<code>pending_nodes</code>. If one of them is <code>B</code> go to (Y).</li>
</ul></li>
<li>(N) Cleanup and return <code>no</code> (and halt).</li>
<li>(Y) Cleanup and return <code>yes</code> (and halt).</li>
</ul>

<p>
With "Cleanup" we mean to make all remaining red edges green again to ensure the first
part of post condition. Of course, if we had a copy of the graph (or of the relevant
connected component) this won't be necessary. Anyway, this can be done in \(O(m)\) steps and
hence it does not hurt much.
</p>

<p>
To prevent a double insertion into <code>pending_nodes</code> in (L3) we can for example add a flag
to each vertex saying whether it is already <i>pending</i> or not. This allows us to implement
<code>pending_nodes</code> as a simple list, with for example, just two operations: <i>push</i> an element
to the end and <i>pop</i> an element from the end. In "ordinary" computers these operations
often run in constant time. Of course, if an implementation of a <i>set</i> is available which
allows <i>checked</i> insertion in constant time we could just use that (maybe a hash-set).
</p>

<p>
We call a vertex <i>visited</i> if it leaves the <i>pending</i> state (gets taken out of
<code>pending_nodes</code>). It is not hard to see by induction over the steps of the algorithm that
a visited vertex never gets pending again and that each edge gets red at most one time.
</p>

<p>
Hence we operate at most \(O(m)\) time on the edges. But we also operate at most \(O(m)\)
times on vertices since we never leave the connected component where <code>A</code> lives. QED
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Note that the term <i>operation</i> is somewhat vague (which is OK!). I
interpreted it as a simple task which can be done on a <i>real</i> computer in <i>essentially</i>
constant time (like random access into memory). I doubt that one can find a Turing
machine (taking the definition of the book) which solves <code>REACHABILITY</code> in \(O(n^2)\)
steps.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org1eb29a3" class="outline-3">
<h3 id="org1eb29a3">Exercise 3.20 (Euler's theorem)</h3>
<div class="outline-text-3" id="text-org1eb29a3">
<p>
Prove Euler's theorem. In particular, if each vertex has an even number of incident edges,
give a constructive procedure for finding an Euler cycle.
</p>
</div>

<div id="outline-container-org9dacc88" class="outline-4">
<h4 id="org9dacc88">Proof</h4>
<div class="outline-text-4" id="text-org9dacc88">
<p>
To see Euler's Theorem consider a graph with \(m\) edges and an Euler cycle. Let us draw
tiny arrows at each edge showing the direction in which we walk. Moreover enumerate the
edges along the path from \(0\) to \(m-1\) along the path - starting at an arbitrary
position. Let us identify the edges with its numbers.
</p>

<p>
Consider one of the vertices \(v\). Let \(i\) be one of the edges whose arrow points towards
\(v\). Clearly \(i+1\) (modulo \(m\)) is an edge at \(v\) whose arrow points away from \(v\). Let
\(j\) be one of the edges whose arrow points away from \(v\). Clearly \(i-1\) (modulo \(m\)) is an
edge at \(v\) whose arrow points towards \(v\). We see that the edges around \(v\) always come
in pairs \((i,i+1)\) where the first one is the "entering" edge and the last one is the
"leaving" edge. Thus, the number of edges at \(v\) must be even. Since \(v\) was arbitrary
this proves the Theorem.
</p>

<p>
Our procedure to compute the Euler cycle makes use of the following subroutine
<code>SimpleCycle</code>. Given a vertex \(v\) and a set of <i>admissible</i> edges the subroutine computes
a nonempty circular path, containing \(v\), visiting each of its vertices exactly once,
containing only admissible edges.
</p>

<ul class="org-ul">
<li>input: a graph,a vertex \(v_s\) of the graph, and a set of admissible edges of the graph.</li>
<li>(I) Set the <i>current vertex</i> equal to \(v_s\) and mark it as <i>visited</i>.</li>
<li>(L) Loop indefinitely over the following
<ul class="org-ul">
<li>(L1) Take an unvisited admissible edge \(e\) to some vertex \(v\).</li>
<li>(L2) Walk over \(e\) to \(v\).</li>
<li>(L3) Set \(v\) to be the new current vertex.</li>
<li>(L4) If \(v\) was already marked <i>visited</i> earlier: return the constructed path and halt.</li>
<li>(L2) Mark \(e\) and \(v\) as visited.</li>
</ul></li>
</ul>

<p>
Note that (L1) implicitly assumes that we actually find an unvisited admissible edge. If
this is always the case it is easy to see that the algorithm does what we want. Also note
that each vertex having an even number of admissible edges and \(v_s\) having at least
<i>some</i> admissible edges guarantees that (L1) always succeeds!
</p>

<p>
Let us formulate the complete procedure for finding an Euler cycle. As a precondition we
assume that each vertex has an even number of edges and that the graph is connected (the
latter implying that no vertex has zero edges). This is justified by Euler's theorem.
</p>

<ul class="org-ul">
<li>Call <code>SimpleCycle</code> on some arbitrarily chosen vertex with all edges being admissible.</li>
<li>Initialize a path \(p\) with the output of the previous step.</li>
<li>Loop indefinitely over the following:
<ul class="org-ul">
<li>Choose a vertex \(v\) having edges not already in \(p\). Halt if none exists.</li>
<li>Call <code>SimpleCycle</code> on \(v\) allowing only the complement of the edges of \(p\) as
admissible. Enlarge \(p\) by inserting the output into \(p\) directly after \(v\).</li>
</ul></li>
</ul>

<p>
It is not hard to see that the procedure halts if and only if the path \(p\) is already an
Euler cycle. QED.
</p>
</div>
</div>
</div>
<div id="outline-container-orge26a447" class="outline-3">
<h3 id="orge26a447">Exercise 3.21 (Transitive property of reduction)</h3>
<div class="outline-text-3" id="text-orge26a447">
<p>
Show that if a language \(L_1\) is reducible to the language \(L_2\) and the language \(L_2\) is
reducible to \(L_3\) then the language \(L_1\) is reducible to the language \(L_3\).
</p>
</div>

<div id="outline-container-org9a0f49f" class="outline-4">
<h4 id="org9a0f49f">Proof</h4>
<div class="outline-text-4" id="text-org9a0f49f">
<p>
By definition there are polynomial-time reduction functions \(R_{12}\) and \(R_{23}\) from
\(L_1\) to \(L_2\) and from \(L_2\) to \(L_3\) respectively.
</p>

<p>
Clearly \(R_{23}\,\circ\,R_{12}\) is a reduction function from \(L_1\) to \(L_3\). It remains to
show that it is polynomial-time.
</p>

<p>
But first let us note that under a few minor assumptions the composition of two Turing
machines can be implemented very naturally. The assumptions are that the input is
presented as a "▶" followed by \(x\) followed by infinitely (or sufficiently) many
blanks. The output is required to be in the same format. At the start and when the machine
halts we require the head to be at the (single) "▶" (which is not to be
modified). Moreover we assume that the set of states of the two Turing machines is
disjoint (if it is not make them disjoint). Under these assumptions the composition of
both Turing machines is obtained by concatenating the two corresponding programs (not
important which one first), defining the start state of the first machine as the common
start state, the halting states of the second machine as the common halting state, adding
program lines which make sure to translate the halting states of the first one into the
start state of the second one (suffices when the head is at "▶").
</p>

<p>
In the following let us identify the reduction functions with concrete Turing machines
implementing them.
</p>

<p>
Let \(t(R,x)\) be the number of steps needed by \(R\) to compute \(R(x)\). Note that
\(|R(x)|\leq|x|+t(R,x)\) since a Turing machine writes at most one symbol to the tape at
each time step. By assumption there is a polynomial \(p(n)=C(1+n^k)\) such that
</p>

<p>
\[
  t(R,x) \leq p(|x|) \text{ for } R\in \{R_{12}, R_{23}\} .
\]
</p>

<p>
Hence
</p>

<p>
\[
  t(R_{23}\,\circ\,R_{12}, x) \leq t(R_{12}, x) + \max_{|y| \leq |x| + p(|x|)} t(R_{23}, y)
  \leq p(|x|) + p(|x| + p(|x|)) .
\]
</p>

<p>
The RHS clearly is a polynomial in the length \(|x|\) of \(x\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org96a7f2d" class="outline-3">
<h3 id="org96a7f2d">Exercise 3.22</h3>
<div class="outline-text-3" id="text-org96a7f2d">
<p>
Suppose \(L\) is complete for a complexity class, and \(L'\) is another language in the
complexity class such that \(L\) reduces to \(L'\). Show that \(L'\) is complete for the
complexity class.
</p>
</div>

<div id="outline-container-org1a4eca0" class="outline-4">
<h4 id="org1a4eca0">Proof</h4>
<div class="outline-text-4" id="text-org1a4eca0">
<p>
We assume that the reduction relation for the class is transitive in the same way as for
natural reduction relation of <code>NP</code> (exercise 3.21). I note this here since not for all
complexity classes the same definition of reduction makes sense. In fact, consider how
useless <a href="https://en.wikipedia.org/wiki/P-complete">P-completenes</a> would be if we used polynomial-time reduction as for <code>NP</code>.
</p>

<p>
Let us now return to the actual exercise. Using transitivity this is almost trivial. In
fact, let \(K\) be any problem in the class then \(K\) reduces to \(L\) by completeness of
\(L\). But \(L\) in turn reduces to \(L'\) by assumption. Using transitivity we deduce that \(K\)
reduces to \(L'\). Since \(K\) was arbitrary we conclude that \(L'\) is complete too. QED.
</p>
</div>
</div>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>
