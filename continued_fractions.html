<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>On Continued Fractions</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">On Continued Fractions</h1>\[
\newcommand{\BB}{\mathbb{B}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\HH}{\mathbb{H}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\jj}{\mathrm{j}}
\newcommand{\kk}{\mathrm{k}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\RF}{\mathrm{RF}}
\newcommand{\sys}{\mathrm{sys}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\cx}{\mathrm{CX}}
\newcommand{\cy}{\mathrm{CY}}
\newcommand{\cz}{\mathrm{CZ}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calR}{\mathcal{R}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % deprecated, use braket instead.
\newcommand{\braket}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\rank}[1]{\mathrm{rank}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\wt}[1]{\mathrm{wt}\left(#1\right)}
\newcommand{\prob}[1]{\mathrm{Prob}\left[#1\right]}
\newcommand{\orac}{\mathrm{Orac}}
\newcommand{\?}{} % sometimes I need just a separator other than whitespace
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9f02e2b">Definition</a></li>
<li><a href="#org0aeb420">Properties</a>
<ul>
<li><a href="#org8a7838a">Uniqueness and Non-uniqueness</a></li>
<li><a href="#monotonicity-section">Monotonicity</a></li>
<li><a href="#org5d4edc4">Recursive Formulas</a></li>
<li><a href="#error-estimate-section">Error Estimates</a></li>
<li><a href="#orga917cb1">Best Approximation Property</a></li>
<li><a href="#6c146ca8-7130-4b91-9e06-983fcbf6143e">Sufficient criterion to be a convergent</a></li>
</ul>
</li>
<li><a href="#orgc611eb2">Some Code!</a></li>
</ul>
</div>
</div>

<p>
This chapter contains my own perspective on continued fractions. When I skimmed over the
Appendix or read <a href="https://en.wikipedia.org/wiki/Continued_fraction">wikipedia</a> I felt that there is something missing I should understand more
deeply. Hence I decided to write down my own thoughts. In particular I think that one
should put a lot of emphasis in the <a href="#org4caf74e">representation formula</a> in every introduction to continued
fractions. A lot of interesting corollaries follow from it. Most importantly an nice <a href="#orgf5c0bbf">error
estimate</a>.
</p>

<div id="outline-container-org9f02e2b" class="outline-2">
<h2 id="org9f02e2b">Definition</h2>
<div class="outline-text-2" id="text-org9f02e2b">
<p>
Consider variables with values in \((0,\infty)\) and let us introduce the following notation
inductively:
</p>

\begin{align*}
  [x] &= x, \\
  [x,y] &= x + \frac{1}{y}, \\
  [x_0,x_1\ldots,x_n] &= [x_0,[x_1,\ldots,x_n]], \\
  [x_0,x_1,\ldots] &= \lim_{n\to\infty} [x_0,x_1\ldots,x_n] .
\end{align*}

<p>
For the last equation we require that the limit exist for the expression to be well-defined. To gain
more flexibility we allow \(x_0\) to be zero. Hence we call the arguments <i>admissible</i> if the first
one is non-negative and the rest is strictly positive.
</p>

<p>
Given a non-negative real number \(x\) we define its <i>continued fraction expansion</i> \([a_0,\ldots]\) by
the following series of term rewrites.
</p>

\begin{align*}
  x &\to [x] \\
  [a_0, a_1,\ldots, a_n, z] &\to \begin{cases}
    [a_0, a_1,\ldots, a_n, \floor{z}, (z - \floor{z})^{-1}] & \text{for } z \text{ not an integer}, \\
    \text{stop rewriting otherwise.} \end{cases}
\end{align*}

<p>
If the procedure ever stops we call it a <i>finite</i> continued fraction. Note that each rewrite
preserves the value of the continued fraction as per the definition of the notation (proof by
mathematical induction).
</p>

<p>
The rational numbers
</p>

<p>
\[
  \frac{p_n}{q_n} = [a_0,\ldots,a_n]
\]
</p>

<p>
are called the <i>convergents</i> of \(x\).
</p>
</div>
</div>

<div id="outline-container-org0aeb420" class="outline-2">
<h2 id="org0aeb420">Properties</h2>
<div class="outline-text-2" id="text-org0aeb420">
</div>
<div id="outline-container-org8a7838a" class="outline-3">
<h3 id="org8a7838a">Uniqueness and Non-uniqueness</h3>
<div class="outline-text-3" id="text-org8a7838a">
<p>
Let \(a_0,\ldots,a_n\) be <i>admissible integers</i> and \(z_{n+1}\geq 1\) a real number. Let
\(a'_0,\ldots,a'_n,z'_{n+1}\) be another bunch of integers with the same characteristics. Assume
</p>

<p>
\[
  [a_0,\ldots,a_n,z_{n+1}] = [a'_0,\ldots,a'_n,z'_{n+1}]
\]
</p>

<p>
Then \(a_i=a'_i\) for all \(i\), and \(z_{n+1}=z'_{n+1}\).
</p>

<p>
PROOF: For \(n=0\) and \(n=1\) this can be seen directly. For \(n>1\) we use mathematical induction and
the formula
</p>

<p>
\[ [x_0,x_1\ldots,x_n] = [x_0,[x_1,\ldots,x_n]] \]
</p>

<p>
from the definition. QED.
</p>

<p>
Note that there is still some degree of Non-uniqueness possible:
</p>

<p>
\[
  [a_0,\ldots,a_n,z_{n+1}] = [a_0,\ldots,a_n,z_{n+1}-1,1] .
\]
</p>

<p>
This basically shows that irrational numbers have a unique infinite bracket-representation, while
positive rationals have exactly two possible <i>finite</i> representations.
</p>
</div>
</div>

<div id="outline-container-monotonicity-section" class="outline-3">
<h3 id="monotonicity-section">Monotonicity</h3>
<div class="outline-text-3" id="text-monotonicity-section">
<p>
Let \(\lambda_n=[x_0,\ldots,x_n]\) for admissible reals \(x_0,\ldots,x_n\). This value strictly increases for
even indices and strictly decreases for odd indices. Moreover all odd values are larger than any
even value.
</p>

<p>
Proof: The statement follows once these formulas are proved for all \(n\):
\(\lambda_{2n+1}>\lambda_{2n-1}\), \(\lambda_{2n}<\lambda_{2n-2}\), and \(\lambda_{2n+1}>\lambda_{2n}\). These can be proved by induction. QED.
</p>

<p>
In particular, series of \(\lambda_n\) has at most two accumulation points. We will soon see
that for our application in continued fractions there is always a limit.
</p>
</div>
</div>

<div id="outline-container-org5d4edc4" class="outline-3">
<h3 id="org5d4edc4">Recursive Formulas</h3>
<div class="outline-text-3" id="text-org5d4edc4">
<p>
Let \(x\geq0\) and \(x=[a_0,a_1,\ldots,a_n,z_{n+1}]\) be its continued fraction expansion with
remainder \(z_{n+1}\) (which is guaranteed to be at least \(1\)). Moreover let
\(p_n/q_n=[a_0,\ldots,a_n]\) be the \(n\)​-th convergent. Then we have:
</p>

<p>
<a id="org4caf74e"></a>
\[
  x = \frac{z_{n+1}p_n + p_{n-1}}{z_{n+1}q_n + q_{n-1}} .
\]
</p>

<p>
and the convergents can be recursively defined by:
</p>

<p>
<a id="orgbac058f"></a>
\[\begin{align*}
  p_{n+1} = a_{n+1}p_n + p_{n-1} , \\
  q_{n+1} = a_{n+1}q_n + q_{n-1} ,
\end{align*}\]
</p>

<p>
With \(p_{-2},p_{-1}=0,1\) and \(q_{-2},q_{-1}=1,0\).
</p>

<p>
PROOF: Just define \(p_n\) and \(q_n\) by the above formula. It is not hard to see by induction that the
formula for \(x\) holds. After that just replace \(z_{n+1}\) by \(a_{n+1}\) to see that the \(p_n\) and
\(q_n\) are the nominator and denominator of the convergents. QED.
</p>

<p>
Corollary:
</p>

<p>
<a id="org3f7b34c"></a>
\[ p_n q_{n-1} - p_{n-1} q_n = (-1)^n . \]
</p>

<p>
Just subtract two consecutive convergents from each other to see this. This directly shows that
\(p_n\) and \(q_n\) have no common divisor.
</p>
</div>
</div>

<div id="outline-container-error-estimate-section" class="outline-3">
<h3 id="error-estimate-section">Error Estimates</h3>
<div class="outline-text-3" id="text-error-estimate-section">
<p>
From the <a href="#org4caf74e">representation formula</a> of \(x\) together with the <a href="#org3f7b34c">coprimness</a> of \(p_n\) and \(q_n\) we see
</p>

<p>
<a id="orgf5c0bbf"></a>
\[
  x - \frac{p_n}{q_n} = \frac{(-1)^{n+1}}{q_n(z_{n+1}q_n+q_{n-1})} .
\]
</p>

<p>
This implies that the convergent's distance strictly decreases on each iteration and that the
convergents indeed converge toward \(x\). Since \(a_{n+1}\,\leq\,z_{n+1}\,\leq\,a_{n+1} + 1\) this also
implies
</p>

<p>
\[
  \frac{1}{q_n(q_{n+1} + q_n)} \leq \abs{x - \frac{p_n}{q_n}} \leq \frac{1}{q_nq_{n+1}} .
\]
</p>

<p>
Remark: <a href="#orgf5c0bbf">The formula</a> on the error explains very clearly why it is said that the golden ratio
\([1,1,1,\ldots]\) is the hardest to approximate irrational number. Small coefficients in the
continued fraction expansion lead to small values for \(q_n\) (by the <a href="#orgbac058f">recursion formula</a>) and hence to
a big error.
</p>
</div>
</div>

<div id="outline-container-orga917cb1" class="outline-3">
<h3 id="orga917cb1">Best Approximation Property</h3>
<div class="outline-text-3" id="text-orga917cb1">
<p>
A rational \(p/q\) is called a <i>best approximation</i> of \(x\) if no other rational with smaller
denominator approximates \(x\) better or equally well.
</p>

<p>
Each convergent of \(x\) is a best approximations (but not necessarily the other way around).
</p>

<p>
PROOF: By the <a href="#org4caf74e">representation formula</a> for \(x\) we see that any real number \(y\) between \(x\) and
\(p_n/q_n\) can be written as:
</p>

<p>
\[
  y = \frac{z p_n + p_{n-1}}{z q_n + q_{n-1}} = [a_0,\ldots,a_n,z] .
\]
</p>

<p>
for some \(z\in(z_{n+1},\infty)\). In particular this implies that each <i>rational</i> between \(x\) and
\(p_n/q_n\) has \(p_n/q_n=[a_0,\ldots,a_n]\) as convergent. So these rationals have a denominator which
is bigger than \(q_n\).
</p>

<p>
What is with the other side of \(x\)? It is actually equally usefull to just show a stronger
statement. In fact, all these rationals on \(p_n/q_n\)​'s side of \(x\) have \([a_0,\ldots,a_n,a]\) for some
\(a>a_{n+1}\) as their convergent. This shows that their denominator is even larger than \(q_{n+1}\)
(use <a href="#orgbac058f">recursive formula</a> for the convergents to see this). This shows that any rational between
\(p_n/q_n\) and \(p_{n+1}/q_{n+1}\) as denominator which is larger than \(q_{n+1}\). QED.
</p>
</div>
</div>

<div id="outline-container-6c146ca8-7130-4b91-9e06-983fcbf6143e" class="outline-3">
<h3 id="6c146ca8-7130-4b91-9e06-983fcbf6143e">Sufficient criterion to be a convergent</h3>
<div class="outline-text-3" id="text-6c146ca8-7130-4b91-9e06-983fcbf6143e">
<p>
Let \(x\) be a positive real number and \(p/q\) a rational with:
</p>

<p>
\[
  \abs{x - \frac{p}{q}} \leq \frac{1}{2q^2}.
\]
</p>

<p>
Then \(p/q\) is a convergent of \(x\).
</p>

<p>
PROOF: Let
</p>

<p>
\[
  \frac{p}{q} = \frac{p_n}{q_n} = [a_0, a_1,\ldots, a_n] .
\]
</p>

<p>
By the <a href="#org8a7838a">non-uniqueness</a> for rationals we may choose whether we want \(n\) to be odd or even. We will use
this freedom soon. By the assumption of the theorem there is a \(z>1\) such that:
</p>

<p>
\[
  x - \frac{p}{q} = \frac{\pm1}{q_n(zq_n + q_{n-1})} .
\]
</p>

<p>
Compare this with the <a href="#orgf5c0bbf">error estimate</a> for convergents to get a motivation for this weird formula. As
said we may choose the parity of \(n\) so that
</p>

<p>
\[ p_{n-1} q_n - p_n q_{n-1} = (-1)^{n+1} \]
</p>

<p>
has the same sign as \(x-p/q\). Hence (just recall how we got the <a href="#orgf5c0bbf">error estimate</a> for the
convergents)
</p>

<p>
\[
  x = \frac{z p_n + p_{n-1}}{z q_n + q_{n-1}} = [a_0,\ldots,a_n,z] ,
\]
</p>

<p>
which shows that \(p/q\) is a convergent of \(x\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc611eb2" class="outline-2">
<h2 id="orgc611eb2">Some Code!</h2>
<div class="outline-text-2" id="text-orgc611eb2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> fractions <span class="org-keyword">import</span> Fraction
<span class="org-keyword">from</span> numbers <span class="org-keyword">import</span> Number, Integral, Rational
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> Any, Literal
<span class="org-keyword">import</span> math
</pre>
</div>

<p>
Let us first define a function to evaluate a given continued fraction expansion:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">OutputFormat</span> <span class="org-operator">=</span> Literal[<span class="org-string">"float"</span>] <span class="org-operator">|</span> Literal[<span class="org-string">"pair"</span>] <span class="org-operator">|</span> Literal[<span class="org-string">"rational"</span>]


<span class="org-keyword">def</span> <span class="org-function-name">eval_cfrac</span>(<span class="org-operator">*</span>coeffs: <span class="org-builtin">list</span>[Number], out_format: OutputFormat <span class="org-operator">=</span> <span class="org-string">"float"</span>, callback<span class="org-operator">=</span><span class="org-keyword">lambda</span> <span class="org-operator">*</span>_: <span class="org-constant">None</span>) <span class="org-operator">-&gt;</span> Any:
    <span class="org-doc">"""Evaluate the continued fraction given by coeffs."""</span>
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(coeffs) <span class="org-operator">!=</span> 0, <span class="org-string">"At least one coefficient is required"</span>

    <span class="org-variable-name">p0</span>, <span class="org-variable-name">p1</span> <span class="org-operator">=</span> 0, 1
    <span class="org-variable-name">q0</span>, <span class="org-variable-name">q1</span> <span class="org-operator">=</span> 1, 0

    <span class="org-keyword">for</span> xi <span class="org-keyword">in</span> coeffs:
        <span class="org-variable-name">p0</span>, <span class="org-variable-name">p1</span> <span class="org-operator">=</span> p1, p1<span class="org-operator">*</span>xi <span class="org-operator">+</span> p0
        <span class="org-variable-name">q0</span>, <span class="org-variable-name">q1</span> <span class="org-operator">=</span> q1, q1<span class="org-operator">*</span>xi <span class="org-operator">+</span> q0

        <span class="org-variable-name">abort_loop</span> <span class="org-operator">=</span> callback(p1, q1, p0, q0)
        <span class="org-keyword">if</span> abort_loop:
            <span class="org-keyword">break</span>

    <span class="org-keyword">if</span> out_format <span class="org-operator">==</span> <span class="org-string">"float"</span>:
        <span class="org-keyword">return</span> p1<span class="org-operator">/</span>q1
    <span class="org-keyword">elif</span> out_format <span class="org-operator">==</span> <span class="org-string">"pair"</span>:
        <span class="org-keyword">return</span> p1, q1
    <span class="org-keyword">elif</span> <span class="org-string">"rational"</span>:
        <span class="org-keyword">return</span> Fraction(p1, q1)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(f<span class="org-string">"Unknown output format '</span>{out_format}<span class="org-string">'"</span>)
</pre>
</div>

<p>
The next function either takes a number as input and computes its continued fraction
expansion up to a given order, or it extends a given expansion in place.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">compute_cfrac</span>(val_or_partial_cfrac: Number <span class="org-operator">|</span> <span class="org-builtin">list</span>[Number], n: Integral, skip_remainder<span class="org-operator">=</span><span class="org-constant">False</span>) <span class="org-operator">-&gt;</span> <span class="org-builtin">list</span>[Number]:
    <span class="org-doc">"""Compute the continued fraction expansion [a_0,...,a_{n-1},z_n] of the first arg.</span>

<span class="org-doc">    If the first arg is already a continued fraction expansion (with the last entry being</span>
<span class="org-doc">    a *real* number) it is modified in place. In any case the result is returned."""</span>
    <span class="org-keyword">if</span> <span class="org-builtin">isinstance</span>(val_or_partial_cfrac, Number):
        <span class="org-keyword">return</span> compute_cfrac([val_or_partial_cfrac], n, skip_remainder<span class="org-operator">=</span>skip_remainder)

    <span class="org-variable-name">pfrac</span> <span class="org-operator">=</span> val_or_partial_cfrac
    <span class="org-variable-name">n</span> <span class="org-operator">+=</span> 1 <span class="org-operator">-</span> <span class="org-builtin">len</span>(pfrac)

    <span class="org-keyword">for</span> _ <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-variable-name">z</span> <span class="org-operator">=</span> pfrac.pop()
        <span class="org-variable-name">a</span> <span class="org-operator">=</span> math.floor(z)
        <span class="org-variable-name">z1</span> <span class="org-operator">=</span> z <span class="org-operator">%</span> 1

        <span class="org-keyword">if</span> z1 <span class="org-operator">==</span> 0:
            pfrac.append(a)
            <span class="org-keyword">break</span>
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">pfrac</span> <span class="org-operator">+=</span> [a, z1<span class="org-operator">**</span>(<span class="org-operator">-</span>1)]

    <span class="org-keyword">return</span> pfrac[:<span class="org-operator">-</span>1] <span class="org-keyword">if</span> (z1 <span class="org-operator">!=</span> 0 <span class="org-keyword">and</span> skip_remainder) <span class="org-keyword">else</span> pfrac
</pre>
</div>

<p>
Let us demonstrate these functions on \(\pi\):
</p>

<div class="org-src-container">
<pre class="src src-python" id="org4af08ed"><span class="org-variable-name">pi10</span> <span class="org-operator">=</span> compute_cfrac(math.pi, 10)
<span class="org-builtin">print</span>(f<span class="org-string">"&#960; = </span>{pi10}<span class="org-string">"</span>)

<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">Convergents of &#960;:"</span>)
eval_cfrac(<span class="org-operator">*</span>pi10[:<span class="org-operator">-</span>1], callback<span class="org-operator">=</span><span class="org-keyword">lambda</span> p, q, <span class="org-operator">*</span>_: \
           <span class="org-builtin">print</span>(f<span class="org-string">"</span>{<span class="org-builtin">str</span>(Fraction(p,q)):20}<span class="org-string"> | error = </span>{<span class="org-builtin">abs</span>(math.pi <span class="org-operator">-</span> p<span class="org-operator">/</span>q):.3E}<span class="org-string">"</span>))
</pre>
</div>

<pre class="example" id="org515c030">
π = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3.93464231529632]

Convergents of π:
3                    | error = 1.416E-01
22/7                 | error = 1.264E-03
333/106              | error = 8.322E-05
355/113              | error = 2.668E-07
103993/33102         | error = 5.779E-10
104348/33215         | error = 3.316E-10
208341/66317         | error = 1.224E-10
312689/99532         | error = 2.914E-11
833719/265381        | error = 8.715E-12
1146408/364913       | error = 1.611E-12
</pre>

<p>
We can nicely see that at first the error decreases rapidly, but then it slows down. The
slow-down is consistent with the expansion starting with primarily large values followed by
several small values. Also note that during the slow period the denominator increases only
marginally.
</p>

<p>
Let us give a <b>warning</b>: The above implementation of <code>compute_cfrac</code> is not very reliable
<i>for certain inputs</i>. Unfortunately for "typical" <i>rational</i> numbers it fails badly <i>if
they are represented as floats</i>. See:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Expected result: [0, 1, 2, 1, 7, 3, 1]</span>
compute_cfrac(0b1011_1110 <span class="org-operator">/</span> 2<span class="org-operator">**</span>8, 10)
</pre>
</div>

<pre class="example">
[0, 1, 2, 1, 7, 3, 1, 7036874417766, 2, 2, 102.00000000000036]
</pre>


<p>
We immediately see that the <code>7036874417766</code> looks a bit odd (following the little <code>1</code>). We
also see that the error accumulates quickly since <code>math.log2(7036874417766)==42.678...</code>
(which is well below \(52\), the number of mantissa bits for double precision). So while
this allows us to interactively determine the continued fraction of a binary such as
<code>0.10111110</code> it makes automation very hard.
</p>

<p>
Before we solve our dilemma let us briefly mention that there is already something built
into python which behaves better:
</p>

<div class="org-src-container">
<pre class="src src-python">Fraction(0b1011_1110 <span class="org-operator">/</span> 2<span class="org-operator">**</span>8)
</pre>
</div>

<pre class="example">
95/128
</pre>


<p>
Also it has a nice feature to limit the denominator:
</p>

<div class="org-src-container">
<pre class="src src-python">Fraction(0b1011_1110 <span class="org-operator">/</span> 2<span class="org-operator">**</span>8).limit_denominator(100)
</pre>
</div>

<pre class="example">
72/97
</pre>


<p>
How do we solve our problem? Fortunately in case of order finding we already know the
exact <i>rational</i> representation of our input \(\varphi\) (recall that it is given in terms
of a finite binary expansion and hence rational!). Hence we can completely avoid floating
point issues by using a <i>rational numerical type</i>:
</p>

<div class="org-src-container">
<pre class="src src-python">compute_cfrac(Fraction(0b1011_1110, 2<span class="org-operator">**</span>8), 10)
</pre>
</div>

<pre class="example">
[0, 1, 2, 1, 7, 4]
</pre>


<p>
This also works for rationals which are not exactly representable by 64bit floats.
</p>

<p>
Remark: Whenever we have a <i>float</i> we could always read out its bit representation which
directly yields a rational representation! That is not important for order finding but it
is good to be aware of the fact that it is <i>pointless</i> (in a sense) to apply <code>compute_cfrac</code>
to a <code>float</code>.
</p>

<p>
Finally let us define a function which will be helpful in order finding:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">get_convergent</span>(value: Rational, limit_denominator: Integral) <span class="org-operator">-&gt;</span> Fraction:
    <span class="org-doc">"""Compute the last convergent of 'value' whose denominator is smaller than 'limit_denominator'."""</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Second arg is just something large enough for what we want:</span>
    <span class="org-variable-name">cfrac</span> <span class="org-operator">=</span> compute_cfrac(value, limit_denominator)
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">callback</span>(p, q, <span class="org-operator">*</span>args):
        <span class="org-keyword">nonlocal</span> result
        <span class="org-keyword">if</span> q <span class="org-operator">&lt;=</span> limit_denominator:
            <span class="org-variable-name">result</span> <span class="org-operator">=</span> Fraction(p, q)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> <span class="org-constant">True</span>  <span class="org-comment-delimiter"># </span><span class="org-comment">no need to further run evalutation</span>

    eval_cfrac(<span class="org-operator">*</span>cfrac, callback<span class="org-operator">=</span>callback)

    <span class="org-keyword">return</span> result
</pre>
</div>

<p>
We note here that <code class="src src-python">get_convergent(value, limit)</code> is not the same as
<code class="src src-python">Fraction(value).limit_denominator(limit)</code>. In fact, not every best
approximation is a convergent. Let us demonstrate this with \(\pi\) (again):
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">l</span> <span class="org-operator">=</span> []
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1,355):
    <span class="org-variable-name">frac</span> <span class="org-operator">=</span> Fraction(math.pi).limit_denominator(i)
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> l <span class="org-keyword">or</span> frac <span class="org-operator">!=</span> l[<span class="org-operator">-</span>1]:
        l.append(frac)

<span class="org-string">", "</span>.join([<span class="org-builtin">str</span>(f) <span class="org-keyword">for</span> f <span class="org-keyword">in</span> l])
</pre>
</div>

<pre class="example">
3, 13/4, 16/5, 19/6, 22/7, 179/57, 201/64, 223/71, 245/78, 267/85, 289/92, 311/99, 333/106, 355/113
</pre>


<p>
For example the fractions <code>13/4, 16/5, 19/6</code> are not convergents of \(\pi\).
</p>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1.90 (<a href="https://orgmode.org">Org</a> mode 9.6.11)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>
