<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 7</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 7</h1>\[
\newcommand{\CC}{\mathbb{C}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\orac}{\mathrm{Orac}}
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org11a0a4f">Setup</a>
<ul>
<li><a href="#orgf139648">Imports</a></li>
<li><a href="#org1947f88">Harmonic Oscillator</a></li>
<li><a href="#orgb0c486a">Optical photon quantum computers</a></li>
</ul>
</li>
<li><a href="#orgde855d1">Exercises</a>
<ul>
<li><a href="#orga1e2d92">Exercise 7.1</a></li>
<li><a href="#exercise-7.2">Exercise 7.2</a></li>
<li><a href="#org94dc4cd">Exercise 7.3</a></li>
<li><a href="#orgbc9b1ad">Exercise 7.4</a></li>
<li><a href="#orgade62a2">Exercise 7.5</a></li>
<li><a href="#orgacd7c76">Exercise 7.6 (Eigenstates of photon annihilation)</a></li>
<li><a href="#org215902e">Exercise 7.7</a></li>
<li><a href="#org23503f2">Exercise 7.8</a></li>
<li><a href="#org48e22dd">Exercise 7.9 (Optical Hadamard gate)</a></li>
<li><a href="#org2f0cf1c">Exercise 7.10 (Mach–Zehnder interferometer)</a></li>
<li><a href="#orgd766695">Exercise 7.11</a></li>
<li><a href="#exercise-7.12">Exercise 7.12 (Quantum beamsplitter with classical inputs)</a></li>
<li><a href="#org68dfcfe">Exercise 7.13 (Optical Deutsch–Jozsa quantum circuit)</a></li>
<li><a href="#orgc3fee64">Exercise 7.14 (Classical cross phase modulation)</a></li>
<li><a href="#org2be884a">Exercise 7.15</a></li>
<li><a href="#org90aab4a">Exercise 7.16 (Electric dipole selection rules)</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org11a0a4f" class="outline-2">
<h2 id="org11a0a4f">Setup</h2>
<div class="outline-text-2" id="text-org11a0a4f">
</div>
<div id="outline-container-orgf139648" class="outline-3">
<h3 id="orgf139648">Imports</h3>
<div class="outline-text-3" id="text-orgf139648">
<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">from</span> utils <span class="org-keyword">import</span> commutator <span class="org-keyword">as</span> com
<span class="org-keyword">from</span> utils_sage <span class="org-keyword">import</span> Z, H, Ry, Rz
</pre>
</div>
</div>
</div>

<div id="outline-container-org1947f88" class="outline-3">
<h3 id="org1947f88">Harmonic Oscillator</h3>
<div class="outline-text-3" id="text-org1947f88">
<p>
To simplify calculations we will use unit-less expressions. To do this let \(\tilde{x}\),
\(\tilde{p}\), etc denote physical quantities <i>with</i> units and denote the unit-less versions
without the tilde, such that e.g.
</p>

<p>
<a id="org5ae55a8"></a>
\[
  \tilde{x} = \sqrt{\frac{\hbar}{m\omega}} \; x, \quad \tilde{p} = \sqrt{m\omega\hbar} \; p .
\]
</p>

<p>
Note that this implies \(p=-\ii\partial_x\). The effect on \(H\) and \(a\) is the same as
setting \(m=\hbar=\omega=1\) (we have e.g. \(H=p^2/2+x^2/2\)).
</p>

<p>
In this chapter let us use the python based computer algebra system <a href="https://www.sagemath.org/">sage</a> to solve the
exercises (some of them). For this reason we define momentum and position operator in code
as follows:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgc910f79">R.<span class="org-operator">&lt;</span>x<span class="org-operator">&gt;</span> <span class="org-operator">=</span> QQbar[]
<span class="org-variable-name">W</span> <span class="org-operator">=</span> DifferentialWeylAlgebra(R)
(<span class="org-variable-name">x</span>, <span class="org-variable-name">dx</span>) <span class="org-operator">=</span> W.gens()
<span class="org-variable-name">p</span> <span class="org-operator">=</span> <span class="org-operator">-</span>i<span class="org-operator">*</span>dx
</pre>
</div>

<p>
Having this we can define the Hamiltonian \(H\) of the one-dimensional harmonic oscillator
and the corresponding annihilation (\(a\)), and creation operator (\(a^\dagger\)):
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org800831c"><span class="org-variable-name">H_qho</span> <span class="org-operator">=</span> p<span class="org-operator">^</span>2 <span class="org-operator">/</span> 2 <span class="org-operator">+</span> x<span class="org-operator">^</span>2 <span class="org-operator">/</span> 2

<span class="org-variable-name">a</span> <span class="org-operator">=</span> (x <span class="org-operator">+</span> i<span class="org-operator">*</span>p) <span class="org-operator">/</span> sqrt(2)
<span class="org-variable-name">ad</span> <span class="org-operator">=</span> (x <span class="org-operator">-</span> i<span class="org-operator">*</span>p) <span class="org-operator">/</span> sqrt(2)
</pre>
</div>

<p>
Some basic sanity checks:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org3cbaab3"><span class="org-keyword">assert</span> com(x, p) <span class="org-operator">==</span> i
<span class="org-keyword">assert</span> com(a, ad) <span class="org-operator">==</span> 1
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Note that from <a href="#org5ae55a8">above</a> we get
</p>

<p>
<a id="org564cd23"></a>
\[
  \tilde{H} = \hbar\omega H, \quad \tilde{a} = a .
\]
</p>

<p>
For convenience let us also define the number operator \(N=a^\dagger a = H-1/2\). Clearly
the number operator has the same eigenstates as \(H\). The corresponding eigenvalues are
shifted by \(1/2\).
</p>

<p>
<a id="org2946675"></a>
</p>
<dl class="org-dl">
<dt>Theorem (Spectrum of 1D Harmonic Oscillator)</dt><dd><p>
Let
</p>

<p>
\[ \ket{0} = \frac{1}{\sqrt{2\pi}} e^{-x^2 / 2} , \]
</p>

<p>
and
</p>

<p>
\[ \ket{n} = \frac{(a^\dagger)^n}{\sqrt{n!}} \ket{0} , \]
</p>

<p>
for \(n\in\{1,2,\ldots\}\). These states form a complete orthonormal set of the Hilbert
space \(L^2 (\RR)\) of square integrable functions. Moreover they are eigenstates of \(H\)
and \(N\) with \(N\ket{n}=n\ket{n}\).
</p>
<dl class="org-dl">
<dt>Remark</dt><dd><a id="orgbdf4a27"></a> It is well known that the gaussian function which
defines \(\ket{0}\) is already normalized (see <a href="https://en.wikipedia.org/wiki/Gaussian_integral">gaussian integral</a>).</dd>
<dt>Proof</dt><dd>See <a href="#exercise-7.4-proof">solution of exercise 7.4</a>.</dd>
</dl></dd>
</dl>
</div>
</div>

<div id="outline-container-orgb0c486a" class="outline-3">
<h3 id="orgb0c486a">Optical photon quantum computers</h3>
<div class="outline-text-3" id="text-orgb0c486a">
<p>
The book showed that the beamsplitter \(B=e^{\theta(ab^\dagger-a^\dagger b)}\) acts as
follows on the dual-rail representation
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org2817ba8"><span class="org-variable-name">theta</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'theta'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
<span class="org-variable-name">B</span> <span class="org-operator">=</span> matrix([[cos(theta), <span class="org-operator">-</span>sin(theta)], [sin(theta), cos(theta)]])
</pre>
</div>

<p>
This essentially follows from these commutation relations:
</p>

<p>
<a id="org0b98c8c"></a>
\[
  BaB^\dagger = a \cos(\theta) + b \sin(\theta)
  \quad \text{and} \quad
  BbB^\dagger = b \cos(\theta) - a \sin(\theta) .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-orgde855d1" class="outline-2">
<h2 id="orgde855d1">Exercises</h2>
<div class="outline-text-2" id="text-orgde855d1">
</div>
<div id="outline-container-orga1e2d92" class="outline-3">
<h3 id="orga1e2d92">Exercise 7.1</h3>
<div class="outline-text-3" id="text-orga1e2d92">
<p>
Using the fact that \(x\) and \(p\) do not commute, and that in fact \([x,p]=\ii\,\hbar\),
explicitly show that \(a^\dagger\,a=H/\hbar\omega-1/2\).
</p>
</div>

<div id="outline-container-orga133c88" class="outline-4">
<h4 id="orga133c88">Solution</h4>
<div class="outline-text-4" id="text-orga133c88">
<p>
This is just boring algebra which can be done much faster (and more reliably) by <i>sage</i>:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org59b7afa"><span class="org-keyword">assert</span> ad <span class="org-operator">*</span> a <span class="org-operator">==</span> H_qho <span class="org-operator">-</span> 1<span class="org-operator">/</span>2
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>
</div>

<div id="outline-container-exercise-7.2" class="outline-3">
<h3 id="exercise-7.2">Exercise 7.2</h3>
<div class="outline-text-3" id="text-exercise-7.2">
<p>
Given that \([x,p]=\ii\,\hbar\), compute \([a,a^\dagger]\).
</p>
</div>

<div id="outline-container-org8494e8e" class="outline-4">
<h4 id="org8494e8e">Solution</h4>
<div class="outline-text-4" id="text-org8494e8e">
<p>
The unitless result is \(1\):
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org822d48a">com(a, ad)
</pre>
</div>

<pre class="example">
1
</pre>


<p>
Since the <a href="#org564cd23">creator/annihilator is already unit-less</a> the same is true with units.
</p>
</div>
</div>
</div>

<div id="outline-container-org94dc4cd" class="outline-3">
<h3 id="org94dc4cd">Exercise 7.3</h3>
<div class="outline-text-3" id="text-org94dc4cd">
<p>
Compute \([H,a]\) and use the result to show that if \(\ket{\psi}\) is an eigenstate of \(H\)
with energy \(E\geq n\hbar\omega\), then \(a^n\ket{\psi}\) is an eigenstate with energy
\(E-n\hbar\omega\).
</p>
</div>

<div id="outline-container-orgb818b75" class="outline-4">
<h4 id="orgb818b75">Solution</h4>
<div class="outline-text-4" id="text-orgb818b75">
<p>
Using \([a^\dagger,a]=-[a,a^\dagger]=-1\) (see <a href="#exercise-7.2">exercise 7.2</a>) we deduce (assuming unit-less quantities)
</p>

<p>
\[
  [H,a] = [a^\dagger a, a] = (a^\dagger a - a a^\dagger) a = [a^\dagger,a] a = -a .
\]
</p>

<p>
Using this we get
</p>

\begin{align*}
  H a^n \ket{\psi} &= (Ha) a^{n-1} \ket{\psi} \\
  &= ([H,a] + aH)a^{n-1} \ket{\psi} \\
  &= (-a^n + a H a^{n-1}) \ket{\psi} \\
  &= a H a^{n-1} \ket{\psi} - a^n \ket{\psi} .
\end{align*}

<p>
Recall that we want to show that \(Ha^n\ket{\psi}=(E-n)a^n\ket{\psi}\) for all natural
numbers \(n\leq E\). Using the above calculation we can prove this by induction. In fact,
for \(n=0\) the assertion is trivial. For \(n>0\) we may use the above calculation together
with the assertion for \(n-1\):
</p>

<p>
\[
  H a^n \ket{\psi} = a(E-n+1)a^{n-1}\ket{\psi} - a^n \ket{\psi} = (E-n)a^n\ket{\psi} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbc9b1ad" class="outline-3">
<h3 id="orgbc9b1ad">Exercise 7.4</h3>
<div class="outline-text-3" id="text-orgbc9b1ad">
<p>
Show that \(\ket{n}=\frac{(a^\dagger)^n}{\sqrt{n!}}\ket{0}\).
</p>
</div>

<div id="outline-container-exercise-7.4-proof" class="outline-4">
<h4 id="exercise-7.4-proof">Proof</h4>
<div class="outline-text-4" id="text-exercise-7.4-proof">
<p>
The exercise statement is rather "vague" (I try to be friendly here 😉), so let us prove
some definite statement like the <a href="#org2946675">theorem about the spectrum of the harmonic oscillator</a>
instead.
</p>

<p>
To find the <i>ground state</i> consider
</p>

<p>
\[
  \bra{\phi} N \ket{\phi} = \norm{a\phi}^2 \geq 0 .
\]
</p>

<p>
Equality holds iff
</p>

<p>
\[
  x \phi(x) + \phi'(x) = \sqrt{2} \cdot (a\phi)(x) = 0 .
\]
</p>

<p>
This is a linear ordinary differential equation. One solution is given by
\(x\mapsto\exp(-x^2/2)\), which can be easily checked by plugging this in. We do not need
this fact (since it follows automatically later on) but the solution is unique up to a
scalar factor, which can be seen by observing that the ODE is equivalent to
\(\partial_x\log(\phi(x))=-x\).
</p>

<p>
The factor \(1/\sqrt{2\pi}\) in the definition of \(\ket{0}\) <a href="#orgbdf4a27">ensures normalization</a>. We thus
proved \(N\ket{0}=0\). Next let us verify that \(\ket{n}\) is an eigenvector. To simplify the
notation let us define \(\ket{n'}:=\sqrt{n!}\ket{n}\).
</p>

<p>
\[
  N\ket{n'} = a^\dagger a (a^\dagger)^n \ket{0} .
\]
</p>

<p>
By using \([a,a^\dagger]=1\) (<a href="#exercise-7.2">exercise 7.2</a>) we may move the single \(a\) to the right and then
use \(a\ket{0}=0\) (this procedure is just simple example of mathematical induction). This
leads to
</p>

<p>
\[
  N\ket{n'} = n (a^\dagger)^n \ket{0} = n \ket{n'} ,
\]
</p>

<p>
hence establishing that \(\ket{n'}\) (and \(\ket{n}\)) is an eigenvector for the eigenvalue
\(n\). To see that the \(1/\sqrt{n!}\) in the definition of \(\ket{n}\) is indeed the right
normalization factor use the freshly proved equality \(N\ket{n'}=n\ket{n'}\) and consider
(don't forget \([a,a^\dagger]=1\))
</p>

<p>
\[
  \norm{(n+1)'}^2 = \bra{n'} a a^\dagger \ket{n'}
  = \bra{n'} N + 1 \ket{n'}
  = (n+1) \norm{n'}^2 .
\]
</p>

<p>
Hence, since \(\ket{0}\) is already normalized mathematical induction shows that \(\ket{n}\)
is normalized too.
</p>

<p>
It remains to show that the \((\ket{n})\) generate the whole Hilbert space (completeness),
since orthogonality already follows from the fact that they are eigenstates to <i>different</i>
eigenvalues of some (unbounded) self-adjoint operator. This essentially boils down to show
that finite linear combinations of the eigenstates are dense in \(L^2(\RR)\).
</p>

<p>
We only sketch the proof since this reaches out to other parts of mathematics. First of
all observe that
</p>

<p>
\[
  \ket{n}(x) = \frac{1}{\sqrt{2\pi}} \; p_n(x) \; e^{-x^2/2} ,
\]
</p>

<p>
where the \(p_n(x)\) are polynomials which satisfy the recursive relation
</p>

<p>
\[ p_{n+1}(x)=(2x+\partial_x)p_n(x), \quad p_0(x) = 1 . \]
</p>

<p>
These are the well-known <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">hermite polynomials</a>. From the recursive relation we directly see
(inductively) the <i>for our purpose important</i> property that \(p_n\) has degree \(n\) (with
leading factor \(2^n\)). The density now follows from the following well known results
</p>

<ol class="org-ol">
<li><a id="orgb89bb89"></a> The compactly supported continuous functions are dense in
\(L^2(\RR)\). I do not have a good resource on that but one way to see this is by a
method called <i><a href="https://en.wikipedia.org/wiki/Mollifier">mollification</a></i>.</li>
<li><a id="org53dc10f"></a> For any finite interval \(I\) the polynomials on that
interval are dense in the continuous function on \(I\) with respect to the
$L^&infin;$-norm which is stronger than the \(L^2\) norm (since the interval is
finite). This is the <a href="https://en.wikipedia.org/wiki/Stone%E2%80%93Weierstrass_theorem">Stone-Weierstrass Theorem</a>.</li>
</ol>

<p>
By <a href="#org53dc10f">2</a> finite linear combinations of eigenstates can approximate any
compactly supported continuous function. Here it is important that any degree is
represented among the eigenstates. It should be obvious that the factor \(e^{-x^2/2}\) does
not disturb this argument at all. Now completeness directly follows from
<a href="#orgb89bb89">1</a>. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgade62a2" class="outline-3">
<h3 id="orgade62a2">Exercise 7.5</h3>
<div class="outline-text-3" id="text-orgade62a2">
<p>
Verify that Equations (7.11) and (7.12) are consistent with (7.10) and the normalization
condition \(\norm{\ket{n}}^2=1\).
</p>
</div>

<div id="outline-container-org5a1ac83" class="outline-4">
<h4 id="org5a1ac83">Solution</h4>
<div class="outline-text-4" id="text-org5a1ac83">
<p>
It is not hard to see that (7.11) and (7.12) imply (7.10):
</p>

<p>
\[
  a^\dagger a \ket{n} = a^\dagger \sqrt{n} \ket{n-1} = n \ket{n} .
\]
</p>

<p>
The normalization condition is not relevant here. So it is indeed true that it is
consistent with the three equations but for trivial reasons.
</p>
</div>
</div>
</div>

<div id="outline-container-orgacd7c76" class="outline-3">
<h3 id="orgacd7c76">Exercise 7.6 (Eigenstates of photon annihilation)</h3>
<div class="outline-text-3" id="text-orgacd7c76">
<p>
Prove that a coherent state is an eigenstate of the photon annihilation operator, that is,
show \(a\ket{\alpha}=\lambda\ket{\alpha}\) for some constant \(\lambda\).
</p>
</div>

<div id="outline-container-org156291d" class="outline-4">
<h4 id="org156291d">Proof</h4>
<div class="outline-text-4" id="text-org156291d">
<p>
Recall that \(a\ket{n}=\sqrt{n}\ket{n-1}\) for \(n\geq1\) and \(a\ket{0}=0\). Hence
</p>

<p>
\[
  a\ket{\alpha} = e^{-\abs{\alpha}/2} \sum_n \frac{\alpha^n}{\sqrt{n}} \, a \, \ket{n}
  = e^{-\abs{\alpha}/2} \sum_n \frac{\alpha^{n+1}}{\sqrt{n}} \ket{n}
  = \alpha \ket{\alpha} .
\]
</p>

<p>
The claim follows with \(\lambda=\alpha\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org215902e" class="outline-3">
<h3 id="org215902e">Exercise 7.7</h3>
<div class="outline-text-3" id="text-org215902e">
<p>
Show that the circuit below transforms a dual-rail state by
</p>

<p>
\[
  \ket{\psi_{\mathrm{out}}} = \begin{bmatrix} e^{\ii\pi} & 0 \\ 0 & 1 \end{bmatrix} \ket{\psi_{\mathrm{in}}} .
\]
</p>

<p>
if we take the top wire to represent the \(\ket{01}\) mode, and \(\ket{10}\) the bottom mode,
and the boxed \(\pi\) to represent a phase shift by \(\pi\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The book contains a picture showing the circuit.</dd>
</dl>
</div>

<div id="outline-container-org4bc5e3d" class="outline-4">
<h4 id="org4bc5e3d">Solution</h4>
<div class="outline-text-4" id="text-org4bc5e3d">
<p>
By definition the circuit acts like this (we use \(e^{\ii\pi}=-1\) to simplify notation):
</p>

<p>
\[
  \ket{0_L} = \ket{01} \mapsto -\ket{0_L}, \quad
  \ket{1_L} = \ket{10} \mapsto \ket{1_L}.
\]
</p>

<p>
The matrix representing this linear transformation with respect to the basis
\((\ket{0_L},\ket{1_L})\) (the order is important) is
</p>

\begin{bmatrix} -1 & 0 \\ 0 & 1 \end{bmatrix}

<p>
as desired.
</p>
</div>
</div>
</div>

<div id="outline-container-org23503f2" class="outline-3">
<h3 id="org23503f2">Exercise 7.8</h3>
<div class="outline-text-3" id="text-org23503f2">
<p>
Show that \(P\ket{\alpha}=\ket{\alpha e^{\ii\Delta}}\) where \(\ket{\alpha}\) is a coherent
state (note that, in general, \(\alpha\) is a complex number!).
</p>
</div>

<div id="outline-container-org7471ac9" class="outline-4">
<h4 id="org7471ac9">Proof</h4>
<div class="outline-text-4" id="text-org7471ac9">
<p>
The phase shift operator is given by \(P\ket{n}=e^{\ii n\Delta}\ket{n}\). Hence, using \(\abs{e^{\ii\Delta}}=1\)
</p>

<p>
\[
P\ket{\alpha} = e^{-\abs{\alpha}^2/2} \sum_n \frac{\alpha^n \, e^{\ii n\Delta}}{\sqrt{n!}} \ket{n}
= \ket{\alpha e^{\ii\Delta}} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org48e22dd" class="outline-3">
<h3 id="org48e22dd">Exercise 7.9 (Optical Hadamard gate)</h3>
<div class="outline-text-3" id="text-org48e22dd">
<p>
Show that the following circuit acts as a Hadamard gate on dual-rail single photon states,
that is, \(\ket{01}\mapsto(\ket{01}+\ket{10})/\sqrt{2}\) and
\(\ket{10}\mapsto(\ket{01}-\ket{10})/\sqrt{2}\) up to an overall phase.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The book contains a picture showing the circuit.</dd>
</dl>
</div>

<div id="outline-container-org958e80d" class="outline-4">
<h4 id="org958e80d">Solution</h4>
<div class="outline-text-4" id="text-org958e80d">
<p>
Assuming evolution from left to right the circuit implements \(ZB_{\theta=\pi/4}\) (note
that the phase shift is \(Z\) up to a global phase). Below you can see that then the
assertion of the exercise is wrong. We give two alternatives instead.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">B0</span> <span class="org-operator">=</span> B.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>4)
<span class="org-variable-name">B1</span> <span class="org-operator">=</span> B.subs(theta<span class="org-operator">=-</span>pi<span class="org-operator">/</span>4)

<span class="org-comment-delimiter"># </span><span class="org-comment">This shows that the original circuit does not implement H, not even if we neglect a</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">global phase</span>
f<span class="org-string">"sqrt(2)*H != </span>{sqrt(2) <span class="org-operator">*</span> Z <span class="org-operator">*</span> B0}<span class="org-string">"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">These alternatives implement the Hadamard gate:</span>
<span class="org-keyword">assert</span> B0 <span class="org-operator">*</span> Z <span class="org-operator">==</span> H
<span class="org-keyword">assert</span> Z <span class="org-operator">*</span> B1 <span class="org-operator">==</span> H
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'sqrt(2)*H != [ 1 -1]\n[-1 -1]'
'PASSED'
</pre>
</div>
</div>
</div>

<div id="outline-container-org2f0cf1c" class="outline-3">
<h3 id="org2f0cf1c">Exercise 7.10 (Mach–Zehnder interferometer)</h3>
<div class="outline-text-3" id="text-org2f0cf1c">
<p>
Interferometers are optical tools used to measure small phase shifts, which are
constructed from two beamsplitters. Their basic principle of operation can be understood
by this simple exercise.
</p>


<ol class="org-ol">
<li><p>
Note that this circuit performs the identity operation:
</p>

<p>
\[ B_{\theta=\pi/4}^\dagger \cdot B_{\theta=\pi/4} \]
</p></li>
<li><p>
Compute the rotation operation (on dual-rail states) which this circuit performs, as a
function of the phase shift \(\varphi\):
</p>

<p>
\[ B_{\theta=\pi/4}^\dagger \cdot R_z(-\varphi) \cdot B_{\theta=\pi/4} \]
</p></li>
</ol>


<dl class="org-dl">
<dt>Remark</dt><dd>The book contains actual circuits drawings instead of algebraic
expressions. The second expression neglects the global phase (as is common).</dd>
</dl>
</div>


<div id="outline-container-orgccd1201" class="outline-4">
<h4 id="orgccd1201">Solution</h4>
<div class="outline-text-4" id="text-orgccd1201">
<p>
Recall that we have \(B=B(\theta)=R_y(2\theta)\). Hence \(B_{\theta=\pi/4}\) is a rotation
around the y-axis by ninety degrees. This maps the x-axis onto the reversed z-axsis. Hence
the (reversed) z-rotation in the middle effectively acts like a rotation around the x-axis
by an angle \(+\varphi\). The net result is \(R_x(\varphi)\).
</p>

<p>
Such reasoning easily leads to subtle errors. Therefore let us verify this using sagemath:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">B0</span> <span class="org-operator">=</span> B.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>4)
<span class="org-variable-name">phi</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'phi'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)

<span class="org-keyword">assert</span> B0.H <span class="org-operator">*</span> Rz.subs(theta<span class="org-operator">=-</span>phi) <span class="org-operator">*</span> B0 <span class="org-operator">==</span> Rx.subs(theta<span class="org-operator">=</span>phi)
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
It worked out 😎!
</p>
</div>
</div>
</div>

<div id="outline-container-orgd766695" class="outline-3">
<h3 id="orgd766695">Exercise 7.11</h3>
<div class="outline-text-3" id="text-orgd766695">
<p>
What is \(B\ket{2,0}\) for \(\theta=\pi/4\)?
</p>
</div>

<div id="outline-container-org7e6e346" class="outline-4">
<h4 id="org7e6e346">Solution</h4>
<div class="outline-text-4" id="text-org7e6e346">
<p>
Following the book we basically identify states with products of creation operators and
then use the <a href="#org0b98c8c">commutation relations</a> for the beamsplitter and \(B\ket{0,0}=\ket{0,0}\):
</p>

<p>
\[
  B\ket{2,0} = \frac{1}{\sqrt{2}} B (a^\dagger)^2 \ket{0,0}
  = \frac{1}{\sqrt{2}} \left(a^\dagger \cos(\theta) + b^\dagger \sin(\theta) \right)^2 \ket{0,0} .
\]
</p>

<p>
Now it helps that \(a^\dagger\) and \(b^\dagger\) commute, which implies
</p>

<p>
\[
  \left(a^\dagger \cos(\theta) + b^\dagger \sin(\theta) \right)^2
  = (a^\dagger)^2 \cos(\theta)^2 + (b^\dagger)^2 \sin(\theta)^2 + 2a^\dagger b^\dagger \sin(\theta)\cos(\theta) .
\]
</p>

<p>
Using \(2\sin(x)\cos(x)=\sin(2x)\) we obtain:
</p>

<p>
\[
  B\ket{2,0} = \cos(\theta)^2 \ket{2,0} + \sin(\theta)^2 \ket{0,2} +
  \frac{\sin(2\theta)}{\sqrt{2}} \ket{1,1} .
\]
</p>

<p>
Plugging in \(\theta=\pi/4\) we obtain
</p>

<p>
\[
  B_{\theta=\pi/4} \ket{2,0} = \frac{1}{2} \ket{2,0} + \frac{1}{2} \ket{0,2} +
  \frac{1}{\sqrt{2}} \ket{1,1}
\]
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-7.12" class="outline-3">
<h3 id="exercise-7.12">Exercise 7.12 (Quantum beamsplitter with classical inputs)</h3>
<div class="outline-text-3" id="text-exercise-7.12">
<p>
What is \(B\ket{\alpha,\beta}\) where \(\ket{\alpha}\) and \(\ket{\beta}\) are two coherent
states as in Equation (7.16)? (Hint: recall that
\(\ket{n}=\frac{(a^\dagger)^n}{\sqrt{n!}}\ket{0}\).)
</p>
</div>

<div id="outline-container-org3d30bef" class="outline-4">
<h4 id="org3d30bef">Solution</h4>
<div class="outline-text-4" id="text-org3d30bef">
<p>
Observe that
</p>

<p>
\[
  \ket{\alpha} = e^{-\abs{\alpha}^2/2} \sum_n \frac{\alpha^n}{\sqrt{n!}} \ket{n}
  = e^{\alpha a^\dagger - \abs{\alpha}^2/2} \ket{0} .
\]
</p>

<p>
There is one subtle thing to note here. The operator \((a^\dagger)\) is neither bounded nor
normal. So it is not clear if \(e^{\alpha a^\dagger}\) is well defined as an
operator.
</p>

<p>
Let us give a sketch of how one might make the exponential function rigorous. Let us
define the (large) Hilbert space spanned by the \(\ket{n}\) but with scalar product
(implicitly) defined by \(\sprod{n}{n}_1=(n!)\inv\). With respect to this Hilbert space
\(a^\dagger\) is bounded. Hence we can define \(e^{\alpha a^\dagger}\) by the usual
exponential series (we need the space for convergence).
</p>

<p>
Another way to deal with the problem is to just see it as an abbreviation. In fact, we
only ever apply such operators to \(\ket{0,0}\).
</p>

<p>
In the following let us abreviate \(K=e^{-(\abs{\alpha}^2+\abs{\beta}^2)/2}\),
\(c=\cos(\theta)\), and \(s=\sin(\theta)\). Now let us go on with the calculation:
</p>

\begin{align*}
  B \ket{\alpha,\beta}
  &= K B e^{\alpha a^\dagger + \beta b^\dagger} \ket{0,0} \\
  &= K B e^{\alpha a^\dagger + \beta b^\dagger} B^\dagger B \ket{0,0} \\
  &= K \exp(\alpha B a^\dagger B^\dagger + \beta B b^\dagger B^\dagger) \ket{0,0} \\
  &= K \exp(\alpha[ca^\dagger + sb^\dagger] + \beta[cb^\dagger-sa^\dagger]) \ket{0,0} \\
  &= K \exp((\alpha c - \beta s)a^\dagger + (\alpha s + \beta c)b^\dagger) \ket{0,0} \\
  & = \ket{\alpha c - \beta s, \alpha s + \beta c} .
\end{align*}

<p>
Hence the operation of \(B\) on coherent states is again given by a rotation matrix:
</p>

<p>
\[
  B: \begin{pmatrix} \alpha \\ \beta \end{pmatrix} \mapsto
  \begin{bmatrix} c & -s \\ s & c \end{bmatrix} \begin{pmatrix} \alpha \\ \beta \end{pmatrix} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org68dfcfe" class="outline-3">
<h3 id="org68dfcfe">Exercise 7.13 (Optical Deutsch–Jozsa quantum circuit)</h3>
<div class="outline-text-3" id="text-org68dfcfe">
<p>
In Section 1.4.4 (page 34), we described a quantum circuit for solving the one-bit
Deutsch–Jozsa problem. Here is a version of that circuit for single photon states (in the
dual-rail representation), using beamsplitters, phase shifters, and nonlinear Kerr media:
</p>

<pre class="example">
The book contains a drawing of the circuit at this place.
</pre>


<ol class="org-ol">
<li>Construct circuits for the four possible classical functions \(U_f\) using Fredkin gates and
beamsplitters.</li>
<li>Why are no phase shifters necessary in this construction?</li>
<li>For each \(U_f\) show explicitly how interference can be used to explain how the quantum
algorithm works.</li>
<li>Does this implementation work if the single photon states are replaced by coherent
states?</li>
</ol>
</div>

<div id="outline-container-org4f425ae" class="outline-4">
<h4 id="org4f425ae">Solution to 1</h4>
<div class="outline-text-4" id="text-org4f425ae">
<p>
Recall that \(U_f\) implements the following operation on the logical qubits:
</p>

<p>
\[
  U_f \ket{x,y} = \ket{x,y\oplus f(x)} .
\]
</p>

<p>
Recall from box 7.4 that the optical Fredkin gate
</p>

<p>
\[ \exp\left(\frac{\pi}{2} c^\dagger c (a^\dagger b - b^\dagger a)\right) \]
</p>

<p>
can be used two implement two different logical gates:
</p>

<ul class="org-ul">
<li>A <code>CX</code> gate in the dual-rail representation.</li>
<li>A <code>CSWAP</code> (the <i>actual</i> Fredkin gate) if operating directly on the physical qubits.</li>
</ul>

<p>
There are four possible functions (two constant, two balanced). Let us sketch how to
implement each of them.
</p>

<p>
\[
  f_1(x) = 0, \quad f_2(x) = 1, \quad f_3(x) = x, \quad f_4(x) = \neg x .
\]
</p>

<ol class="org-ol">
<li>\(f(x)=0\) can be implemented trivially by the empty circuit.</li>
<li>\(f(x)=1\) can accomplished by performing <code>X</code> on the second rail. This in turn can be
implemented by a <code>CX</code> and an ancilla initialized to <code>1</code>. We can use the optical Fredkin
gate in the dual-rail representation as mentioned above to do the <code>CX</code>.</li>
<li>\(f(x)=x\) just needs a <code>CX</code> which directly be implemented by the optical Fredkin gate in
the dual rail representation.</li>
<li>\(f(x)=\neg x\) just needs a <code>CX</code> conjugated by <code>X</code> in the control. Both types of gates
can be implemented as shown above.</li>
</ol>

<p>
So overall, we could do this with the <i>optical</i> Fredkin gate alone!
</p>
</div>
</div>

<div id="outline-container-org8482120" class="outline-4">
<h4 id="org8482120">Solution to 2</h4>
<div class="outline-text-4" id="text-org8482120">
<p>
That \(U_f\) can be implemented without phase shifts should be clear since controlled <code>X</code>
gates (this is what the optical Fredkin does on the dual-rail represenation as we have
just seen) are sufficient to implement any boolean function.
</p>

<p>
So let us turn to the question "why" no phase shifts are needed in the rest of the
circuit. More precisely we show that the circuit leads to the same measurement statistics
as the Deutsch-Josza algorithm (and so is identical for all practical purposes). The
circuit implements
</p>

<p>
\[
  B^\dagger \otimes I \cdot U_f \cdot B \otimes B .
\]
</p>

<p>
The original Deutsch-Josza algorithm is the same, but with \(B\) replaced by \(H\). The
initial state \(\ket{01_L}\) is the same. But recall that \(B=B_{\theta=\pi/4}=HZ\). The \(Z\)
would be implemented by a phase shift. But we actually do not need them since in this
particular setting at the intial state they just produce a global phase \(-1\) and at the
final state it does not matter since we measure in the computational base anyway).
</p>
</div>
</div>

<div id="outline-container-orgd61cb5a" class="outline-4">
<h4 id="orgd61cb5a">Solution to 3</h4>
<div class="outline-text-4" id="text-orgd61cb5a">
<p>
Not sure what this exercise even means. If it means to show that the circuit actually
implements the Deutsch-Josza algorithm: then this was done in the solution to 2.
</p>
</div>
</div>

<div id="outline-container-org37f7695" class="outline-4">
<h4 id="org37f7695">Solution to 4</h4>
<div class="outline-text-4" id="text-org37f7695">
<p>
No it does not work with coherent states. No matter how the measurement outcome is
interpreted there is always a non-zero chance of failure for some \(f\) (recall that the
Deutsch-Josza algorithm is one of a few <i>quantum</i> algorithms with a 100% success
probability).
</p>

<p>
To see this consider the constructions of \(U_f\) from part 1 (we need to look at a
particular implemenation since the action on coherent states might be different for
different implementation). We only look at the cases \(f(x)=0\) (constant) and \(f(x)=x\)
(balanced).
</p>

<p>
Let us assume that the intial state is \(\ket{\alpha,\beta,\gamma,\delta}\).  Let us
abbreviate \(\phi_{\pm}=(\gamma\pm\delta)/\sqrt{2}\). In the constant case the final state
is (see <a href="#exercise-7.12">exercise 7.12</a> for the action of beamsplitters on coherent states)
</p>

<p>
\[
  \ket{\alpha, \beta, \phi_-, \phi_+} ,
\]
</p>

<p>
In the balanced case, in addition there is also an <i>optical</i> Fredkin gate applied <code>a</code>, <code>b</code>
with control at <code>d</code>. In this case the final state is:
</p>

<p>
\[
  e^{\frac{\pi}{2} d^\dagger d(a^\dagger b - ab^\dagger)} \ket{\alpha,\beta,\phi_-,\phi_+}
  = e^{-\abs{\phi_+}^2/2} \sum_n \frac{\phi_+^n}{\sqrt{n!}} e^{\frac{\pi n}{2}(a^\dagger b - ab^\dagger)}
    \ket{\alpha,\beta,\phi_-,n} .
\]
</p>

<p>
Note that the Fredkin gate acts as a controlled beamsplitter, and for this particular angle we have
</p>

<p>
\[
  e^{\frac{\pi n}{2}(a^\dagger b - ab^\dagger)} \ket{\alpha,\beta,\phi_-,n} = \begin{cases}
     \ket{\alpha,\beta,\phi_-,n} & \text{for } n \text{ even,} \\
     \ket{-\beta,\alpha,\phi_-,n} & \text{for } n \text{ odd.} \end{cases}
\]
</p>

<p>
Note that there is always a non-zero probability that \(n=0\) (even) is measured in \(d\). In
that case the measurement statistics for the other three rails is the same as for the
constant case. In particular there are measurement results which match both, the constant
and the balanced case. Hence an exact algorithm with 100% success probability is not
possible. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc3fee64" class="outline-3">
<h3 id="orgc3fee64">Exercise 7.14 (Classical cross phase modulation)</h3>
<div class="outline-text-3" id="text-orgc3fee64">
<p>
To see that the expected classical behavior of a Kerr medium is obtained from the
deﬁnition of \(K\), Equation (7.41), apply it to two modes, one with a coherent state and
the other in state \(\ket{n}\); that is, show that
</p>

<p>
\[
  K \ket{\alpha}\ket{n} = \ket{\alpha e^{\ii\chi Ln}}\ket{n} .
\]
</p>

<p>
Use this to compute
</p>

\begin{align*}
  \rho_a &= \ptrace{b}{K\ket{\alpha}\ket{\beta}\bra{\beta}\bra{\alpha} K^\dagger} \\
  &= e^{-\abs{\beta}^2} \sum_m \frac{\abs{\beta}^{2m}}{m!} \proj{\alpha e^{\ii\chi Lm}} .
\end{align*}

<p>
and show that the main contribution to the sum is for \(m=\abs{\beta}^2\).
</p>
</div>

<div id="outline-container-orgb9e7d88" class="outline-4">
<h4 id="orgb9e7d88">Proof of the first part</h4>
<div class="outline-text-4" id="text-orgb9e7d88">
<p>
Let us abbreviate \(\xi=\chi L\) and \(J=a^\dagger ab^\dagger b\). We have
</p>

<p>
\[
  \ket{\alpha}\ket{n} = e^{-\abs{\alpha}^2/2} \, (b^\dagger)^n \, e^{\alpha a^\dagger} \ket{0,0} .
\]
</p>

<p>
Hence we are interested to compute
</p>

<p>
\[
  K (b^\dagger)^n \, e^{\alpha a^\dagger} K^\dagger
  = K (b^\dagger)^n K^\dagger \, e^{\alpha K a^\dagger K^\dagger} .
\]
</p>

<p>
By the CBH formula we have
</p>

<p>
\[
  K a^\dagger K^\dagger = \sum_n \frac{(\ii\xi)^n}{n!} [(J)^n,a^\dagger] .
\]
</p>

<p>
For that reason let us look at
</p>

<p>
\[
  [J,a^\dagger] = [a^\dagger a, a^\dagger] b^\dagger b = a^\dagger [a, a^\dagger] b^\dagger b
  = a^\dagger b^\dagger b .
\]
</p>

<p>
Hence the iterated commutator is \([(J)^n,a^\dagger]=a^\dagger(b^\dagger b)^n\). Let
\(P_b=e^{\ii\xi\,b^\dagger\,b}\). Then
</p>

<p>
\[
  K a^\dagger K^\dagger = a^\dagger P_b .
\]
</p>

<p>
Similarly
</p>

<p>
\[
  K b^\dagger K^\dagger = b^\dagger P_a .
\]
</p>

<p>
Therefore
</p>

<p>
\[
  K (b^\dagger)^n \, e^{\alpha a^\dagger} K^\dagger
  = (b^\dagger)^n P_a^n \, e^{\alpha a^\dagger P_b} .
\]
</p>

<p>
Finally, using \(P_a^n\ket{k}=e^{\ii\xi\,nk}\ket{k}\), we obtain
</p>

<p>
\[
  K \ket{\alpha} \ket{n}
  = e^{-\abs{\alpha}^2/2} (b^\dagger)^n P_a^n \, e^{\alpha a^\dagger P_b} \ket{0,0}
  = e^{-\abs{\alpha}^2/2} (b^\dagger)^n \, e^{\alpha e^{\ii\xi\,n} a^\dagger} \ket{0,0}
  = \ket{\alpha e^{\ii\xi\,n}} \ket{n} .
\]
</p>

<p>
QED.
</p>
</div>
</div>

<div id="outline-container-org365fbfe" class="outline-4">
<h4 id="org365fbfe">Proof of the second part</h4>
<div class="outline-text-4" id="text-org365fbfe">
<p>
Using the first part we get
</p>

\begin{align*}
  \rho_b
  &= \sum_{mn} \ptrace{b}{K \ket{\alpha} \frac{\beta^{m+n}}{\sqrt{m!n!}} \ket{m}\bra{n} \bra{\alpha} K^\dagger} \\
  &= \sum_{mn} \ptrace{b}{\ket{\alpha e^{\ii\xi\,m}} \frac{\beta^{m+n}}{\sqrt{m!n!}} \ket{m}\bra{n} \bra{\alpha e^{\ii\xi\,n}}} \\
  &= \sum_{m} \frac{\beta^{2m}}{m!} \proj{\alpha e^{\ii\xi\,m}} .
\end{align*}

<p>
To show the final claim consider the function
</p>

<p>
\[ g(m) = \log(b^{2m}/m!) . \]
</p>

<p>
For simplicity let us assume \(\beta\geq0\) (to avoid writing \(\abs{\beta}\) all the
time). We have to find the maximum of \(g\). I put the logarithm there to simplify
differentiating this function. By Stirlings formula we have
</p>

<p>
\[ g(m) \approx m (1 + 2\log{\beta} - \log{m}) . \]
</p>

<p>
The derivative is \(g'(m)=2\log{\beta}-\log{m}\). This is zero iff \(m=\beta^2\). Hence the
biggest contribution to \(\rho_b\) comes from a state close to \(\ket{\alpha\,e^{\ii\xi\abs{\beta}^2}}\). QED.
</p>
</div>
</div>
</div>
<div id="outline-container-org2be884a" class="outline-3">
<h3 id="org2be884a">Exercise 7.15</h3>
<div class="outline-text-3" id="text-org2be884a">
<p>
Plot (7.55):
</p>

<p>
\[
  P_{\mathrm{cav}}/P_{\mathrm{in}} = \frac{1 - R_1}{\abs{1 + e^{\ii\varphi}\sqrt{R_1R_2}}^2}
\]
</p>

<p>
as a function of field detuning \(\varphi\), for \(R_1=R_2=0.9\).
</p>
</div>

<div id="outline-container-orga8de28b" class="outline-4">
<h4 id="orga8de28b">Solution</h4>
<div class="outline-text-4" id="text-orga8de28b">
<p>
Here is the code to make the plot in <code>sage</code>:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org158ff57"><span class="org-variable-name">R1</span>, <span class="org-variable-name">R2</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'R1 R2'</span>, domain<span class="org-operator">=</span><span class="org-string">'positive'</span>)
<span class="org-variable-name">phi</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'phi'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)

<span class="org-variable-name">power</span> <span class="org-operator">=</span> (1 <span class="org-operator">-</span> R1) <span class="org-operator">/</span> <span class="org-builtin">abs</span>(1 <span class="org-operator">+</span> exp(i<span class="org-operator">*</span>phi)<span class="org-operator">*</span>sqrt(R1<span class="org-operator">*</span>R2))<span class="org-operator">**</span>2

<span class="org-keyword">def</span> <span class="org-function-name">make_plot_ex715</span>(r1, r2<span class="org-operator">=</span><span class="org-constant">None</span>, interval<span class="org-operator">=</span>(0, 2), <span class="org-operator">**</span>kwargs):
    <span class="org-doc">"""Plot P_cav/P_in according to exercise 7.15 but with s=phi/pi on the x-axis."""</span>
    <span class="org-variable-name">s</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'s'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
    <span class="org-keyword">return</span> parametric_plot((s, power.subs(phi<span class="org-operator">=</span>pi<span class="org-operator">*</span>s, R1<span class="org-operator">=</span>r1, R2<span class="org-operator">=</span>r2 <span class="org-keyword">or</span> r1)), (s,) <span class="org-operator">+</span> interval, <span class="org-operator">**</span>kwargs)
</pre>
</div>

<p>
You can use it like so:
</p>

<div class="org-src-container">
<pre class="src src-sage">show(make_plot_ex715(0.9, interval<span class="org-operator">=</span>(0.5, 1.5), aspect_ratio<span class="org-operator">=</span><span class="org-string">'automatic'</span>))
</pre>
</div>


<div id="org74a6ecc" class="figure">
<p><img src="images/exercise_7_15_plot.png" alt="exercise_7_15_plot.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Fabry-Perot cavity, relative power \(P_{\mathrm{cav}}/P_{\mathrm{in}}\) inside cavity vs \(\varphi/\pi\).</p>
</div>

<p>
As we can see \(P_{\mathrm{cav}}/P_{\mathrm{in}}\) is maximal at \(\varphi=\pi\) with value
\((1-R)^{-1}=10\). Let us also note that at \(\varphi=0\) and \(\varphi=2\pi\) the value is
roughly \((1-R_1)/4\) if \(R_1,R_2\approx1\). Moreover the width of the central peak is around
\(R_1\inv\) as can be easily verified by plugging in the Taylor expansion of
\(e^{\ii\varphi}\) at \(\varphi=\pi\) into the formula for \(P_{\mathrm{cav}}/P_{\mathrm{in}}\).
</p>
</div>
</div>
</div>

<div id="outline-container-org90aab4a" class="outline-3">
<h3 id="org90aab4a">Exercise 7.16 (Electric dipole selection rules)</h3>
<div class="outline-text-3" id="text-org90aab4a">
<p>
Show that (7.60):
</p>

<p>
\[
  \int Y_{l_1m_1}^* Y_{1,\pm1} Y_{l_2m_2} \dd \Omega
\]
</p>

<p>
is non-zero only when \(m_2-m_1=\pm1\) and \(\Delta\,l=\pm1\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
More precisely: Let \(a\in\{+1,-1\}\) and replace the middle function by
\(Y_{1a}\). Then the integral does not vanish if and only if
</p>

<p>
\[
  m_2 - m_1 = a \text{ and } \abs{l_2-l_1} = 1 .
  \]
</p>

<p>
That is, the sign of \(\Delta\,m\) does depend on which of the two \(Y_{1,\pm1}\) is chosen
but the sign of \(\Delta\,l\) does not.
</p></dd>
</dl>
</div>

<div id="outline-container-orgd841c1c" class="outline-4">
<h4 id="orgd841c1c">Proof</h4>
<div class="outline-text-4" id="text-orgd841c1c">
<p>
All relevant functions involve relatively complicated constant factors. Since we are only
interested in the question whether the integral is non-zero or not, let us introduce a
specific notation for this exercise: We write \(a\sim b\) if \(a=cb\) for some <i>non-zero</i> and
<i>constant</i> \(c\). By constant I mean that \(c\) does not depend on \(\theta\) or \(\varphi\) (the
variables we integrate over).
</p>

<p>
Let \(a=\pm1\) and note that \(Y_{1,a}\sim\sin(\theta)e^{a\ii\varphi}\). By
\(\dd\Omega=\sin(\theta)\dd\theta\dd\varphi\) the definition of the spherical harmonics in
terms of the <a href="https://en.wikipedia.org/wiki/Associated_Legendre_polynomials">associated Legendre polynomials</a> we have:
</p>

\begin{align*}
  \int Y_{l_1m_1}^* Y_{1,\pm1} Y_{l_2m_2} \dd \Omega
  &\sim \int_0^{\pi} \int_0^{2\pi} Y_{l_1m_1}^* Y_{l_2m_2} \sin(\theta)^2 e^{a\ii\varphi} \dd\varphi\dd\theta \\
  &\sim \int_{-1}^{+1} \int_{0}^{2\pi} P_{l_1m_1}^*(x) P_{l_2m_2}(x) \sqrt{1-x^2} e^{\ii\varphi(m_2-m_1+a)} \dd\varphi \dd x \\
  &\sim: I_1 .
\end{align*}

<p>
The integral over \(\varphi\) vanishes iff \(m_1=m_2+a\). This already proves the first part
of the exercise. Let \(b=(a+1)/2\). The question now translates to the task to find out when
the following integral vanishes:
</p>

<p>
\[
  I_1 \sim I_2 := \int_{-1}^{+1} (1-x^2)^{m_2+b} \partial_x^{m_2+a+l_1} (x^2-1)^{l_1} \partial_x^{m_2+l_2} (x^2-1)^{l_2} \dd x .
\]
</p>

<p>
Let us rewrite this in terms of the "normal" <a href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre polynomials</a>
\(P_l(x)\sim\partial_x^l(x^2-1)^l\):
</p>

<p>
\[
  I_2 \sim I_3(b) :=
  \int_{-1}^{+1} (1-x^2)^{m_2+b} \partial_x^{m_2+a} P_{l_1}(x) \cdot \partial_x^{m_2} P_{l_2}(x) \dd x .
\]
</p>

<p>
Let us define the differential operator \(D_n=\partial_x^n(1-x^2)^n\partial_x^n\). Moreover,
write \(\tilde{P}_l(x)\sim\partial_x^{l-1}(x^2-1)^l\) (this is the Legendre polynomial of
order \(l\) for \(l\,>\,0\) where one derivative was "stolen"). Integration by parts \(m_2+b\)
times (in one or in the other direction) yields:
</p>

<p>
<a id="org8e8eaf8"></a>
\[
  I_3(b=0) \sim \int_{-1}^{+1} \tilde{P}_{l_1}(x) \cdot D_{m_2} P_{l_2}(x) \dd x .
\]
</p>

<p>
assuming \(l_1\neq0\), and
</p>

<p>
<a id="org4729dd5"></a>
\[
  I_3(b=1) \sim \int_{-1}^{+1} D_{m_2+1} P_{l_1}(x) \cdot \tilde{P}_{l_2}(x) \dd x .
\]
</p>

<p>
assuming \(l_2\neq1\).
</p>

<p>
As said these formulas are only valid for \(l_1\neq0\) or \(l_2\neq0\) respectively. This
however is not a big issue since these special cases are very simple. Let us briefly
consider the case \(b=l_1=0\). It follows that \(m_1=0\) and hence \(m_2=m_1+1=1\) and
\(l_2\geq1\). Hence the integral simplifies to
\(\int(1-x^2)\partial_x\,P_{l_2}(x)\dd\,x\). Using integration by parts (once) we see that
this is only ever non-zero if \(l_2=1\), proving the claim for this special case (we use
that \(P_1(x)\sim\,x\) and take the orthogonality relations for the Legendre polynomials for
granted). The case \(b=1\) is similar.
</p>

<p>
Let us come back to the above formulas for <a href="#org8e8eaf8">\(b=0\)</a> and <a href="#org4729dd5">\(b=1\)</a>. We have the following
</p>

<dl class="org-dl">
<dt>Lemma</dt><dd><p>
<a id="orgd0927f1"></a> \(P_l\) is an eigenfunction of \(D_n\). More precisely
\(D_nP_l=\lambda_{nl}P_l\) where
</p>

<p>
\[
  \lambda_{nl} = \prod_{j=0}^{n-1} \left( j(j+1) - l(l+1) \right) .
  \]
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Note that \(\lambda_{nl}=0\) for \(n\geq\,l+1\).</dd>
</dl></dd>
</dl>

<p>
Before we prove the Lemma let us see why this helps us. We only have to consider the case
\(b=0\) since the other case is the same. Using the lemma we see that
</p>

<p>
\[
  I_3(b=0) \sim \int_{-1}^{+1} \tilde{P}_{l_1}(x) \cdot P_{l_2}(x) \dd x .
\]
</p>

<p>
Recall that the Legendre polynomial form an orthogonal (and complete) set of functions of
the Hilbert space \(L^2(-1,+1)\). We will show that the above "skewed" version of the scalar
product is non-zero iff \(\abs{l_1-l_2}=1\) (yes there are two values of \(l_2\) for each
\(l_1\geq1\)).
</p>

<p>
The idea to see this is a case analysis. We use integration by parts below. Please observe
that the reason that no boundary terms are introduced by this is precisely because one of
the derivatives is "missing".
</p>

<dl class="org-dl">
<dt>Case \(l_1\geq\,l_2+1\)</dt><dd><p>
Integration by parts yields
</p>

<p>
\[
  I_3(b=0) \sim \int_{-1}^{+1} (x^2-1)^{l_1} \partial_x^{l_1+l_2-1} (x^2-1)^{l_2} \dd x.
  \]
</p>

<p>
Clearly the term with the many derivatives vanishes if \(l_1\,>\,l_2+1\). On the other
hand it is a constant if \(l_1=l_2+1\). Hence the integral is non-zero iff \(l_1=l_2+1\).
</p></dd>
<dt>Case \(l_2\geq\,l_1+1\)</dt><dd>This case is analogous to the first case. The only difference is
that we move the derivative to the other side. The integral is non-zero iff \(l_2=l_1+1\).</dd>
<dt>Case \(l_1=l_2+1=:l\)</dt><dd><p>
In that case we can move all derivatives to either side and get
</p>

<p>
\[
  I_3(b=0) \sim \int_{-1}^{+1} x(x^2-1)^l = 0,
  \]
</p>

<p>
since the integrand is an odd function (meaning \(f(-x)=-f(x)\)) over a symmetric
interval.
</p></dd>
</dl>

<p>
It remains to do the following
</p>

<dl class="org-dl">
<dt>Proof of the <a href="#orgd0927f1">lemma</a></dt><dd><p>
We prove this by mathematical induction. The case \(n=0\) is trivial
(\(D_0\) is the identity and \(\lambda_{0l}=1\)). Let us assume the claim for an \(n\geq0\)
and consider
</p>

<p>
\[
  D_{n+1} P_l = \partial_x^{n+1} (1-x^2)^{n+1} \partial_x^{n+1} P_l .
  \]
</p>

<p>
Note that \(D_{n+1}\) consists of three blocks, the left and right one contain only
derivatives and the middle one is a function of the position operator. The idea is to
commute one of the derivatives from the right block through the middle block and
similarly one factor \((1-x^2)\) from the middle block through the left block (including
the one derivative which was moved there from the right block). This should lead to an
expression of the form \((\ldots)D_nP_l\) and we can apply the induction hypothesis.
</p>

<p>
Let us start:
</p>

\begin{align*}
D_{n+1} P_l &= \partial_x^{n+2} (1-x^2)^{n+1} \partial_x^{n} P_l +
    2(n+1)\partial_x^{n+1} x(1-x^2)^{n} \partial_x^{n} P_l \\
&=: A + 2(n+1)B .
\end{align*}

<p>
Next, let us treat \(B\) by commuting the \(x\) to the left:
</p>

\begin{align*}
B &= x\partial_x D_n P_l + (n+1)D_nP_l \\
&= \lambda_{nl} \left(xP_l' + (n+1)P_l \right) .
\end{align*}

<p>
Now we go on with \(A\). We first make a simple thing: just take one of the factors
\((1-x^2)\) and split the some with \(1\) and \(-x^2\):
</p>

\begin{align*}
A &= \partial_x^2 D_n P_l - \partial_x^{n+2} x^2 (1-x^2)^n \partial_x^n P_l \\
&=: \lambda_{nl} P_l'' - A_1 .
\end{align*}

<p>
For \(A_1\) we try to commute the \(x^2\) to the left:
</p>

\begin{align*}
A_1 &= x^2 \partial_x^2 D_nP_l + 2(n+2) x \partial_x D_nP_l + (n+2)(n+1)D_nP_l \\
&= \lambda_{nl} \left(x^2P_l'' + 2(n+2)xP_l' + (n+2)(n+1)P_l  \right) .
\end{align*}

<p>
Gathering what we obtained leads to
</p>

<p>
\[
  D_{n+1} P_l = \lambda_{nl} \left((1-x^2)P_l'' - 2x P_l' + n(n+1) P_l \right) .
  \]
</p>

<p>
Recall <i>Legendre's differential equation</i>:
</p>

<p>
\[
  (1-x^2)P_l'' - 2xP_l' + n(n+1)P_l = 0 .
  \]
</p>

<p>
I won't prove it (it is well known) but let me mention the following. Legendre's
differential equation is actually the special case \(n=1\): \(D_1P_l=-l(l+1)P_l\). I am
confident that one can prove it by induction on \(l\) (I did not check this claim
though). The case \(l=0\) is trivial. The induction step can probably be proved by moving
around derivatives and position operators as we have seen above.
</p>

<p>
Using Legendre's differential equation we obtain
</p>

<p>
\[
  D_{n+1} P_l = \lambda_{nl} \left(n(n+1) - l(l+1)\right) P_l ,
  \]
</p>

<p>
which essentially proves the claim. QED.
</p></dd>
</dl>
</div>
</div>


<div id="outline-container-org4d48328" class="outline-4">
<h4 id="org4d48328">Appendix</h4>
<div class="outline-text-4" id="text-org4d48328">
<p>
Before I finally managed to find the solution to this exercise I had to do a lot of
experiments with sage math. I do not want to collect them all here but let me just give
one example.
</p>

<p>
I was a bit surprised by the fact that the <a href="#orgd0927f1">lemma</a> should be true. By what the exercise
demanded to show and what I already managed to prove it had to be true. On the other hand
I typically do a lot of mistakes when doing such calculations so I needed a way to verify
the claim for concrete values of \(n\) and \(l\). It turned out that my experiments backed the
lemma and I could go on proving it.
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org125faf3"><span class="org-comment-delimiter"># </span><span class="org-comment">We have to call it xx to not overwrite the position operator.</span>
<span class="org-variable-name">xx</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'x'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)

<span class="org-keyword">def</span> <span class="org-function-name">Pl</span>(l):
    <span class="org-doc">"""Legendre polynomial of order l."""</span>
    <span class="org-variable-name">q</span> <span class="org-operator">=</span> xx<span class="org-operator">^</span>2 <span class="org-operator">-</span> 1
    <span class="org-keyword">return</span> diff(q<span class="org-operator">^</span>l, xx, l)

<span class="org-keyword">def</span> <span class="org-function-name">Dn</span>(f, n<span class="org-operator">=</span>1):
    <span class="org-doc">"""Differential operator dx^n (1-x^2)^n dx^n."""</span>
    <span class="org-keyword">return</span> diff((1<span class="org-operator">-</span>xx<span class="org-operator">^</span>2)<span class="org-operator">^</span>n <span class="org-operator">*</span> diff(f, xx, n), xx, n)


<span class="org-keyword">def</span> <span class="org-function-name">lambda_nl</span>(n, l):
    <span class="org-doc">"""Eigenvalues: DnPl=lambda_nl*Pl."""</span>
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> 1
    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-variable-name">result</span> <span class="org-operator">*=</span> j<span class="org-operator">*</span>(j<span class="org-operator">+</span>1) <span class="org-operator">-</span> l<span class="org-operator">*</span>(l<span class="org-operator">+</span>1)
    <span class="org-keyword">return</span> result
</pre>
</div>

<p>
Test the claim of the lemma:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org5ac21f9"><span class="org-keyword">for</span> l <span class="org-keyword">in</span> <span class="org-builtin">range</span>(6):
    <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(l<span class="org-operator">+</span>1):
        <span class="org-variable-name">q</span> <span class="org-operator">=</span> Dn(Pl(l), n) <span class="org-operator">-</span> lambda_nl(n, l)<span class="org-operator">*</span>Pl(l)
        <span class="org-keyword">assert</span> q <span class="org-operator">==</span> 0
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1.50 (<a href="https://orgmode.org">Org</a> mode 9.6.7)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>