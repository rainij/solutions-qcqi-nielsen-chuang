<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="Reinhard Stahn"/><title>Chapter 7</title><link rel="icon" type="image/x-icon" sizes="any" href="./favicon/favicon.ico"/><!-- https://simplecss.org - License: MIT - We are using ./simple.css from commit dcb3545f2304356985c99acce9471ba3f559976b from https://github.com/kevquirk/simple.css --><link rel="stylesheet" href="./css/simple.css"/><link rel="stylesheet" href="./css/style.css"/><script src="./js/perf.js"></script><script src="./js/mathjax.js"></script><script async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei" crossorigin="anonymous"></script></head><body><nav><a href="index.html">HOME</a></nav><h1 class="title">Chapter 7</h1>\[
\newcommand{\CC}{\mathbb{C}}
\newcommand{\HH}{\mathbb{H}}
\newcommand{\KK}{\mathbb{K}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ii}{\mathrm{i}}
\newcommand{\jj}{\mathrm{j}}
\newcommand{\kk}{\mathrm{k}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\FT}{\mathcal{F}} % Fourier Transform
\newcommand{\tto}{\twoheadrightarrow}
\newcommand{\inv}{^{-1}}
\newcommand{\RF}{\mathrm{RF}}
\newcommand{\sys}{\mathrm{sys}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\sprod}[2]{\langle#1|#2\rangle} % scalar product
\newcommand{\ptrace}[2]{\mathrm{tr}_{#1}\left(#2\right)}
\newcommand{\trace}[1]{\mathrm{tr}\left(#1\right)}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\proj}[1]{\ket{#1}\bra{#1}}
\newcommand{\mean}[1]{\langle#1\rangle}
\newcommand{\orac}{\mathrm{Orac}}
\]
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org911b99d">Setup</a>
<ul>
<li><a href="#orgf004edc">Imports</a></li>
<li><a href="#org8f2887d">Harmonic Oscillator</a></li>
<li><a href="#org3b7b6c2">Optical photon quantum computers</a></li>
<li><a href="#discussion-annoying-error">Discussion of an annoying error</a></li>
<li><a href="#chapter-7-state-tomography">On magnetization readout and state tomography</a></li>
</ul>
</li>
<li><a href="#orgf9663c3">Exercises</a>
<ul>
<li><a href="#org5b762d3">Exercise 7.1</a></li>
<li><a href="#exercise-7.2">Exercise 7.2</a></li>
<li><a href="#org1c1a5bd">Exercise 7.3</a></li>
<li><a href="#org9ac0eb2">Exercise 7.4</a></li>
<li><a href="#org2094e89">Exercise 7.5</a></li>
<li><a href="#org60a18ac">Exercise 7.6 (Eigenstates of photon annihilation)</a></li>
<li><a href="#orgd6102a2">Exercise 7.7</a></li>
<li><a href="#org76a7a9b">Exercise 7.8</a></li>
<li><a href="#orgb9be0d1">Exercise 7.9 (Optical Hadamard gate)</a></li>
<li><a href="#org779f3d8">Exercise 7.10 (Mach–Zehnder interferometer)</a></li>
<li><a href="#orgb328f59">Exercise 7.11</a></li>
<li><a href="#exercise-7.12">Exercise 7.12 (Quantum beamsplitter with classical inputs)</a></li>
<li><a href="#org2bf4a5c">Exercise 7.13 (Optical Deutsch–Jozsa quantum circuit)</a></li>
<li><a href="#org9340ddd">Exercise 7.14 (Classical cross phase modulation)</a></li>
<li><a href="#orge435415">Exercise 7.15</a></li>
<li><a href="#org0bc44d9">Exercise 7.16 (Electric dipole selection rules)</a></li>
<li><a href="#org4cf9f17">Exercise 7.17 (Eigenstates of the Jaynes–Cummings Hamiltonian)</a></li>
<li><a href="#exercise-7.18">Exercise 7.18 (Rabi oscillations)</a></li>
<li><a href="#orgecc2e1c">Exercise 7.19 (Lorentzian absorption profile)</a></li>
<li><a href="#exercise-7.20">Exercise 7.20 (Single photon phase shift)</a></li>
<li><a href="#org797959c">Exercise 7.21</a></li>
<li><a href="#org33b4e64">Exercise 7.22</a></li>
<li><a href="#orgdac22a0">Exercise 7.23</a></li>
<li><a href="#org9a65367">Exercise 7.24</a></li>
<li><a href="#org676e456">Exercise 7.25</a></li>
<li><a href="#exercise-7.26">Exercise 7.26</a></li>
<li><a href="#org13db63e">Exercise 7.27 (Three spin angular momenta states)</a></li>
<li><a href="#org81ef22a">Exercise 7.28 (Hyperfine states)</a></li>
<li><a href="#org8e91e5b"><span class="todo SKIP">SKIP</span> Exercise 7.29 (Spontaneous emission)</a></li>
<li><a href="#org29262f2">Exercise 7.30 (Electronic state lifetimes)</a></li>
<li><a href="#org4fc76bc">Exercise 7.31</a></li>
<li><a href="#orgc9bfcf7">Exercise 7.32</a></li>
<li><a href="#org69b74a9">Exercise 7.33 (Magnetic resonance)</a></li>
<li><a href="#orgb176066"><span class="todo TODO">TODO</span> Exercises 7.34 (NMR frequencies)</a></li>
<li><a href="#orgda0f63a"><span class="todo SKIP">SKIP</span> Exercises 7.35 (Motional narrowing)</a></li>
<li><a href="#orgfe0b287">Exercises 7.36 (Thermal equilibrium NMR state)</a></li>
<li><a href="#org430d473">Exercises 7.37 (NMR spectrum of coupled spins)</a></li>
<li><a href="#org62adbb9">Exercise 7.38 (Refocusing)</a></li>
<li><a href="#orgeef32cd">Exercise 7.39 (Three-dimensional refocusing)</a></li>
<li><a href="#org8891d06">Exercise 7.40 (Refocusing dipolar interactions)</a></li>
<li><a href="#org7189e34">Exercise 7.41 (NMR <code>CNOT</code>)</a></li>
<li><a href="#org69a4d97">Exercise 7.42 (Permutations for temporal labeling)</a></li>
<li><a href="#orge4ff41d">Exercise 7.43 (Permutations for logical labeling)</a></li>
<li><a href="#org48bfe41"><span class="todo SKIP">SKIP</span> Exrcise 7.44 (Logical labeling for \(n\) spins)</a></li>
<li><a href="#exercise-7.45">Exercise 7.45 (State tomography with NMR)</a></li>
<li><a href="#org35fa11e"><span class="todo WIP">WIP</span> Exercise 7.46</a></li>
<li><a href="#org5433fc5">Exercise 7.47 (NMR <code>CNOT</code> gate)</a></li>
<li><a href="#orge11e9f9">Exercise 7.48</a></li>
<li><a href="#org722d0a3">Exercise 7.49 (NMR swap gate)</a></li>
<li><a href="#org0a94668">Exercise 7.50</a></li>
<li><a href="#org2e8be21">Exercise 7.51</a></li>
</ul>
</li>
<li><a href="#orgc4398b3">References</a></li>
</ul>
</div>
</div>

<div id="outline-container-org911b99d" class="outline-2">
<h2 id="org911b99d">Setup</h2>
<div class="outline-text-2" id="text-org911b99d">
</div>
<div id="outline-container-orgf004edc" class="outline-3">
<h3 id="orgf004edc">Imports</h3>
<div class="outline-text-3" id="text-orgf004edc">
<div class="org-src-container">
<pre class="src src-sage" id="orge49ffce"><span class="org-keyword">from</span> scipy.constants <span class="org-keyword">import</span> physical_constants, pi <span class="org-keyword">as</span> pi_numeric

<span class="org-keyword">from</span> utils <span class="org-keyword">import</span> commutator <span class="org-keyword">as</span> com
<span class="org-keyword">from</span> utils_sage <span class="org-keyword">import</span> Id, X, Y, Z, H, Rx, Ry, Rz, CX, kron, bra, ket
</pre>
</div>

<p>
For circuit drawings (python, not tangled):
</p>

<div class="org-src-container">
<pre class="src src-python" id="org7158024"><span class="org-keyword">from</span> qiskit.circuit <span class="org-keyword">import</span> QuantumCircuit, Gate
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f2887d" class="outline-3">
<h3 id="org8f2887d">Harmonic Oscillator</h3>
<div class="outline-text-3" id="text-org8f2887d">
<p>
To simplify calculations we will use unit-less expressions. To do this let \(\tilde{x}\),
\(\tilde{p}\), etc denote physical quantities <i>with</i> units and denote the unit-less versions
without the tilde, such that e.g.
</p>

<p>
<a id="org4032fe7"></a>
\[
  \tilde{x} = \sqrt{\frac{\hbar}{m\omega}} \; x, \quad \tilde{p} = \sqrt{m\omega\hbar} \; p .
\]
</p>

<p>
Note that this implies \(p=-\ii\partial_x\). The effect on \(H\) and \(a\) is the same as
setting \(m=\hbar=\omega=1\) (we have e.g. \(H=p^2/2+x^2/2\)).
</p>

<p>
In this chapter let us use the python based computer algebra system <a href="https://www.sagemath.org/">sage</a> to solve the
exercises (some of them). For this reason we define momentum and position operator in code
as follows:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orga86b5d1">R.<span class="org-operator">&lt;</span>x<span class="org-operator">&gt;</span> <span class="org-operator">=</span> QQbar[]
<span class="org-variable-name">W</span> <span class="org-operator">=</span> DifferentialWeylAlgebra(R)
(<span class="org-variable-name">x</span>, <span class="org-variable-name">dx</span>) <span class="org-operator">=</span> W.gens()
<span class="org-variable-name">p</span> <span class="org-operator">=</span> <span class="org-operator">-</span>i<span class="org-operator">*</span>dx
</pre>
</div>

<p>
Having this we can define the Hamiltonian \(H\) of the one-dimensional harmonic oscillator
and the corresponding annihilation (\(a\)), and creation operator (\(a^\dagger\)):
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org82f128a"><span class="org-variable-name">H_qho</span> <span class="org-operator">=</span> p<span class="org-operator">^</span>2 <span class="org-operator">/</span> 2 <span class="org-operator">+</span> x<span class="org-operator">^</span>2 <span class="org-operator">/</span> 2

<span class="org-variable-name">a</span> <span class="org-operator">=</span> (x <span class="org-operator">+</span> i<span class="org-operator">*</span>p) <span class="org-operator">/</span> sqrt(2)
<span class="org-variable-name">ad</span> <span class="org-operator">=</span> (x <span class="org-operator">-</span> i<span class="org-operator">*</span>p) <span class="org-operator">/</span> sqrt(2)
</pre>
</div>

<p>
Some basic sanity checks:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgca86c41"><span class="org-keyword">assert</span> com(x, p) <span class="org-operator">==</span> i
<span class="org-keyword">assert</span> com(a, ad) <span class="org-operator">==</span> 1
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Note that from <a href="#org4032fe7">above</a> we get
</p>

<p>
<a id="orgf5a1906"></a>
\[
  \tilde{H} = \hbar\omega H, \quad \tilde{a} = a .
\]
</p>

<p>
For convenience let us also define the number operator \(N=a^\dagger a = H-1/2\). Clearly
the number operator has the same eigenstates as \(H\). The corresponding eigenvalues are
shifted by \(1/2\).
</p>

<p>
<a id="org4aefff8"></a>
</p>
<dl class="org-dl">
<dt>Theorem (Spectrum of 1D Harmonic Oscillator)</dt><dd><p>
Let
</p>

<p>
\[ \ket{0} = \frac{1}{\sqrt{2\pi}} e^{-x^2 / 2} , \]
</p>

<p>
and
</p>

<p>
\[ \ket{n} = \frac{(a^\dagger)^n}{\sqrt{n!}} \ket{0} , \]
</p>

<p>
for \(n\in\{1,2,\ldots\}\). These states form a complete orthonormal set of the Hilbert
space \(L^2 (\RR)\) of square integrable functions. Moreover they are eigenstates of \(H\)
and \(N\) with \(N\ket{n}=n\ket{n}\).
</p>
<dl class="org-dl">
<dt>Remark</dt><dd><a id="org120aced"></a> It is well known that the gaussian function which
defines \(\ket{0}\) is already normalized (see <a href="https://en.wikipedia.org/wiki/Gaussian_integral">gaussian integral</a>).</dd>
<dt>Proof</dt><dd>See <a href="#exercise-7.4-proof">solution of exercise 7.4</a>.</dd>
</dl></dd>
</dl>
</div>
</div>

<div id="outline-container-org3b7b6c2" class="outline-3">
<h3 id="org3b7b6c2">Optical photon quantum computers</h3>
<div class="outline-text-3" id="text-org3b7b6c2">
<p>
The book showed that the beamsplitter \(B=e^{\theta(ab^\dagger-a^\dagger b)}\) acts as
follows on the dual-rail representation
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org84e9fae"><span class="org-variable-name">theta</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'theta'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
<span class="org-variable-name">B</span> <span class="org-operator">=</span> matrix([[cos(theta), <span class="org-operator">-</span>sin(theta)], [sin(theta), cos(theta)]])
</pre>
</div>

<p>
This essentially follows from these commutation relations:
</p>

<p>
<a id="org7e40d26"></a>
\[
  BaB^\dagger = a \cos(\theta) + b \sin(\theta)
  \quad \text{and} \quad
  BbB^\dagger = b \cos(\theta) - a \sin(\theta) .
\]
</p>
</div>
</div>

<div id="outline-container-discussion-annoying-error" class="outline-3">
<h3 id="discussion-annoying-error">Discussion of an annoying error</h3>
<div class="outline-text-3" id="text-discussion-annoying-error">
<p>
I <i>think</i> that (7.66):
</p>

<p>
\[ H_{\mathrm{atom}}=\hbar\omega_0Z/2 \]
</p>

<p>
is not correct. The state \(\ket{1}\) (for the atom) is considered (by the book) the
"excited" state after absorbtion of a photon. Clearly this should correspond to a higher
energy (than that of \(\ket{0}\)) but this is not the case with this Hamiltonian.
</p>

<p>
One way to resolve the issue is to consider \(\ket{0}\) to the be excited state. I would be
definitely confused by this. Another solution might be to replace the Pauli matrices by
</p>

<p>
\[
  X' = XXX = X, Y' = XYX = -Y, \text{ and } Z' = XZX = -Z .
\]
</p>

<p>
These modified Pauli matrices still satisfy the following algebraic identities
</p>

<p>
\[
  X^2 = Y^2 = Z^2 = -\ii XYZ = I
\]
</p>

<p>
Note that these identities essentially characterize the <i>Quaternions</i> (using
\(I\in\CC^{2\times2}\) as the unit and \(-\ii\,X\), \(-\ii\,Y\), and \(-\ii\,Z\) as the imaginary
units). This is important for the interpretation of the Pauli-rotations as actual
rotations in \(\RR^3\).
</p>

<p>
In particular the commutation relations \([\sigma_i,\sigma_j]=2\ii\epsilon_{ijk}\sigma_k\)
hold. I didn't do this conversion in the exercises in part because I was not aware of the
error when I started to solve the exercises. But some inconsistencies in the exercises
made me suspecting that something is wrong and lead me to the formula for
\(H_{\mathrm{atom}}\).
</p>

<p>
In some of the exercises I just ignore this error. In other exercises I try to circumvent
the error by swapping zeros and ones. In any case, if I do not ignore the error I say so
within the exercise.
</p>
</div>
</div>

<div id="outline-container-chapter-7-state-tomography" class="outline-3">
<h3 id="chapter-7-state-tomography">On magnetization readout and state tomography</h3>
<div class="outline-text-3" id="text-chapter-7-state-tomography">
<p>
The treatment of the magnetization readout in the book looks a bit odd to me. On the one
hand I wonder why in (7.143) only one qubit is involved. On the other hand there is an
inconsistency in <a href="#exercise-7.45">exercise 7.45</a>. In short: I didn't understand a lot of things.
</p>

<p>
In the following I present an alternative to the chapters <i>magnetization readout</i> within
section 7.7.2, and <i>state tomography</i> within section 7.7.4. It is based on
(Jae-Seung Lee, 2002).
</p>

<p>
Let \(\sigma_k^{-}=(X_k+\ii Y_k)/2\) be the Pauli lowering operator for spin \(k\). For a
Hamiltonian \(H\) let \(U(t)=e^{-\ii\,Ht}\) be its evolution operator. Let us write \(U\) for
\(U(t)\). The free induction decay signal is given by (for some non-zero constant \(V_0\))
</p>

<p>
\[
  V(t) = V_0 \trace{U\rho U^\dagger \sum_k\sigma_k^-} .
\]
</p>

<p>
The <i>main</i> difference to (7.143) is the sum over <i>all</i> spins. Using cyclicity property of
traces we get
</p>

<p>
\[
  V(t) = V_0 \trace{\rho \cdot \underbrace{U^\dagger \sum_k\sigma_k^- U}_{=:A}} .
\]
</p>

<p>
Let us consider the single-spin case now. In this case the system Hamiltonian is
\(H=\frac{\omega}{2}Z\). Using the following sage code &#x2026;
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">w</span>, <span class="org-variable-name">t</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'&#969; t'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
<span class="org-variable-name">U1</span> <span class="org-operator">=</span> matrix.diagonal([exp(<span class="org-operator">-</span>i<span class="org-operator">*</span>w<span class="org-operator">*</span>t<span class="org-operator">/</span>2), exp(<span class="org-operator">+</span>i<span class="org-operator">*</span>w<span class="org-operator">*</span>t<span class="org-operator">/</span>2)])

<span class="org-variable-name">sm</span> <span class="org-operator">=</span> (X <span class="org-operator">+</span> i<span class="org-operator">*</span>Y) <span class="org-operator">/</span> 2
<span class="org-variable-name">sp</span> <span class="org-operator">=</span> (X <span class="org-operator">-</span> i<span class="org-operator">*</span>Y) <span class="org-operator">/</span> 2
</pre>
</div>

<p>
&#x2026; it is easy to find a formula for \(A\):
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> U1.H <span class="org-operator">*</span> sm <span class="org-operator">*</span> U1 <span class="org-operator">==</span> e<span class="org-operator">^</span>(I<span class="org-operator">*</span>t<span class="org-operator">*</span>w) <span class="org-operator">*</span> sm
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
That is (for \(H=\frac{\omega}{2}Z\)):
</p>

<p>
\[
  U^\dagger \sigma^- U = e^{\ii \omega t} \sigma^- .
\]
</p>

<p>
Hence for the single spin case we have the following signal
</p>

<p>
<a id="orgfce6071"></a>
\[
  V_1(t) = V_0 \trace{\rho\sigma^-} e^{\ii \omega t} .
\]
</p>

<p>
This also explains why this signal is Fourier transformed. In fact, the fourier transform
would be a delta distribution at \(\omega\). For actual measurements one would expect a
sharp peak at \(\omega\). Unfortunately I didn't get this valuable insight from the book.
</p>

<p>
How do we use this formula to obtain \(\rho\)? Recall that any mixed state can be
represented as
</p>

<p>
\[
  \rho = \frac{1}{2} I + r_x X + r_y Y + r_z Z
\]
</p>

<p>
for some real vector \(\vec{r}=(r_x,r_y,r_z)\) with \(\norm{\vec{r}}\leq1\) (the state is pure
if the norm is exactly one). The task is to determine \(\vec{r}\). Plugging this into <a href="#orgfce6071">the
formula</a> above and using the orthogonality of the Pauli matrices with respect to the
scalar product \(A,B\mapsto\trace{A^\dagger\cdot\,B}\) we get
</p>

<p>
\[
  V_1(t) = V_0 (r_x + \ii r_y) e^{\ii\omega t} .
\]
</p>

<p>
Pretending that we know \(V_0\) this is enough to obtain \(r_x\) and \(r_y\). How do we obtain
\(r_z\)? This can be accomplished by evolving \(\rho\) by \(R_x\) or \(R_y\), that is, an RF pulse
by 90 degrees around X or Y. For a unitary \(M\) let us define
</p>

<p>
\[
  V^M(t) = V_0 \trace{U M\rho M^\dagger U^\dagger \sum_k\sigma_k^-} .
\]
</p>

<p>
Hence
</p>

<p>
\[
  V_1^M(t) = V_0 \trace{(M \rho M^\dagger) \sigma^-} e^{\ii \omega t} .
\]
</p>

<p>
Note that
</p>

<p>
\[
  R_x X R_x^\dagger = X, \quad R_x Y R_x^\dagger = Z, \quad R_x Z R_x^\dagger = -Y ,
\]
</p>

<p>
and
</p>

<p>
\[
  R_y X R_y^\dagger = -Z, \quad R_y Y R_y^\dagger = Y, \quad R_y Z R_y^\dagger = X .
\]
</p>

<p>
Hence
</p>

\begin{align*}
  V_1^{I}(t) &= (r_x + \ii r_y) e^{\ii\omega t} , \\
  V_1^{R_x}(t) &= (r_x - \ii r_z) e^{\ii\omega t} , \\
  V_1^{R_y}(t) &= (r_z + \ii r_y) e^{\ii\omega t} .
\end{align*}

<p>
We see that two of the three experiments corresponding to \(\{I,R_x,R_y\}\) are sufficient
to determine \(\rho\) via state tomography.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf9663c3" class="outline-2">
<h2 id="orgf9663c3">Exercises</h2>
<div class="outline-text-2" id="text-orgf9663c3">
</div>
<div id="outline-container-org5b762d3" class="outline-3">
<h3 id="org5b762d3">Exercise 7.1</h3>
<div class="outline-text-3" id="text-org5b762d3">
<p>
Using the fact that \(x\) and \(p\) do not commute, and that in fact \([x,p]=\ii\,\hbar\),
explicitly show that \(a^\dagger\,a=H/\hbar\omega-1/2\).
</p>
</div>

<div id="outline-container-org52f39d4" class="outline-4">
<h4 id="org52f39d4">Solution</h4>
<div class="outline-text-4" id="text-org52f39d4">
<p>
This is just boring algebra which can be done much faster (and more reliably) by <i>sage</i>:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org09af11a"><span class="org-keyword">assert</span> ad <span class="org-operator">*</span> a <span class="org-operator">==</span> H_qho <span class="org-operator">-</span> 1<span class="org-operator">/</span>2
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>
</div>

<div id="outline-container-exercise-7.2" class="outline-3">
<h3 id="exercise-7.2">Exercise 7.2</h3>
<div class="outline-text-3" id="text-exercise-7.2">
<p>
Given that \([x,p]=\ii\,\hbar\), compute \([a,a^\dagger]\).
</p>
</div>

<div id="outline-container-org64977be" class="outline-4">
<h4 id="org64977be">Solution</h4>
<div class="outline-text-4" id="text-org64977be">
<p>
The unitless result is \(1\):
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org0ecd9fc">com(a, ad)
</pre>
</div>

<pre class="example">
1
</pre>


<p>
Since the <a href="#orgf5a1906">creator/annihilator is already unit-less</a> the same is true with units.
</p>
</div>
</div>
</div>

<div id="outline-container-org1c1a5bd" class="outline-3">
<h3 id="org1c1a5bd">Exercise 7.3</h3>
<div class="outline-text-3" id="text-org1c1a5bd">
<p>
Compute \([H,a]\) and use the result to show that if \(\ket{\psi}\) is an eigenstate of \(H\)
with energy \(E\geq n\hbar\omega\), then \(a^n\ket{\psi}\) is an eigenstate with energy
\(E-n\hbar\omega\).
</p>
</div>

<div id="outline-container-org5cec167" class="outline-4">
<h4 id="org5cec167">Solution</h4>
<div class="outline-text-4" id="text-org5cec167">
<p>
Using \([a^\dagger,a]=-[a,a^\dagger]=-1\) (see <a href="#exercise-7.2">exercise 7.2</a>) we deduce (assuming unit-less quantities)
</p>

<p>
\[
  [H,a] = [a^\dagger a, a] = (a^\dagger a - a a^\dagger) a = [a^\dagger,a] a = -a .
\]
</p>

<p>
Using this we get
</p>

\begin{align*}
  H a^n \ket{\psi} &= (Ha) a^{n-1} \ket{\psi} \\
  &= ([H,a] + aH)a^{n-1} \ket{\psi} \\
  &= (-a^n + a H a^{n-1}) \ket{\psi} \\
  &= a H a^{n-1} \ket{\psi} - a^n \ket{\psi} .
\end{align*}

<p>
Recall that we want to show that \(Ha^n\ket{\psi}=(E-n)a^n\ket{\psi}\) for all natural
numbers \(n\leq E\). Using the above calculation we can prove this by induction. In fact,
for \(n=0\) the assertion is trivial. For \(n>0\) we may use the above calculation together
with the assertion for \(n-1\):
</p>

<p>
\[
  H a^n \ket{\psi} = a(E-n+1)a^{n-1}\ket{\psi} - a^n \ket{\psi} = (E-n)a^n\ket{\psi} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org9ac0eb2" class="outline-3">
<h3 id="org9ac0eb2">Exercise 7.4</h3>
<div class="outline-text-3" id="text-org9ac0eb2">
<p>
Show that \(\ket{n}=\frac{(a^\dagger)^n}{\sqrt{n!}}\ket{0}\).
</p>
</div>

<div id="outline-container-exercise-7.4-proof" class="outline-4">
<h4 id="exercise-7.4-proof">Proof</h4>
<div class="outline-text-4" id="text-exercise-7.4-proof">
<p>
The exercise statement is rather "vague" (I try to be friendly here 😉), so let us prove
some definite statement like the <a href="#org4aefff8">theorem about the spectrum of the harmonic oscillator</a>
instead.
</p>

<p>
To find the <i>ground state</i> consider
</p>

<p>
\[
  \bra{\phi} N \ket{\phi} = \norm{a\phi}^2 \geq 0 .
\]
</p>

<p>
Equality holds iff
</p>

<p>
\[
  x \phi(x) + \phi'(x) = \sqrt{2} \cdot (a\phi)(x) = 0 .
\]
</p>

<p>
This is a linear ordinary differential equation. One solution is given by
\(x\mapsto\exp(-x^2/2)\), which can be easily checked by plugging this in. We do not need
this fact (since it follows automatically later on) but the solution is unique up to a
scalar factor, which can be seen by observing that the ODE is equivalent to
\(\partial_x\log(\phi(x))=-x\).
</p>

<p>
The factor \(1/\sqrt{2\pi}\) in the definition of \(\ket{0}\) <a href="#org120aced">ensures normalization</a>. We thus
proved \(N\ket{0}=0\). Next let us verify that \(\ket{n}\) is an eigenvector. To simplify the
notation let us define \(\ket{n'}:=\sqrt{n!}\ket{n}\).
</p>

<p>
\[
  N\ket{n'} = a^\dagger a (a^\dagger)^n \ket{0} .
\]
</p>

<p>
By using \([a,a^\dagger]=1\) (<a href="#exercise-7.2">exercise 7.2</a>) we may move the single \(a\) to the right and then
use \(a\ket{0}=0\) (this procedure is just simple example of mathematical induction). This
leads to
</p>

<p>
\[
  N\ket{n'} = n (a^\dagger)^n \ket{0} = n \ket{n'} ,
\]
</p>

<p>
hence establishing that \(\ket{n'}\) (and \(\ket{n}\)) is an eigenvector for the eigenvalue
\(n\). To see that the \(1/\sqrt{n!}\) in the definition of \(\ket{n}\) is indeed the right
normalization factor use the freshly proved equality \(N\ket{n'}=n\ket{n'}\) and consider
(don't forget \([a,a^\dagger]=1\))
</p>

<p>
\[
  \norm{(n+1)'}^2 = \bra{n'} a a^\dagger \ket{n'}
  = \bra{n'} N + 1 \ket{n'}
  = (n+1) \norm{n'}^2 .
\]
</p>

<p>
Hence, since \(\ket{0}\) is already normalized mathematical induction shows that \(\ket{n}\)
is normalized too.
</p>

<p>
It remains to show that the \((\ket{n})\) generate the whole Hilbert space (completeness),
since orthogonality already follows from the fact that they are eigenstates to <i>different</i>
eigenvalues of some (unbounded) self-adjoint operator. This essentially boils down to show
that finite linear combinations of the eigenstates are dense in \(L^2(\RR)\).
</p>

<p>
We only sketch the proof since this reaches out to other parts of mathematics. First of
all observe that
</p>

<p>
\[
  \ket{n}(x) = \frac{1}{\sqrt{2\pi}} \; p_n(x) \; e^{-x^2/2} ,
\]
</p>

<p>
where the \(p_n(x)\) are polynomials which satisfy the recursive relation
</p>

<p>
\[ p_{n+1}(x)=(2x+\partial_x)p_n(x), \quad p_0(x) = 1 . \]
</p>

<p>
These are the well-known <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">hermite polynomials</a>. From the recursive relation we directly see
(inductively) the <i>for our purpose important</i> property that \(p_n\) has degree \(n\) (with
leading factor \(2^n\)). The density now follows from the following well known results
</p>

<ol class="org-ol">
<li><a id="org5a9608f"></a> The compactly supported continuous functions are dense in
\(L^2(\RR)\). I do not have a good resource on that but one way to see this is by a
method called <i><a href="https://en.wikipedia.org/wiki/Mollifier">mollification</a></i>.</li>
<li><a id="org5d8d734"></a> For any finite interval \(I\) the polynomials on that
interval are dense in the continuous function on \(I\) with respect to the
$L^&infin;$-norm which is stronger than the \(L^2\) norm (since the interval is
finite). This is the <a href="https://en.wikipedia.org/wiki/Stone%E2%80%93Weierstrass_theorem">Stone-Weierstrass Theorem</a>.</li>
</ol>

<p>
By <a href="#org5d8d734">2</a> finite linear combinations of eigenstates can approximate any
compactly supported continuous function. Here it is important that any degree is
represented among the eigenstates. It should be obvious that the factor \(e^{-x^2/2}\) does
not disturb this argument at all. Now completeness directly follows from
<a href="#org5a9608f">1</a>. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org2094e89" class="outline-3">
<h3 id="org2094e89">Exercise 7.5</h3>
<div class="outline-text-3" id="text-org2094e89">
<p>
Verify that Equations (7.11) and (7.12) are consistent with (7.10) and the normalization
condition \(\norm{\ket{n}}^2=1\).
</p>
</div>

<div id="outline-container-org3344337" class="outline-4">
<h4 id="org3344337">Solution</h4>
<div class="outline-text-4" id="text-org3344337">
<p>
It is not hard to see that (7.11) and (7.12) imply (7.10):
</p>

<p>
\[
  a^\dagger a \ket{n} = a^\dagger \sqrt{n} \ket{n-1} = n \ket{n} .
\]
</p>

<p>
The normalization condition is not relevant here. So it is indeed true that it is
consistent with the three equations but for trivial reasons.
</p>
</div>
</div>
</div>

<div id="outline-container-org60a18ac" class="outline-3">
<h3 id="org60a18ac">Exercise 7.6 (Eigenstates of photon annihilation)</h3>
<div class="outline-text-3" id="text-org60a18ac">
<p>
Prove that a coherent state is an eigenstate of the photon annihilation operator, that is,
show \(a\ket{\alpha}=\lambda\ket{\alpha}\) for some constant \(\lambda\).
</p>
</div>

<div id="outline-container-org34cba43" class="outline-4">
<h4 id="org34cba43">Proof</h4>
<div class="outline-text-4" id="text-org34cba43">
<p>
Recall that \(a\ket{n}=\sqrt{n}\ket{n-1}\) for \(n\geq1\) and \(a\ket{0}=0\). Hence
</p>

<p>
\[
  a\ket{\alpha} = e^{-\abs{\alpha}/2} \sum_n \frac{\alpha^n}{\sqrt{n}} \, a \, \ket{n}
  = e^{-\abs{\alpha}/2} \sum_n \frac{\alpha^{n+1}}{\sqrt{n}} \ket{n}
  = \alpha \ket{\alpha} .
\]
</p>

<p>
The claim follows with \(\lambda=\alpha\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd6102a2" class="outline-3">
<h3 id="orgd6102a2">Exercise 7.7</h3>
<div class="outline-text-3" id="text-orgd6102a2">
<p>
Show that the circuit below transforms a dual-rail state by
</p>

<p>
\[
  \ket{\psi_{\mathrm{out}}} = \begin{bmatrix} e^{\ii\pi} & 0 \\ 0 & 1 \end{bmatrix} \ket{\psi_{\mathrm{in}}} .
\]
</p>

<p>
if we take the top wire to represent the \(\ket{01}\) mode, and \(\ket{10}\) the bottom mode,
and the boxed \(\pi\) to represent a phase shift by \(\pi\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The book contains a picture showing the circuit.</dd>
</dl>
</div>

<div id="outline-container-orgfebab36" class="outline-4">
<h4 id="orgfebab36">Solution</h4>
<div class="outline-text-4" id="text-orgfebab36">
<p>
By definition the circuit acts like this (we use \(e^{\ii\pi}=-1\) to simplify notation):
</p>

<p>
\[
  \ket{0_L} = \ket{01} \mapsto -\ket{0_L}, \quad
  \ket{1_L} = \ket{10} \mapsto \ket{1_L}.
\]
</p>

<p>
The matrix representing this linear transformation with respect to the basis
\((\ket{0_L},\ket{1_L})\) (the order is important) is
</p>

\begin{bmatrix} -1 & 0 \\ 0 & 1 \end{bmatrix}

<p>
as desired.
</p>
</div>
</div>
</div>

<div id="outline-container-org76a7a9b" class="outline-3">
<h3 id="org76a7a9b">Exercise 7.8</h3>
<div class="outline-text-3" id="text-org76a7a9b">
<p>
Show that \(P\ket{\alpha}=\ket{\alpha e^{\ii\Delta}}\) where \(\ket{\alpha}\) is a coherent
state (note that, in general, \(\alpha\) is a complex number!).
</p>
</div>

<div id="outline-container-org5fa67de" class="outline-4">
<h4 id="org5fa67de">Proof</h4>
<div class="outline-text-4" id="text-org5fa67de">
<p>
The phase shift operator is given by \(P\ket{n}=e^{\ii n\Delta}\ket{n}\). Hence, using \(\abs{e^{\ii\Delta}}=1\)
</p>

<p>
\[
P\ket{\alpha} = e^{-\abs{\alpha}^2/2} \sum_n \frac{\alpha^n \, e^{\ii n\Delta}}{\sqrt{n!}} \ket{n}
= \ket{\alpha e^{\ii\Delta}} .
\]
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb9be0d1" class="outline-3">
<h3 id="orgb9be0d1">Exercise 7.9 (Optical Hadamard gate)</h3>
<div class="outline-text-3" id="text-orgb9be0d1">
<p>
Show that the following circuit acts as a Hadamard gate on dual-rail single photon states,
that is, \(\ket{01}\mapsto(\ket{01}+\ket{10})/\sqrt{2}\) and
\(\ket{10}\mapsto(\ket{01}-\ket{10})/\sqrt{2}\) up to an overall phase.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The book contains a picture showing the circuit.</dd>
</dl>
</div>

<div id="outline-container-orgd9ff10a" class="outline-4">
<h4 id="orgd9ff10a">Solution</h4>
<div class="outline-text-4" id="text-orgd9ff10a">
<p>
Assuming evolution from left to right the circuit implements \(ZB_{\theta=\pi/4}\) (note
that the phase shift is \(Z\) up to a global phase). Below you can see that then the
assertion of the exercise is wrong. We give two alternatives instead.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">B0</span> <span class="org-operator">=</span> B.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>4)
<span class="org-variable-name">B1</span> <span class="org-operator">=</span> B.subs(theta<span class="org-operator">=-</span>pi<span class="org-operator">/</span>4)

<span class="org-comment-delimiter"># </span><span class="org-comment">This shows that the original circuit does not implement H, not even if we neglect a</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">global phase</span>
f<span class="org-string">"sqrt(2)*H != </span>{sqrt(2) <span class="org-operator">*</span> Z <span class="org-operator">*</span> B0}<span class="org-string">"</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">These alternatives implement the Hadamard gate:</span>
<span class="org-keyword">assert</span> B0 <span class="org-operator">*</span> Z <span class="org-operator">==</span> H
<span class="org-keyword">assert</span> Z <span class="org-operator">*</span> B1 <span class="org-operator">==</span> H
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'sqrt(2)*H != [ 1 -1]\n[-1 -1]'
'PASSED'
</pre>
</div>
</div>
</div>

<div id="outline-container-org779f3d8" class="outline-3">
<h3 id="org779f3d8">Exercise 7.10 (Mach–Zehnder interferometer)</h3>
<div class="outline-text-3" id="text-org779f3d8">
<p>
Interferometers are optical tools used to measure small phase shifts, which are
constructed from two beamsplitters. Their basic principle of operation can be understood
by this simple exercise.
</p>


<ol class="org-ol">
<li><p>
Note that this circuit performs the identity operation:
</p>

<p>
\[ B_{\theta=\pi/4}^\dagger \cdot B_{\theta=\pi/4} \]
</p></li>
<li><p>
Compute the rotation operation (on dual-rail states) which this circuit performs, as a
function of the phase shift \(\varphi\):
</p>

<p>
\[ B_{\theta=\pi/4}^\dagger \cdot R_z(-\varphi) \cdot B_{\theta=\pi/4} \]
</p></li>
</ol>


<dl class="org-dl">
<dt>Remark</dt><dd>The book contains actual circuits drawings instead of algebraic
expressions. The second expression neglects the global phase (as is common).</dd>
</dl>
</div>


<div id="outline-container-orgab17d5b" class="outline-4">
<h4 id="orgab17d5b">Solution</h4>
<div class="outline-text-4" id="text-orgab17d5b">
<p>
Recall that we have \(B=B(\theta)=R_y(2\theta)\). Hence \(B_{\theta=\pi/4}\) is a rotation
around the y-axis by ninety degrees. This maps the x-axis onto the reversed z-axsis. Hence
the (reversed) z-rotation in the middle effectively acts like a rotation around the x-axis
by an angle \(+\varphi\). The net result is \(R_x(\varphi)\).
</p>

<p>
Such reasoning easily leads to subtle errors. Therefore let us verify this using sagemath:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">B0</span> <span class="org-operator">=</span> B.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>4)
<span class="org-variable-name">phi</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'phi'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)

<span class="org-keyword">assert</span> B0.H <span class="org-operator">*</span> Rz.subs(theta<span class="org-operator">=-</span>phi) <span class="org-operator">*</span> B0 <span class="org-operator">==</span> Rx.subs(theta<span class="org-operator">=</span>phi)
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
It worked out 😎!
</p>
</div>
</div>
</div>

<div id="outline-container-orgb328f59" class="outline-3">
<h3 id="orgb328f59">Exercise 7.11</h3>
<div class="outline-text-3" id="text-orgb328f59">
<p>
What is \(B\ket{2,0}\) for \(\theta=\pi/4\)?
</p>
</div>

<div id="outline-container-org6a1e5fe" class="outline-4">
<h4 id="org6a1e5fe">Solution</h4>
<div class="outline-text-4" id="text-org6a1e5fe">
<p>
Following the book we basically identify states with products of creation operators and
then use the <a href="#org7e40d26">commutation relations</a> for the beamsplitter and \(B\ket{0,0}=\ket{0,0}\):
</p>

<p>
\[
  B\ket{2,0} = \frac{1}{\sqrt{2}} B (a^\dagger)^2 \ket{0,0}
  = \frac{1}{\sqrt{2}} \left(a^\dagger \cos(\theta) + b^\dagger \sin(\theta) \right)^2 \ket{0,0} .
\]
</p>

<p>
Now it helps that \(a^\dagger\) and \(b^\dagger\) commute, which implies
</p>

<p>
\[
  \left(a^\dagger \cos(\theta) + b^\dagger \sin(\theta) \right)^2
  = (a^\dagger)^2 \cos(\theta)^2 + (b^\dagger)^2 \sin(\theta)^2 + 2a^\dagger b^\dagger \sin(\theta)\cos(\theta) .
\]
</p>

<p>
Using \(2\sin(x)\cos(x)=\sin(2x)\) we obtain:
</p>

<p>
\[
  B\ket{2,0} = \cos(\theta)^2 \ket{2,0} + \sin(\theta)^2 \ket{0,2} +
  \frac{\sin(2\theta)}{\sqrt{2}} \ket{1,1} .
\]
</p>

<p>
Plugging in \(\theta=\pi/4\) we obtain
</p>

<p>
\[
  B_{\theta=\pi/4} \ket{2,0} = \frac{1}{2} \ket{2,0} + \frac{1}{2} \ket{0,2} +
  \frac{1}{\sqrt{2}} \ket{1,1}
\]
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-7.12" class="outline-3">
<h3 id="exercise-7.12">Exercise 7.12 (Quantum beamsplitter with classical inputs)</h3>
<div class="outline-text-3" id="text-exercise-7.12">
<p>
What is \(B\ket{\alpha,\beta}\) where \(\ket{\alpha}\) and \(\ket{\beta}\) are two coherent
states as in Equation (7.16)? (Hint: recall that
\(\ket{n}=\frac{(a^\dagger)^n}{\sqrt{n!}}\ket{0}\).)
</p>
</div>

<div id="outline-container-org3e2b19a" class="outline-4">
<h4 id="org3e2b19a">Solution</h4>
<div class="outline-text-4" id="text-org3e2b19a">
<p>
Observe that
</p>

<p>
\[
  \ket{\alpha} = e^{-\abs{\alpha}^2/2} \sum_n \frac{\alpha^n}{\sqrt{n!}} \ket{n}
  = e^{\alpha a^\dagger - \abs{\alpha}^2/2} \ket{0} .
\]
</p>

<p>
There is one subtle thing to note here. The operator \((a^\dagger)\) is neither bounded nor
normal. So it is not clear if \(e^{\alpha a^\dagger}\) is well defined as an
operator.
</p>

<p>
Let us give a sketch of how one might make the exponential function rigorous. Let us
define the (large) Hilbert space spanned by the \(\ket{n}\) but with scalar product
(implicitly) defined by \(\sprod{n}{n}_1=(n!)\inv\). With respect to this Hilbert space
\(a^\dagger\) is bounded. Hence we can define \(e^{\alpha a^\dagger}\) by the usual
exponential series (we need the space for convergence).
</p>

<p>
Another way to deal with the problem is to just see it as an abbreviation. In fact, we
only ever apply such operators to \(\ket{0,0}\).
</p>

<p>
In the following let us abreviate \(K=e^{-(\abs{\alpha}^2+\abs{\beta}^2)/2}\),
\(c=\cos(\theta)\), and \(s=\sin(\theta)\). Now let us go on with the calculation:
</p>

\begin{align*}
  B \ket{\alpha,\beta}
  &= K B e^{\alpha a^\dagger + \beta b^\dagger} \ket{0,0} \\
  &= K B e^{\alpha a^\dagger + \beta b^\dagger} B^\dagger B \ket{0,0} \\
  &= K \exp(\alpha B a^\dagger B^\dagger + \beta B b^\dagger B^\dagger) \ket{0,0} \\
  &= K \exp(\alpha[ca^\dagger + sb^\dagger] + \beta[cb^\dagger-sa^\dagger]) \ket{0,0} \\
  &= K \exp((\alpha c - \beta s)a^\dagger + (\alpha s + \beta c)b^\dagger) \ket{0,0} \\
  & = \ket{\alpha c - \beta s, \alpha s + \beta c} .
\end{align*}

<p>
Hence the operation of \(B\) on coherent states is again given by a rotation matrix:
</p>

<p>
\[
  B: \begin{pmatrix} \alpha \\ \beta \end{pmatrix} \mapsto
  \begin{bmatrix} c & -s \\ s & c \end{bmatrix} \begin{pmatrix} \alpha \\ \beta \end{pmatrix} .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org2bf4a5c" class="outline-3">
<h3 id="org2bf4a5c">Exercise 7.13 (Optical Deutsch–Jozsa quantum circuit)</h3>
<div class="outline-text-3" id="text-org2bf4a5c">
<p>
In Section 1.4.4 (page 34), we described a quantum circuit for solving the one-bit
Deutsch–Jozsa problem. Here is a version of that circuit for single photon states (in the
dual-rail representation), using beamsplitters, phase shifters, and nonlinear Kerr media:
</p>

<pre class="example">
The book contains a drawing of the circuit at this place.
</pre>


<ol class="org-ol">
<li>Construct circuits for the four possible classical functions \(U_f\) using Fredkin gates and
beamsplitters.</li>
<li>Why are no phase shifters necessary in this construction?</li>
<li>For each \(U_f\) show explicitly how interference can be used to explain how the quantum
algorithm works.</li>
<li>Does this implementation work if the single photon states are replaced by coherent
states?</li>
</ol>
</div>

<div id="outline-container-orgbe897f3" class="outline-4">
<h4 id="orgbe897f3">Solution to 1</h4>
<div class="outline-text-4" id="text-orgbe897f3">
<p>
Recall that \(U_f\) implements the following operation on the logical qubits:
</p>

<p>
\[
  U_f \ket{x,y} = \ket{x,y\oplus f(x)} .
\]
</p>

<p>
Recall from box 7.4 that the optical Fredkin gate
</p>

<p>
\[ \exp\left(\frac{\pi}{2} c^\dagger c (a^\dagger b - b^\dagger a)\right) \]
</p>

<p>
can be used two implement two different logical gates:
</p>

<ul class="org-ul">
<li>A <code>CX</code> gate in the dual-rail representation.</li>
<li>A <code>CSWAP</code> (the <i>actual</i> Fredkin gate) if operating directly on the physical qubits.</li>
</ul>

<p>
There are four possible functions (two constant, two balanced). Let us sketch how to
implement each of them.
</p>

<p>
\[
  f_1(x) = 0, \quad f_2(x) = 1, \quad f_3(x) = x, \quad f_4(x) = \neg x .
\]
</p>

<ol class="org-ol">
<li>\(f(x)=0\) can be implemented trivially by the empty circuit.</li>
<li>\(f(x)=1\) can accomplished by performing <code>X</code> on the second rail. This in turn can be
implemented by a <code>CX</code> and an ancilla initialized to <code>1</code>. We can use the optical Fredkin
gate in the dual-rail representation as mentioned above to do the <code>CX</code>.</li>
<li>\(f(x)=x\) just needs a <code>CX</code> which directly be implemented by the optical Fredkin gate in
the dual rail representation.</li>
<li>\(f(x)=\neg x\) just needs a <code>CX</code> conjugated by <code>X</code> in the control. Both types of gates
can be implemented as shown above.</li>
</ol>

<p>
So overall, we could do this with the <i>optical</i> Fredkin gate alone!
</p>
</div>
</div>

<div id="outline-container-org3e5a934" class="outline-4">
<h4 id="org3e5a934">Solution to 2</h4>
<div class="outline-text-4" id="text-org3e5a934">
<p>
That \(U_f\) can be implemented without phase shifts should be clear since controlled <code>X</code>
gates (this is what the optical Fredkin does on the dual-rail represenation as we have
just seen) are sufficient to implement any boolean function.
</p>

<p>
So let us turn to the question "why" no phase shifts are needed in the rest of the
circuit. More precisely we show that the circuit leads to the same measurement statistics
as the Deutsch-Josza algorithm (and so is identical for all practical purposes). The
circuit implements
</p>

<p>
\[
  B^\dagger \otimes I \cdot U_f \cdot B \otimes B .
\]
</p>

<p>
The original Deutsch-Josza algorithm is the same, but with \(B\) replaced by \(H\). The
initial state \(\ket{01_L}\) is the same. But recall that \(B=B_{\theta=\pi/4}=HZ\). The \(Z\)
would be implemented by a phase shift. But we actually do not need them since in this
particular setting at the intial state they just produce a global phase \(-1\) and at the
final state it does not matter since we measure in the computational base anyway).
</p>
</div>
</div>

<div id="outline-container-org7336ea6" class="outline-4">
<h4 id="org7336ea6">Solution to 3</h4>
<div class="outline-text-4" id="text-org7336ea6">
<p>
Not sure what this exercise even means. If it means to show that the circuit actually
implements the Deutsch-Josza algorithm: then this was done in the solution to 2.
</p>
</div>
</div>

<div id="outline-container-orgc1d317e" class="outline-4">
<h4 id="orgc1d317e">Solution to 4</h4>
<div class="outline-text-4" id="text-orgc1d317e">
<p>
No it does not work with coherent states. No matter how the measurement outcome is
interpreted there is always a non-zero chance of failure for some \(f\) (recall that the
Deutsch-Josza algorithm is one of a few <i>quantum</i> algorithms with a 100% success
probability).
</p>

<p>
To see this consider the constructions of \(U_f\) from part 1 (we need to look at a
particular implemenation since the action on coherent states might be different for
different implementation). We only look at the cases \(f(x)=0\) (constant) and \(f(x)=x\)
(balanced).
</p>

<p>
Let us assume that the intial state is \(\ket{\alpha,\beta,\gamma,\delta}\).  Let us
abbreviate \(\phi_{\pm}=(\gamma\pm\delta)/\sqrt{2}\). In the constant case the final state
is (see <a href="#exercise-7.12">exercise 7.12</a> for the action of beamsplitters on coherent states)
</p>

<p>
\[
  \ket{\alpha, \beta, \phi_-, \phi_+} ,
\]
</p>

<p>
In the balanced case, in addition there is also an <i>optical</i> Fredkin gate applied <code>a</code>, <code>b</code>
with control at <code>d</code>. In this case the final state is:
</p>

<p>
\[
  e^{\frac{\pi}{2} d^\dagger d(a^\dagger b - ab^\dagger)} \ket{\alpha,\beta,\phi_-,\phi_+}
  = e^{-\abs{\phi_+}^2/2} \sum_n \frac{\phi_+^n}{\sqrt{n!}} e^{\frac{\pi n}{2}(a^\dagger b - ab^\dagger)}
    \ket{\alpha,\beta,\phi_-,n} .
\]
</p>

<p>
Note that the Fredkin gate acts as a controlled beamsplitter, and for this particular angle we have
</p>

<p>
\[
  e^{\frac{\pi n}{2}(a^\dagger b - ab^\dagger)} \ket{\alpha,\beta,\phi_-,n} = \begin{cases}
     \ket{\alpha,\beta,\phi_-,n} & \text{for } n \text{ even,} \\
     \ket{-\beta,\alpha,\phi_-,n} & \text{for } n \text{ odd.} \end{cases}
\]
</p>

<p>
Note that there is always a non-zero probability that \(n=0\) (even) is measured in \(d\). In
that case the measurement statistics for the other three rails is the same as for the
constant case. In particular there are measurement results which match both, the constant
and the balanced case. Hence an exact algorithm with 100% success probability is not
possible. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org9340ddd" class="outline-3">
<h3 id="org9340ddd">Exercise 7.14 (Classical cross phase modulation)</h3>
<div class="outline-text-3" id="text-org9340ddd">
<p>
To see that the expected classical behavior of a Kerr medium is obtained from the
deﬁnition of \(K\), Equation (7.41), apply it to two modes, one with a coherent state and
the other in state \(\ket{n}\); that is, show that
</p>

<p>
\[
  K \ket{\alpha}\ket{n} = \ket{\alpha e^{\ii\chi Ln}}\ket{n} .
\]
</p>

<p>
Use this to compute
</p>

\begin{align*}
  \rho_a &= \ptrace{b}{K\ket{\alpha}\ket{\beta}\bra{\beta}\bra{\alpha} K^\dagger} \\
  &= e^{-\abs{\beta}^2} \sum_m \frac{\abs{\beta}^{2m}}{m!} \proj{\alpha e^{\ii\chi Lm}} .
\end{align*}

<p>
and show that the main contribution to the sum is for \(m=\abs{\beta}^2\).
</p>
</div>

<div id="outline-container-org72a78aa" class="outline-4">
<h4 id="org72a78aa">Proof of the first part</h4>
<div class="outline-text-4" id="text-org72a78aa">
<p>
Let us abbreviate \(\xi=\chi L\) and \(J=a^\dagger ab^\dagger b\). We have
</p>

<p>
\[
  \ket{\alpha}\ket{n} = e^{-\abs{\alpha}^2/2} \, (b^\dagger)^n \, e^{\alpha a^\dagger} \ket{0,0} .
\]
</p>

<p>
Hence we are interested to compute
</p>

<p>
\[
  K (b^\dagger)^n \, e^{\alpha a^\dagger} K^\dagger
  = K (b^\dagger)^n K^\dagger \, e^{\alpha K a^\dagger K^\dagger} .
\]
</p>

<p>
By the CBH formula we have
</p>

<p>
\[
  K a^\dagger K^\dagger = \sum_n \frac{(\ii\xi)^n}{n!} [(J)^n,a^\dagger] .
\]
</p>

<p>
For that reason let us look at
</p>

<p>
\[
  [J,a^\dagger] = [a^\dagger a, a^\dagger] b^\dagger b = a^\dagger [a, a^\dagger] b^\dagger b
  = a^\dagger b^\dagger b .
\]
</p>

<p>
Hence the iterated commutator is \([(J)^n,a^\dagger]=a^\dagger(b^\dagger b)^n\). Let
\(P_b=e^{\ii\xi\,b^\dagger\,b}\). Then
</p>

<p>
\[
  K a^\dagger K^\dagger = a^\dagger P_b .
\]
</p>

<p>
Similarly
</p>

<p>
\[
  K b^\dagger K^\dagger = b^\dagger P_a .
\]
</p>

<p>
Therefore
</p>

<p>
\[
  K (b^\dagger)^n \, e^{\alpha a^\dagger} K^\dagger
  = (b^\dagger)^n P_a^n \, e^{\alpha a^\dagger P_b} .
\]
</p>

<p>
Finally, using \(P_a^n\ket{k}=e^{\ii\xi\,nk}\ket{k}\), we obtain
</p>

<p>
\[
  K \ket{\alpha} \ket{n}
  = e^{-\abs{\alpha}^2/2} (b^\dagger)^n P_a^n \, e^{\alpha a^\dagger P_b} \ket{0,0}
  = e^{-\abs{\alpha}^2/2} (b^\dagger)^n \, e^{\alpha e^{\ii\xi\,n} a^\dagger} \ket{0,0}
  = \ket{\alpha e^{\ii\xi\,n}} \ket{n} .
\]
</p>

<p>
QED.
</p>
</div>
</div>

<div id="outline-container-org22a7f19" class="outline-4">
<h4 id="org22a7f19">Proof of the second part</h4>
<div class="outline-text-4" id="text-org22a7f19">
<p>
Using the first part we get
</p>

\begin{align*}
  \rho_b
  &= \sum_{mn} \ptrace{b}{K \ket{\alpha} \frac{\beta^{m+n}}{\sqrt{m!n!}} \ket{m}\bra{n} \bra{\alpha} K^\dagger} \\
  &= \sum_{mn} \ptrace{b}{\ket{\alpha e^{\ii\xi\,m}} \frac{\beta^{m+n}}{\sqrt{m!n!}} \ket{m}\bra{n} \bra{\alpha e^{\ii\xi\,n}}} \\
  &= \sum_{m} \frac{\beta^{2m}}{m!} \proj{\alpha e^{\ii\xi\,m}} .
\end{align*}

<p>
To show the final claim consider the function
</p>

<p>
\[ g(m) = \log(b^{2m}/m!) . \]
</p>

<p>
For simplicity let us assume \(\beta\geq0\) (to avoid writing \(\abs{\beta}\) all the
time). We have to find the maximum of \(g\). I put the logarithm there to simplify
differentiating this function. By Stirlings formula we have
</p>

<p>
\[ g(m) \approx m (1 + 2\log{\beta} - \log{m}) . \]
</p>

<p>
The derivative is \(g'(m)=2\log{\beta}-\log{m}\). This is zero iff \(m=\beta^2\). Hence the
biggest contribution to \(\rho_b\) comes from a state close to \(\ket{\alpha\,e^{\ii\xi\abs{\beta}^2}}\). QED.
</p>
</div>
</div>
</div>
<div id="outline-container-orge435415" class="outline-3">
<h3 id="orge435415">Exercise 7.15</h3>
<div class="outline-text-3" id="text-orge435415">
<p>
Plot (7.55):
</p>

<p>
\[
  P_{\mathrm{cav}}/P_{\mathrm{in}} = \frac{1 - R_1}{\abs{1 + e^{\ii\varphi}\sqrt{R_1R_2}}^2}
\]
</p>

<p>
as a function of field detuning \(\varphi\), for \(R_1=R_2=0.9\).
</p>
</div>

<div id="outline-container-orge3601c3" class="outline-4">
<h4 id="orge3601c3">Solution</h4>
<div class="outline-text-4" id="text-orge3601c3">
<p>
Here is the code to make the plot in <code>sage</code>:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org4fb6230"><span class="org-variable-name">R1</span>, <span class="org-variable-name">R2</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'R1 R2'</span>, domain<span class="org-operator">=</span><span class="org-string">'positive'</span>)
<span class="org-variable-name">phi</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'phi'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)

<span class="org-variable-name">power</span> <span class="org-operator">=</span> (1 <span class="org-operator">-</span> R1) <span class="org-operator">/</span> <span class="org-builtin">abs</span>(1 <span class="org-operator">+</span> exp(i<span class="org-operator">*</span>phi)<span class="org-operator">*</span>sqrt(R1<span class="org-operator">*</span>R2))<span class="org-operator">**</span>2

<span class="org-keyword">def</span> <span class="org-function-name">make_plot_ex715</span>(r1, r2<span class="org-operator">=</span><span class="org-constant">None</span>, interval<span class="org-operator">=</span>(0, 2), <span class="org-operator">**</span>kwargs):
    <span class="org-doc">"""Plot P_cav/P_in according to exercise 7.15 but with s=phi/pi on the x-axis."""</span>
    <span class="org-variable-name">s</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'s'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)
    <span class="org-keyword">return</span> parametric_plot((s, power.subs(phi<span class="org-operator">=</span>pi<span class="org-operator">*</span>s, R1<span class="org-operator">=</span>r1, R2<span class="org-operator">=</span>r2 <span class="org-keyword">or</span> r1)), (s,) <span class="org-operator">+</span> interval, <span class="org-operator">**</span>kwargs)
</pre>
</div>

<p>
You can use it like so:
</p>

<div class="org-src-container">
<pre class="src src-sage">show(make_plot_ex715(0.9, interval<span class="org-operator">=</span>(0.5, 1.5), aspect_ratio<span class="org-operator">=</span><span class="org-string">'automatic'</span>))
</pre>
</div>


<div id="org96b1b71" class="figure">
<p><img src="images/exercise_7_15_plot.png" alt="exercise_7_15_plot.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Fabry-Perot cavity, relative power \(P_{\mathrm{cav}}/P_{\mathrm{in}}\) inside cavity vs \(\varphi/\pi\).</p>
</div>

<p>
As we can see \(P_{\mathrm{cav}}/P_{\mathrm{in}}\) is maximal at \(\varphi=\pi\) with value
\((1-R)^{-1}=10\). Let us also note that at \(\varphi=0\) and \(\varphi=2\pi\) the value is
roughly \((1-R_1)/4\) if \(R_1,R_2\approx1\). Moreover the width of the central peak is around
\(R_1\inv\) as can be easily verified by plugging in the Taylor expansion of
\(e^{\ii\varphi}\) at \(\varphi=\pi\) into the formula for \(P_{\mathrm{cav}}/P_{\mathrm{in}}\).
</p>
</div>
</div>
</div>

<div id="outline-container-org0bc44d9" class="outline-3">
<h3 id="org0bc44d9">Exercise 7.16 (Electric dipole selection rules)</h3>
<div class="outline-text-3" id="text-org0bc44d9">
<p>
Show that (7.60):
</p>

<p>
\[
  \int Y_{l_1m_1}^* Y_{1,\pm1} Y_{l_2m_2} \dd \Omega
\]
</p>

<p>
is non-zero only when \(m_2-m_1=\pm1\) and \(\Delta\,l=\pm1\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
More precisely: Let \(a\in\{+1,-1\}\) and replace the middle function by
\(Y_{1a}\). Then the integral does not vanish if and only if
</p>

<p>
\[
  m_2 - m_1 = a \text{ and } \abs{l_2-l_1} = 1 .
  \]
</p>

<p>
That is, the sign of \(\Delta\,m\) does depend on which of the two \(Y_{1,\pm1}\) is chosen
but the sign of \(\Delta\,l\) does not.
</p></dd>
</dl>
</div>

<div id="outline-container-org5d11a52" class="outline-4">
<h4 id="org5d11a52">Proof</h4>
<div class="outline-text-4" id="text-org5d11a52">
<p>
All relevant functions involve relatively complicated constant factors. Since we are only
interested in the question whether the integral is non-zero or not, let us introduce a
specific notation for this exercise: We write \(a\sim b\) if \(a=cb\) for some <i>non-zero</i> and
<i>constant</i> \(c\). By constant I mean that \(c\) does not depend on \(\theta\) or \(\varphi\) (the
variables we integrate over).
</p>

<p>
Let \(a=\pm1\) and note that \(Y_{1,a}\sim\sin(\theta)e^{a\ii\varphi}\). By
\(\dd\Omega=\sin(\theta)\dd\theta\dd\varphi\) the definition of the spherical harmonics in
terms of the <a href="https://en.wikipedia.org/wiki/Associated_Legendre_polynomials">associated Legendre polynomials</a> we have:
</p>

\begin{align*}
  \int Y_{l_1m_1}^* Y_{1,\pm1} Y_{l_2m_2} \dd \Omega
  &\sim \int_0^{\pi} \int_0^{2\pi} Y_{l_1m_1}^* Y_{l_2m_2} \sin(\theta)^2 e^{a\ii\varphi} \dd\varphi\dd\theta \\
  &\sim \int_{-1}^{+1} \int_{0}^{2\pi} P_{l_1m_1}^*(x) P_{l_2m_2}(x) \sqrt{1-x^2} e^{\ii\varphi(m_2-m_1+a)} \dd\varphi \dd x \\
  &\sim: I_1 .
\end{align*}

<p>
The integral over \(\varphi\) vanishes iff \(m_1=m_2+a\). This already proves the first part
of the exercise. Let \(b=(a+1)/2\). The question now translates to the task to find out when
the following integral vanishes:
</p>

<p>
\[
  I_1 \sim I_2 := \int_{-1}^{+1} (1-x^2)^{m_2+b} \partial_x^{m_2+a+l_1} (x^2-1)^{l_1} \partial_x^{m_2+l_2} (x^2-1)^{l_2} \dd x .
\]
</p>

<p>
Let us rewrite this in terms of the "normal" <a href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre polynomials</a>
\(P_l(x)\sim\partial_x^l(x^2-1)^l\):
</p>

<p>
\[
  I_2 \sim I_3(b) :=
  \int_{-1}^{+1} (1-x^2)^{m_2+b} \partial_x^{m_2+a} P_{l_1}(x) \cdot \partial_x^{m_2} P_{l_2}(x) \dd x .
\]
</p>

<p>
Let us define the differential operator \(D_n=\partial_x^n(1-x^2)^n\partial_x^n\). Moreover,
write \(\tilde{P}_l(x)\sim\partial_x^{l-1}(x^2-1)^l\) (this is the Legendre polynomial of
order \(l\) for \(l\,>\,0\) where one derivative was "stolen"). Integration by parts \(m_2+b\)
times (in one or in the other direction) yields:
</p>

<p>
<a id="org3d8ea6c"></a>
\[
  I_3(b=0) \sim \int_{-1}^{+1} \tilde{P}_{l_1}(x) \cdot D_{m_2} P_{l_2}(x) \dd x .
\]
</p>

<p>
assuming \(l_1\neq0\), and
</p>

<p>
<a id="org7bd3854"></a>
\[
  I_3(b=1) \sim \int_{-1}^{+1} D_{m_2+1} P_{l_1}(x) \cdot \tilde{P}_{l_2}(x) \dd x .
\]
</p>

<p>
assuming \(l_2\neq1\).
</p>

<p>
As said these formulas are only valid for \(l_1\neq0\) or \(l_2\neq0\) respectively. This
however is not a big issue since these special cases are very simple. Let us briefly
consider the case \(b=l_1=0\). It follows that \(m_1=0\) and hence \(m_2=m_1+1=1\) and
\(l_2\geq1\). Hence the integral simplifies to
\(\int(1-x^2)\partial_x\,P_{l_2}(x)\dd\,x\). Using integration by parts (once) we see that
this is only ever non-zero if \(l_2=1\), proving the claim for this special case (we use
that \(P_1(x)\sim\,x\) and take the orthogonality relations for the Legendre polynomials for
granted). The case \(b=1\) is similar.
</p>

<p>
Let us come back to the above formulas for <a href="#org3d8ea6c">\(b=0\)</a> and <a href="#org7bd3854">\(b=1\)</a>. We have the following
</p>

<dl class="org-dl">
<dt>Lemma</dt><dd><p>
<a id="org87751d1"></a> \(P_l\) is an eigenfunction of \(D_n\). More precisely
\(D_nP_l=\lambda_{nl}P_l\) where
</p>

<p>
\[
  \lambda_{nl} = \prod_{j=0}^{n-1} \left( j(j+1) - l(l+1) \right) .
  \]
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>Note that \(\lambda_{nl}=0\) for \(n\geq\,l+1\).</dd>
</dl></dd>
</dl>

<p>
Before we prove the Lemma let us see why this helps us. We only have to consider the case
\(b=0\) since the other case is the same. Using the lemma we see that
</p>

<p>
\[
  I_3(b=0) \sim \int_{-1}^{+1} \tilde{P}_{l_1}(x) \cdot P_{l_2}(x) \dd x .
\]
</p>

<p>
Recall that the Legendre polynomial form an orthogonal (and complete) set of functions of
the Hilbert space \(L^2(-1,+1)\). We will show that the above "skewed" version of the scalar
product is non-zero iff \(\abs{l_1-l_2}=1\) (yes there are two values of \(l_2\) for each
\(l_1\geq1\)).
</p>

<p>
The idea to see this is a case analysis. We use integration by parts below. Please observe
that the reason that no boundary terms are introduced by this is precisely because one of
the derivatives is "missing".
</p>

<dl class="org-dl">
<dt>Case \(l_1\geq\,l_2+1\)</dt><dd><p>
Integration by parts yields
</p>

<p>
\[
  I_3(b=0) \sim \int_{-1}^{+1} (x^2-1)^{l_1} \partial_x^{l_1+l_2-1} (x^2-1)^{l_2} \dd x.
  \]
</p>

<p>
Clearly the term with the many derivatives vanishes if \(l_1\,>\,l_2+1\). On the other
hand it is a constant if \(l_1=l_2+1\). Hence the integral is non-zero iff \(l_1=l_2+1\).
</p></dd>
<dt>Case \(l_2\geq\,l_1+1\)</dt><dd>This case is analogous to the first case. The only difference is
that we move the derivative to the other side. The integral is non-zero iff \(l_2=l_1+1\).</dd>
<dt>Case \(l_1=l_2+1=:l\)</dt><dd><p>
In that case we can move all derivatives to either side and get
</p>

<p>
\[
  I_3(b=0) \sim \int_{-1}^{+1} x(x^2-1)^l = 0,
  \]
</p>

<p>
since the integrand is an odd function (meaning \(f(-x)=-f(x)\)) over a symmetric
interval.
</p></dd>
</dl>

<p>
It remains to do the following
</p>

<dl class="org-dl">
<dt>Proof of the <a href="#org87751d1">lemma</a></dt><dd><p>
We prove this by mathematical induction. The case \(n=0\) is trivial
(\(D_0\) is the identity and \(\lambda_{0l}=1\)). Let us assume the claim for an \(n\geq0\)
and consider
</p>

<p>
\[
  D_{n+1} P_l = \partial_x^{n+1} (1-x^2)^{n+1} \partial_x^{n+1} P_l .
  \]
</p>

<p>
Note that \(D_{n+1}\) consists of three blocks, the left and right one contain only
derivatives and the middle one is a function of the position operator. The idea is to
commute one of the derivatives from the right block through the middle block and
similarly one factor \((1-x^2)\) from the middle block through the left block (including
the one derivative which was moved there from the right block). This should lead to an
expression of the form \((\ldots)D_nP_l\) and we can apply the induction hypothesis.
</p>

<p>
Let us start:
</p>

\begin{align*}
D_{n+1} P_l &= \partial_x^{n+2} (1-x^2)^{n+1} \partial_x^{n} P_l +
    2(n+1)\partial_x^{n+1} x(1-x^2)^{n} \partial_x^{n} P_l \\
&=: A + 2(n+1)B .
\end{align*}

<p>
Next, let us treat \(B\) by commuting the \(x\) to the left:
</p>

\begin{align*}
B &= x\partial_x D_n P_l + (n+1)D_nP_l \\
&= \lambda_{nl} \left(xP_l' + (n+1)P_l \right) .
\end{align*}

<p>
Now we go on with \(A\). We first make a simple thing: just take one of the factors
\((1-x^2)\) and split the some with \(1\) and \(-x^2\):
</p>

\begin{align*}
A &= \partial_x^2 D_n P_l - \partial_x^{n+2} x^2 (1-x^2)^n \partial_x^n P_l \\
&=: \lambda_{nl} P_l'' - A_1 .
\end{align*}

<p>
For \(A_1\) we try to commute the \(x^2\) to the left:
</p>

\begin{align*}
A_1 &= x^2 \partial_x^2 D_nP_l + 2(n+2) x \partial_x D_nP_l + (n+2)(n+1)D_nP_l \\
&= \lambda_{nl} \left(x^2P_l'' + 2(n+2)xP_l' + (n+2)(n+1)P_l  \right) .
\end{align*}

<p>
Gathering what we obtained leads to
</p>

<p>
\[
  D_{n+1} P_l = \lambda_{nl} \left((1-x^2)P_l'' - 2x P_l' + n(n+1) P_l \right) .
  \]
</p>

<p>
Recall <i>Legendre's differential equation</i>:
</p>

<p>
\[
  (1-x^2)P_l'' - 2xP_l' + n(n+1)P_l = 0 .
  \]
</p>

<p>
I won't prove it (it is well known) but let me mention the following. Legendre's
differential equation is actually the special case \(n=1\): \(D_1P_l=-l(l+1)P_l\). I am
confident that one can prove it by induction on \(l\) (I did not check this claim
though). The case \(l=0\) is trivial. The induction step can probably be proved by moving
around derivatives and position operators as we have seen above.
</p>

<p>
Using Legendre's differential equation we obtain
</p>

<p>
\[
  D_{n+1} P_l = \lambda_{nl} \left(n(n+1) - l(l+1)\right) P_l ,
  \]
</p>

<p>
which essentially proves the claim. QED.
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-orgd89e06f" class="outline-4">
<h4 id="orgd89e06f">Appendix</h4>
<div class="outline-text-4" id="text-orgd89e06f">
<p>
Before I finally managed to find the solution to this exercise I had to do a lot of
experiments with sage math. I do not want to collect them all here but let me just give
one example.
</p>

<p>
I was a bit surprised by the fact that the <a href="#org87751d1">lemma</a> should be true. By what the exercise
demanded to show and what I already managed to prove it had to be true. On the other hand
I typically do a lot of mistakes when doing such calculations so I needed a way to verify
the claim for concrete values of \(n\) and \(l\). It turned out that my experiments backed the
lemma and I could go on proving it.
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgde90a13"><span class="org-comment-delimiter"># </span><span class="org-comment">We have to call it xx to not overwrite the position operator.</span>
<span class="org-variable-name">xx</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'x'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)

<span class="org-keyword">def</span> <span class="org-function-name">Pl</span>(l):
    <span class="org-doc">"""Legendre polynomial of order l."""</span>
    <span class="org-variable-name">q</span> <span class="org-operator">=</span> xx<span class="org-operator">^</span>2 <span class="org-operator">-</span> 1
    <span class="org-keyword">return</span> diff(q<span class="org-operator">^</span>l, xx, l)

<span class="org-keyword">def</span> <span class="org-function-name">Dn</span>(f, n<span class="org-operator">=</span>1):
    <span class="org-doc">"""Differential operator dx^n (1-x^2)^n dx^n."""</span>
    <span class="org-keyword">return</span> diff((1<span class="org-operator">-</span>xx<span class="org-operator">^</span>2)<span class="org-operator">^</span>n <span class="org-operator">*</span> diff(f, xx, n), xx, n)


<span class="org-keyword">def</span> <span class="org-function-name">lambda_nl</span>(n, l):
    <span class="org-doc">"""Eigenvalues: DnPl=lambda_nl*Pl."""</span>
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> 1
    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-variable-name">result</span> <span class="org-operator">*=</span> j<span class="org-operator">*</span>(j<span class="org-operator">+</span>1) <span class="org-operator">-</span> l<span class="org-operator">*</span>(l<span class="org-operator">+</span>1)
    <span class="org-keyword">return</span> result
</pre>
</div>

<p>
Test the claim of the lemma:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgfbbbabc"><span class="org-keyword">for</span> l <span class="org-keyword">in</span> <span class="org-builtin">range</span>(6):
    <span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(l<span class="org-operator">+</span>1):
        <span class="org-variable-name">q</span> <span class="org-operator">=</span> Dn(Pl(l), n) <span class="org-operator">-</span> lambda_nl(n, l)<span class="org-operator">*</span>Pl(l)
        <span class="org-keyword">assert</span> q <span class="org-operator">==</span> 0
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>
</div>

<div id="outline-container-org4cf9f17" class="outline-3">
<h3 id="org4cf9f17">Exercise 7.17 (Eigenstates of the Jaynes–Cummings Hamiltonian)</h3>
<div class="outline-text-3" id="text-org4cf9f17">
<p>
Show that
</p>

\begin{align*}
  \ket{\chi_n} &= \frac{1}{\sqrt{2}} \left[ \ket{n,1} + \ket{n+1,0} \right] \\
  \ket{\overline{\chi}_n} &= \frac{1}{\sqrt{2}} \left[ \ket{n,1} - \ket{n+1,0} \right]
\end{align*}

<p>
are eigenstates of the Jaynes–Cummings Hamiltonian (7.71) for \(\omega=\delta=0\), with the
eigenvalues
</p>

\begin{align*}
  H \ket{\chi_n} &= g \sqrt{n+1} \; \ket{\chi_n} \\
  H \ket{\overline{\chi}_n} &= -g \sqrt{n+1} \; \ket{\overline{\chi}_n}
\end{align*}

<p>
where the labels in the ket are \(\ket{\mathrm{field},\mathrm{atom}}\).
</p>
</div>

<div id="outline-container-org454aa83" class="outline-4">
<h4 id="org454aa83">Proof</h4>
<div class="outline-text-4" id="text-org454aa83">
<p>
Recall
</p>

<p>
\[
  \sigma_{+} = \begin{pmatrix} 0 & 0 \\ 1 & 0  \end{pmatrix} \quad \text{and} \quad
  \sigma_{-} = \begin{pmatrix} 0 & 1 \\ 0 & 0  \end{pmatrix} .
\]
</p>

<p>
Using this with the <a href="#org4aefff8">theorem on the ladder operators</a> for the harmonic oscillator yields
</p>

\begin{align*}
  a^\dagger \sigma_{-} \ket{n,1}   &= \sqrt{n+1} \; \ket{n+1,0}, \\
  a^\dagger \sigma_{-} \ket{n+1,0} &= 0, \\
  a \sigma_{+ } \ket{n,1}          &= 0, \\
  a \sigma_{+} \ket{n+1,0}         &= \sqrt{n+1} \; \ket{n,0}.
\end{align*}

<p>
Finally, using this with
</p>

<p>
\[
  H = g ( a^\dagger \sigma_{-} + a \sigma_{+} ) ,
\]
</p>

<p>
yields the claim. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-7.18" class="outline-3">
<h3 id="exercise-7.18">Exercise 7.18 (Rabi oscillations)</h3>
<div class="outline-text-3" id="text-exercise-7.18">
<p>
Show that (7.77):
</p>

\begin{align*}
  U = e^{-\ii Ht} = \; & e^{-\ii\delta t} \proj{00} \\
    &+ \left(\cos(\Omega t) + \ii \frac{\delta}{\Omega} \sin(\Omega t) \right) \proj{01} \\
    &+ \left(\cos(\Omega t) - \ii \frac{\delta}{\Omega} \sin(\Omega t) \right) \proj{10} \\
    &- \ii \frac{g}{\Omega} \sin(\Omega t) \left(\ket{01}\bra{10} + \ket{10}\bra{01}\right) ,
\end{align*}

<p>
(with \(\Omega=\sqrt{g^2+\delta^2}\)) is correct by using
</p>

<p>
\[
  e^{\ii \vec{n}\cdot\vec{\sigma}} = \cos(\abs{\vec{n}}) + \ii \abs{\vec{n}}\inv \, \vec{n}\cdot\vec{\sigma} \cos(\abs{\vec{n}}) .
\]
</p>

<p>
to exponentiate \(H\). This is an unusually simple derivation of the Rabi oscillations and
the Rabi frequency; ordinarily, one solves coupled differential equations to obtain
\(\Omega\), but here we obtain the essential dynamics just by focusing on the single-atom,
single-photon subspace!
</p>

<dl class="org-dl">
<dt>Remarks</dt><dd><ul class="org-ul">
<li>In the original hint the formula for \(e^{\ii\vec{n}\cdot\vec{\sigma}}\) is wrong. I
corrected this here.</li>
<li><p>
The formula (7.76) for \(H\) seems to be wrong (at least if considering (7.77) as
correct). It contains some sign errors and should read
</p>

<p>
\[
    H = \begin{bmatrix} \delta & 0 & 0 \\ 0 & -\delta & g \\ 0 & g & \delta \end{bmatrix}
    \]
</p>

<p>
(as in the book the basis states are \(\ket{00}\), \(\ket{01}\), \(\ket{10}\) with the left
one for the field and the right one for the atom). Recall that \(H\) without \(N\) is
</p>

<p>
\[
      H = \delta Z + g ( a^\dagger \sigma_{-} + a \sigma_{+} ) .
    \]
</p>

<p>
Assuming the standard matrix representation \(\mathrm{diag}(1,-1)\) for \(Z\) this is also
consistent with the above matrix. So at least all this is self-consistent now (does
not mean it is correct though).
</p></li>
</ul></dd>
</dl>
</div>

<div id="outline-container-orgbd01b11" class="outline-4">
<h4 id="orgbd01b11">Proof</h4>
<div class="outline-text-4" id="text-orgbd01b11">
<p>
Observe that \(H\) is block-diagonal
</p>

\begin{bmatrix} H_1 & 0 \\ 0 & H_2 \end{bmatrix}

<p>
with \(H_1=\delta\) and
</p>

<p>
\[
  H_2 = \begin{bmatrix} -\delta & g \\ g & \delta \end{bmatrix} .
\]
</p>

<p>
Hence
</p>

<p>
\[
  e^{-\ii Ht} = \begin{bmatrix} e^{-\ii\delta} & 0 \\ 0 & e^{-\ii H_2} \end{bmatrix} .
\]
</p>

<p>
which already explains the term \(e^{-\ii\delta\,t}\proj{00}\) in the formula we have to
prove. Hence we can restrict our analysis to the sub-space spanned by \(\ket{01}\),
\(\ket{10}\) on which \(H_2\) acts. Note how \(H_2\) can be represented as a sum of Pauli
matrices (where we relabel the two basis vectors by \(0\) and \(1\) respectively to have the
standard matrix representations of these operators):
</p>

<p>
\[
  H_2 = \Omega \left( \frac{g}{\Omega} X - \frac{\delta}{\Omega} Z \right) .
\]
</p>

<p>
Here we factored out \(\Omega\) to make the norm apparent. Using the hint we get
</p>

<p>
\[
  e^{-\ii H_2 t} = \cos(\Omega t) I -
  \ii \left( \frac{g}{\Omega} X - \frac{\delta}{\Omega} Z \right) \sin(\Omega t) .
\]
</p>

<p>
Plugging in \(Z=\proj{01}-\proj{10}\), \(X=\ket{01}\bra{10}+\ket{10}\bra{01}\), and
\(I=\proj{01}+\proj{10}\) yields the claim. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgecc2e1c" class="outline-3">
<h3 id="orgecc2e1c">Exercise 7.19 (Lorentzian absorption profile)</h3>
<div class="outline-text-3" id="text-orgecc2e1c">
<p>
Plot the photon-absorbtion probability (7.79)
</p>

<p>
\[
  \chi_r = \abs{\bra{01}U\ket{10}}^2 = \frac{g^2}{g^2+\delta^2} \sin(\Omega t)^2,
\]
</p>

<p>
for \(t=1\) and \(g=1.2\), as a function of the detuning \(\delta\), and (if you know it)
the corresponding classical result. What are the oscillations due to?
</p>
</div>

<div id="outline-container-org6780ae6" class="outline-4">
<h4 id="org6780ae6">Proof</h4>
<div class="outline-text-4" id="text-org6780ae6">
<p>
First of all observe that for \(\delta\to\infty\) we have the following asymptotics
</p>

<p>
\[
  \chi_r \sim \frac{g^2}{\delta^2} \sin(\delta t)^2 .
\]
</p>

<p>
This is consistent with the following plot:
</p>


<div id="org9ca23f9" class="figure">
<p><img src="images/exercise_7_19_plot.png" alt="exercise_7_19_plot.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Absorbtion probability \(\chi_r\) against \(\delta\) for \(t=1\) and \(g=1.2\).</p>
</div>

<p>
The plot is produced by the following function
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgff541d4"><span class="org-keyword">def</span> <span class="org-function-name">make_plot_ex719</span>(interval<span class="org-operator">=</span>(<span class="org-operator">-</span>15, 15), t<span class="org-operator">=</span>1, g<span class="org-operator">=</span>1.2):
    <span class="org-doc">"""Plot for exercise 7.19."""</span>
    <span class="org-variable-name">d</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'delta'</span>)
    <span class="org-variable-name">Omega2</span> <span class="org-operator">=</span> g<span class="org-operator">^</span>2 <span class="org-operator">+</span> d<span class="org-operator">^</span>2
    <span class="org-variable-name">Omega</span> <span class="org-operator">=</span> sqrt(Omega2)

    <span class="org-variable-name">chi_r</span> <span class="org-operator">=</span> (g<span class="org-operator">^</span>2<span class="org-operator">/</span>Omega2) <span class="org-operator">*</span> sin(Omega<span class="org-operator">*</span>t)<span class="org-operator">^</span>2

    <span class="org-keyword">return</span> parametric_plot((d, chi_r), (d,)<span class="org-operator">+</span>interval, aspect_ratio<span class="org-operator">=</span><span class="org-string">'automatic'</span>)
</pre>
</div>

<p>
Note that the peak of \(\chi_r\) at \(0\) has value \(\sin(g)\approx0.932\). For other values of
\(g\) or \(t\) the maximum is not necessarily at \(\delta=0\).
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-7.20" class="outline-3">
<h3 id="exercise-7.20">Exercise 7.20 (Single photon phase shift)</h3>
<div class="outline-text-3" id="text-exercise-7.20">
<p>
Derive the phase shift of a single photon (7.80)
</p>

<p>
\[
  \chi_i = \arg \left[ e^{\ii\delta t} \left( \cos(\Omega t) -
    \ii \frac{\delta}{\Omega} \sin(\Omega t) \right) \right]
\]
</p>

<p>
from \(U\), and plot it for \(t=1\) and \(g=1.2\), as a function of the detuning
\(\delta\). Compare with \(\delta/\Omega^2\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>In case you wonder, \(\arg(z)\) is the so called <a href="https://en.wikipedia.org/wiki/Argument_(complex_analysis)"><i>argument</i></a> of a complex number
\(z\). Its value is an element of \(\RR/2\pi\) (the unit circle, or in other words, the real
numbers where two numbers are considered equivalent if their difference is an integer
multiple of \(2\pi\)).</dd>
</dl>
</div>

<div id="outline-container-orge367dd3" class="outline-4">
<h4 id="orge367dd3">Solution</h4>
<div class="outline-text-4" id="text-orge367dd3">
<p>
At first I didn't really understand what the authors want (the wording in the main text was
very confusing for me). But reading on I could infer what they meant (hopefully).
</p>

<p>
The task is <i>essentially</i> to find out the phase shift which happens to the single photon
state \(\ket{10}\) if it evolves under \(U=e^{-\ii\,Ht}\) and does not get absorbed (so we
project to \(\ket{10}\)). That is
</p>

<p>
\[
  \arg\left[ \frac{\bra{10}U\ket{10}}{\abs{\bra{10}U\ket{10}}} \right]
  = \arg\left[ \bra{10}U\ket{10} \right] .
\]
</p>

<p>
More precisely the <i>refractive index</i> is the difference of <i>this</i> phase with the analogous
phase change of the \(\ket{00}\) state:
</p>

<p>
\[
  \chi_i = \arg\left[ \bra{10}U\ket{10} \right] - \arg\left[ \bra{00}U\ket{00} \right] .
\]
</p>

<p>
Note that in both cases the atom remains in the ground state. According to (7.77), the
formula for \(U\) this is
</p>

<p>
\[
  \chi_i = \arg \left[\left( \cos(\Omega t) - \ii \frac{\delta}{\Omega} \sin(\Omega t) \right) \right] -
    \arg\left[ e^{-\ii\delta t} \right] .
\]
</p>

<p>
The given formula for \(\chi_i\) follows from \(\arg(z_1z_2)=\arg(z_1)+\arg(z_2)\) (this is
only true in \(\RR/2\pi\), not in \(\RR\)) and \(\arg(z\inv)=-\arg(z)\).
</p>

<p>
It remains to compare this to \(\delta/\Omega^2\) and make a plot. It will turn out that
\(\chi_i\) and \(-\delta/\Omega^2\) "look" very similar. Let us make this more precise by
considering the behavior at \(\delta=0\) and \(\delta=\infty\).
</p>

<p>
Let us write \(a\sim b\) whenever the principle asymptotic behavior is the same as that of
\(b\), that is \(a=b(1+o(1))\) as \(\delta\) goes to zero or infinity (depending on the case).
</p>

<dl class="org-dl">
<dt>Case \(\delta\) near \(0\)</dt><dd><p>
Observe that \(\Omega=g(1+O(\delta^2))\sim g\). Hence (using
\(\arg(x+iy)=\arctan(y/x)\) for \(x\,>\,0\))
</p>

<p>
\[
  \chi_i \sim \arctan\left(- \frac{\delta \sin(gt)}{g \cos(gt)}\right) + \delta t .
  \]
</p>

<p>
Using \(\arctan(x)\sim x\) at zero we see
</p>

<p>
\[
  \chi_i \sim - (g\tan(gt) - g^2 t) \, \frac{\delta}{\Omega^2} .
  \]
</p>

<p>
For our particular values \(g=1.2\) and \(t=1.0\) we have \(\chi_i\approx-1.647\cdot\delta/\Omega^2\) near \(\delta=0\).
</p></dd>
<dt>Case \(\delta\) near \(\infty\)</dt><dd><p>
In this case we have \(\delta/\Omega^2\sim\delta\inv\). Moreover
</p>

<p>
\[
  \Omega = \delta + \frac{g^2}{2\delta} + O(\delta^{-3}) ,
  \]
</p>

<p>
and
</p>

<p>
\[
  \frac{\delta}{\Omega} = 1 - \frac{g^2}{2\delta^2} + O(\delta^{-4}) .
  \]
</p>

<p>
Hence
</p>

\begin{align*}
\chi_i &= \delta t + \arg\left[\cos(\Omega t) - \ii \frac{\delta}{\Omega} \sin(\Omega t)\right] \\
  &= \delta t + \arg\left[ e^{-\Omega t} \right] + O(\delta^{-2}) \\
  &= (\delta - \Omega)t + O(\delta^{-2}) \\
  &= - \frac{g^2 t}{2\delta} + O(\delta^{-2}) \\
  &\sim - \frac{g^2 t}{2} \cdot \frac{\delta}{\Omega^2} .
\end{align*}

<p>
For our particular values \(g=1.2\) and \(t=1.0\) we have
\(\chi_i\approx-0.72\cdot\delta/\Omega^2\) near \(\delta=\infty\).
</p></dd>
</dl>

<p>
In the plot below we show how well these approximations work. Even for the intermediate
zone away from \(0\) and \(\infty\) the approximation works well at the <i>qualitative</i> level
(at least for these values of \(g\) and \(t\)).
</p>


<div id="org161d73d" class="figure">
<p><img src="./images/exercise_7_20_plot.png" alt="exercise_7_20_plot.png" />
</p>
<p><span class="figure-number">Figure 3: </span>The refractive index \(\chi_i\) of a single atom against the detuning \(\delta\) (blue) for \(g=1.2\) and \(t=1\). In green and red approximations in terms of \(\sim-\delta/\Omega^2\) at \(0\) and \(\infty\).</p>
</div>

<p>
This is the code to produce the plot:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org62e21a2"><span class="org-keyword">def</span> <span class="org-function-name">make_plot_ex720</span>(interval<span class="org-operator">=</span>(<span class="org-operator">-</span>15, 15), t<span class="org-operator">=</span>1, g<span class="org-operator">=</span>1.2):
    <span class="org-doc">"""Plot for exercise 7.20."""</span>
    <span class="org-variable-name">d</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'delta'</span>)
    <span class="org-variable-name">Omega</span> <span class="org-operator">=</span> sqrt(g<span class="org-operator">^</span>2 <span class="org-operator">+</span> d<span class="org-operator">^</span>2)

    <span class="org-comment-delimiter"># </span><span class="org-comment">The refractive index:</span>
    <span class="org-variable-name">chi_i</span> <span class="org-operator">=</span> arg(exp(i<span class="org-operator">*</span>d<span class="org-operator">*</span>t) <span class="org-operator">*</span> (cos(Omega<span class="org-operator">*</span>t) <span class="org-operator">-</span> i<span class="org-operator">*</span>(d<span class="org-operator">/</span>Omega)<span class="org-operator">*</span>sin(Omega<span class="org-operator">*</span>t)))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Approximations at delta=0 and delta=infinity</span>
    <span class="org-variable-name">approx_0</span> <span class="org-operator">=</span> <span class="org-operator">-</span> (g<span class="org-operator">*</span>tan(g<span class="org-operator">*</span>t) <span class="org-operator">-</span> t<span class="org-operator">*</span>g<span class="org-operator">^</span>2) <span class="org-operator">*</span> d<span class="org-operator">/</span>Omega<span class="org-operator">^</span>2
    <span class="org-variable-name">approx_inf</span> <span class="org-operator">=</span> <span class="org-operator">-</span> (t<span class="org-operator">*</span>g<span class="org-operator">^</span>2<span class="org-operator">/</span>2) <span class="org-operator">*</span> d<span class="org-operator">/</span>Omega<span class="org-operator">^</span>2

    <span class="org-variable-name">p1</span> <span class="org-operator">=</span> parametric_plot((d, chi_i), (d,)<span class="org-operator">+</span>interval, aspect_ratio<span class="org-operator">=</span><span class="org-string">'automatic'</span>,
                         color<span class="org-operator">=</span><span class="org-string">'blue'</span>)
    <span class="org-variable-name">p2</span> <span class="org-operator">=</span> parametric_plot((d, approx_0), (d,)<span class="org-operator">+</span>interval, aspect_ratio<span class="org-operator">=</span><span class="org-string">'automatic'</span>,
                         color<span class="org-operator">=</span><span class="org-string">'green'</span>)
    <span class="org-variable-name">p3</span> <span class="org-operator">=</span> parametric_plot((d, approx_inf), (d,)<span class="org-operator">+</span>interval, aspect_ratio<span class="org-operator">=</span><span class="org-string">'automatic'</span>,
                         color<span class="org-operator">=</span><span class="org-string">'red'</span>)

    <span class="org-keyword">return</span> p1 <span class="org-operator">+</span> p2 <span class="org-operator">+</span> p3
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org797959c" class="outline-3">
<h3 id="org797959c">Exercise 7.21</h3>
<div class="outline-text-3" id="text-org797959c">
<p>
Explicitly exponentiate (7.82) and show that
</p>

<p>
\[
  \varphi_{ab} = \arg\left[ e^{\ii\delta t} \left( \cos(\Omega_{ab}t) - \ii \frac{\delta}{\Omega_{ab}}\sin(\Omega_{ab} t) \right) \right] ,
\]
</p>

<p>
where \(\Omega_{ab}=\sqrt{\delta^2+g_a^2+g_b^2}\). Use this to compute \(\chi_3\), the nonlinear
Kerr phase shift. This is a very simple way to model and understand the Kerr interaction,
which sidesteps much of the complication typically involved in classical nonlinear optics.
</p>
</div>

<div id="outline-container-orgc8ff129" class="outline-4">
<h4 id="orgc8ff129">Solution</h4>
<div class="outline-text-4" id="text-orgc8ff129">
<p>
To be consistent with the remark from <a href="#exercise-7.18">exercise 7.18</a> I assume that equation (7.83) reads
\(H_0=\delta\) (instead of \(H_0=-\delta\)). Let
</p>

<p>
\[
  \varphi_0 = \arg(\bra{000}U\ket{000}) = \arg(e^{-\ii\delta t}) = -\delta .
\]
</p>

<p>
We have
</p>

<p>
\[
  \varphi_a + \varphi_0 = \arg(\bra{100}U\ket{100})
  = \arg\left(\cos(\Omega_a t) - \ii \frac{\delta}{\Omega_a}\sin(\Omega_a t)\right) .
\]
</p>

<p>
Similarly
</p>

<p>
\[
  \varphi_b + \varphi_0 = \arg(\bra{010}U\ket{010})
  = \arg\left(\cos(\Omega_b t) - \ii \frac{\delta}{\Omega_b}\sin(\Omega_b t)\right) .
\]
</p>

<p>
This is basically what we dealt with in <a href="#exercise-7.20">exercise 7.20</a>. Now we want to compute
</p>

<p>
\[
  \varphi_{ab} + \varphi_0 = \arg(\bra{110}U\ket{110}) .
\]
</p>

<p>
We only have to exponentiate \(H_2\) to compute this (not all of \(H\)). But actually we not
even have to do this due to the following observation (see also <a href="#org2a125e9">sage code</a> below):
</p>

<p>
\[
  H_2^2 = \begin{bmatrix} \Omega_{ab}^2 & 0 & 0 \\ 0 & \Omega_a^2 & g_ag_b \\ 0 & g_ag_b & \Omega_b^2 \end{bmatrix} .
\]
</p>

<p>
Note that \(\ket{110}\) corresponds to the upper left corner of the matrix \(H_2\). Hence
</p>

<p>
<a id="org058500f"></a>
\[
  \bra{110}U\ket{110} = \sum_{n \text{ even}} \frac{(-\ii t)^n}{n!} \Omega_{ab}^n +
    \sum_{n \text{ odd}} \frac{(-\ii t)^n}{n!} (-\delta)\Omega_{ab}^{n-1}
  = \cos(\Omega_{ab} t) - \ii \frac{\delta}{\Omega_{ab}}\sin(\Omega_{ab} t) .
\]
</p>

<p>
Hence
</p>

<p>
\[
  \varphi_{ab} + \varphi_0 = \arg(\bra{110}U\ket{110})
  = \arg\left(\cos(\Omega_{ab} t) - \ii \frac{\delta}{\Omega_{ab}}\sin(\Omega_{ab} t)\right) .
\]
</p>

<p>
Interestingly this is the same formula as for the single-photon case, but with a different
value for \(\Omega\). This proves the stated formula for \(\varphi_{ab}\). Let us write
</p>

<p>
\[
  R(\Omega) = \cos(\Omega t) - \ii \frac{\delta}{\Omega}\sin(\Omega t) .
\]
</p>

<p>
By what we have just shown the Kerr phase shift is
</p>

<p>
\[
  \chi_3 = \varphi_{ab} - \varphi_a - \varphi_b
  = \arg\left[e^{-\ii\delta t} \frac{R(\Omega_{ab})}{R(\Omega_a)R(\Omega_b)}\right] .
\]
</p>


<div id="orgc614e95" class="figure">
<p><img src="./images/exercise_7_21_plot.png" alt="exercise_7_21_plot.png" />
</p>
<p><span class="figure-number">Figure 4: </span>Kerr phase shift \(\chi_3\), in degrees, for \(g=1\), \(t=0.98\) plotted against the detuning \(\delta\).</p>
</div>

<p>
The code for the plot can be found <a href="#org9991d13">below</a>. In principle my plot should show the same as
Figure 7.5 in the book. And indeed it looks very similar. However it is not exactly the
same. Not sure why this is the case 🤨.
</p>
</div>
</div>

<div id="outline-container-org12f8a47" class="outline-4">
<h4 id="org12f8a47">Appendix</h4>
<div class="outline-text-4" id="text-org12f8a47">
<p>
Code to square \(H_2\):
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org12c5739"><span class="org-keyword">def</span> <span class="org-function-name">square_H2</span>():
    <span class="org-variable-name">delta</span>, <span class="org-variable-name">ga</span>, <span class="org-variable-name">gb</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'delta g_a g_b'</span>)

    <span class="org-variable-name">H2</span> <span class="org-operator">=</span> matrix([
        [<span class="org-operator">-</span>delta, ga, gb],
        [ga, delta, 0],
        [gb, 0, delta],
    ])

    <span class="org-keyword">return</span> H2<span class="org-operator">^</span>2

square_H2()
</pre>
</div>

<pre class="example">
[delta^2 + g_a^2 + g_b^2                       0                       0]
[                      0         delta^2 + g_a^2                 g_a*g_b]
[                      0                 g_a*g_b         delta^2 + g_b^2]
</pre>


<pre class="example">
[delta^2 + g_a^2 + g_b^2                       0                       0]
[                      0         delta^2 + g_a^2                 g_a*g_b]
[                      0                 g_a*g_b         delta^2 + g_b^2]
</pre>


<p>
Code to make the plot:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org9991d13"><span class="org-keyword">def</span> <span class="org-function-name">make_plot_ex721</span>(interval<span class="org-operator">=</span>(<span class="org-operator">-</span>2, 2), t<span class="org-operator">=</span>0.98, ga<span class="org-operator">=</span>1, gb<span class="org-operator">=</span>1):
    <span class="org-doc">"""Plot for exercise 7.21."""</span>
    <span class="org-variable-name">d</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'delta'</span>)
    <span class="org-variable-name">Omega_a</span> <span class="org-operator">=</span> sqrt(ga<span class="org-operator">^</span>2 <span class="org-operator">+</span> d<span class="org-operator">^</span>2)
    <span class="org-variable-name">Omega_b</span> <span class="org-operator">=</span> sqrt(gb<span class="org-operator">^</span>2 <span class="org-operator">+</span> d<span class="org-operator">^</span>2)
    <span class="org-variable-name">Omega_ab</span> <span class="org-operator">=</span> sqrt(ga<span class="org-operator">^</span>2 <span class="org-operator">+</span> gb<span class="org-operator">^</span>2 <span class="org-operator">+</span> d<span class="org-operator">^</span>2)

    <span class="org-keyword">def</span> <span class="org-function-name">phi</span>(Omega):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Note that we convert to degrees at the end</span>
        <span class="org-keyword">return</span> arg(exp(i<span class="org-operator">*</span>d<span class="org-operator">*</span>t) <span class="org-operator">*</span> (cos(Omega<span class="org-operator">*</span>t) <span class="org-operator">-</span> i<span class="org-operator">*</span>(d<span class="org-operator">/</span>Omega)<span class="org-operator">*</span>sin(Omega<span class="org-operator">*</span>t))) <span class="org-operator">*</span> 180 <span class="org-operator">/</span> pi

    <span class="org-variable-name">phi_a</span> <span class="org-operator">=</span> phi(Omega_a)
    <span class="org-variable-name">phi_b</span> <span class="org-operator">=</span> phi(Omega_b)
    <span class="org-variable-name">phi_ab</span> <span class="org-operator">=</span> phi(Omega_ab)

    <span class="org-variable-name">chi_3</span> <span class="org-operator">=</span> phi_ab <span class="org-operator">-</span> phi_a <span class="org-operator">-</span> phi_b

    <span class="org-variable-name">p1</span> <span class="org-operator">=</span> parametric_plot((d, chi_3), (d,)<span class="org-operator">+</span>interval, aspect_ratio<span class="org-operator">=</span><span class="org-string">'automatic'</span>, color<span class="org-operator">=</span><span class="org-string">'blue'</span>)
    <span class="org-keyword">return</span> p1
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org33b4e64" class="outline-3">
<h3 id="org33b4e64">Exercise 7.22</h3>
<div class="outline-text-3" id="text-org33b4e64">
<p>
Associated with the cross phase modulation is also a certain amount of loss, which is
given by the probability that a photon is absorbed by the atom. Compute this probability,
\(1-\abs{\bra{110}U\ket{110}}^2\), where \(U=\exp(-\ii\,Ht)\) for \(H\) as in (7.82); compare
with \(1-\abs{\bra{100}U\ket{100}}^2\) as a function of \(\delta\), \(g_a\), \(g_b\), and \(t\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The original exercise contained \(1-\bra{110}U\ket{110}\) as the formula for the
probability. I corrected this.</dd>
</dl>
</div>

<div id="outline-container-orgf3912c5" class="outline-4">
<h4 id="orgf3912c5">Solution</h4>
<div class="outline-text-4" id="text-orgf3912c5">
<p>
Let \(\Omega_{ab}=\sqrt{\delta^2+g_a^2+g_b^2}\). By a <a href="#org058500f">formula for</a> \(\bra{110}U\ket{110}\) from
exercise 7.21 we have
</p>

<p>
\[
  P_{ab} := 1 - \abs{\bra{110}U\ket{110}}^2
  = 1 - \abs{\cos(\Omega_{ab}t)-\frac{\ii\delta}{\Omega_{ab}}\sin(\Omega_{ab}t)}^2
  = \frac{1}{1+\frac{\delta^2}{g_a^2+g_b^2}} \, \sin(\Omega_{ab}t)^2 .
\]
</p>

<p>
In the same way we have (c.f. (7.82) and (7.77)):
</p>

<p>
\[
  P_{a} := 1 - \abs{\bra{100}U\ket{100}}^2
  = \frac{1}{1+\frac{\delta^2}{g_a^2}} \, \sin(\Omega_{a}t)^2 .
\]
</p>

<p>
Averaging over the time we see that the two-photon absorbtion probability is higher than
the one-photon absorbtion probability (which seems plausible of course).
</p>
</div>
</div>
</div>

<div id="outline-container-orgdac22a0" class="outline-3">
<h3 id="orgdac22a0">Exercise 7.23</h3>
<div class="outline-text-3" id="text-orgdac22a0">
<p>
Show that the two qubit gate of (7.87)
</p>

<p>
\[
  G(\Delta) = \begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & e^{\ii\varphi_a} & 0 & 0 \\
  0 & 0 & e^{\ii\varphi_b} & 0 \\
  0 & 0 & 0 & e^{\ii(\varphi_a+\varphi_b+\Delta)} \end{bmatrix}
\]
</p>

<p>
can be used to realize a controlled-<code>NOT</code> gate, when augmented with arbitrary single qubit
operations, for any \(\varphi_a\) and \(\varphi_b\) , and \(\Delta=\pi\). It turns out that for
nearly any value of \(\Delta\) this gate is universal when augmented with single qubit
unitaries.
</p>
</div>

<div id="outline-container-org4af84de" class="outline-4">
<h4 id="org4af84de">Proof</h4>
<div class="outline-text-4" id="text-org4af84de">
<p>
Note that up to a global phase \(e^{\ii(\varphi_a+\varphi_b)/2}\) we have
</p>

<p>
\[
  G(\Delta=0) = R_z(\varphi_b) \otimes R_z(\varphi_a) .
\]
</p>

<p>
Hence we can easily produce the controlled-<code>Z</code> gate
</p>

<p>
\[
  C(Z) = G(\Delta=\pi) \cdot R_z(-\varphi_b) \otimes R_z(-\varphi_a)
\]
</p>

<p>
By using \(X=HZH\) (\(H\) being the Hadamard gate) we get
</p>

<p>
\[
  \mathrm{CNOT} = I \otimes H \cdot G(\Delta=\pi) \cdot R_z(-\varphi_b) \otimes R_z(-\varphi_a)H .
\]
</p>

<p>
Note that we have some freedom to arrange the gates here. Due to the fact that \(R_z\)
commutes with \(G\) we could move the \(R_z\) gates to either side of \(G\). Moreover, by the
symmetry of the <code>CZ</code> gate we could also conjugate by \(H\otimes\,I\) to obtain the <code>CNOT</code>
gate with the control and target bits swapped.
</p>

<p>
QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org9a65367" class="outline-3">
<h3 id="org9a65367">Exercise 7.24</h3>
<div class="outline-text-3" id="text-org9a65367">
<p>
The energy of a nuclear spin in a magnetic ﬁeld is approximately \(\mu_NB\), where
\(\mu_N=eh/4\pi\,m_p\approx5\times10^{-27}\) joules per tesla is the nuclear Bohr magneton.
Compute the energy of a nuclear spin in a \(B=10\) tesla ﬁeld, and compare with the thermal
energy \(k_BT\) at \(T=300K\).
</p>
</div>

<div id="outline-container-org32fa2b8" class="outline-4">
<h4 id="org32fa2b8">Solution</h4>
<div class="outline-text-4" id="text-org32fa2b8">
<p>
Let us do a quick calculation:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org90a21f9"><span class="org-keyword">def</span> <span class="org-function-name">thermal_vs_spin_energy</span>(T<span class="org-operator">=</span>300, B<span class="org-operator">=</span>10):
    <span class="org-doc">"""Ratio of thermal energy against nuclear spin energy.</span>

<span class="org-doc">    Args:</span>
<span class="org-doc">        T: Temperature in Kelvin.</span>
<span class="org-doc">        B: Magnetic field in Tesla.</span>

<span class="org-doc">    NOTE: Only the ratio T/B is really relevant.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">kB</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"Boltzmann constant"</span>]
    <span class="org-variable-name">m_p</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"proton mass"</span>]
    <span class="org-variable-name">q</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"elementary charge"</span>]
    <span class="org-variable-name">h</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"Planck constant"</span>]

    <span class="org-variable-name">mu_N</span> <span class="org-operator">=</span> q<span class="org-operator">*</span>h <span class="org-operator">/</span> (4<span class="org-operator">*</span>pi_numeric<span class="org-operator">*</span>m_p) <span class="org-comment-delimiter"># </span><span class="org-comment">according to exercise</span>

    <span class="org-keyword">return</span> kB<span class="org-operator">*</span>T <span class="org-operator">/</span> (B<span class="org-operator">*</span>mu_N)
</pre>
</div>

<p>
At room temperature we get:
</p>

<div class="org-src-container">
<pre class="src src-sage">thermal_vs_spin_energy(T<span class="org-operator">=</span>300, B<span class="org-operator">=</span>10)
</pre>
</div>

<pre class="example">
82006.02536588917
</pre>


<p>
Hence the thermal energy at room temperature is around five orders of magnitude larger
than the energy of a spin in a very strong magnetic field. Conversely one can deduce that
the Temperature where both quantities are roughly equal is around \(1mK\) (still for this
strong magnetic field).
</p>
</div>
</div>
</div>

<div id="outline-container-org676e456" class="outline-3">
<h3 id="org676e456">Exercise 7.25</h3>
<div class="outline-text-3" id="text-org676e456">
<p>
Show that the total angular momenta operators obey the commutation relations for \(\mathrm{SU}(2)\),
that is, \([j_i,j_j]=\ii\epsilon_{ijk}j_k\).
</p>
</div>

<div id="outline-container-org288d558" class="outline-4">
<h4 id="org288d558">Proof</h4>
<div class="outline-text-4" id="text-org288d558">
<p>
Let \(\sigma=(X,Y,Z)\) be a vector of Pauli matrices. Then
</p>

<p>
\[
  j_i = \left(\sigma_i^{(1)} + \sigma_i^{(2)}\right) / 2 .
\]
</p>

<p>
Since \([\sigma_i^{(n)},\sigma_j^{(n')}]=0\) if \(n\neq\,n'\) we have
</p>

<p>
\[
  [j_i,j_j] = \frac{1}{4} \left(\left[\sigma_i^{(1)}, \sigma_j^{(1)}\right] +
    \left[\sigma_i^{(2)}, \sigma_j^{(2)}\right]\right) .
\]
</p>

<p>
Now the claim follows from the commutator relations of the Pauli matrices:
\([\sigma_i,\sigma_j]=2\ii\epsilon_{ijk}\sigma_k\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-7.26" class="outline-3">
<h3 id="exercise-7.26">Exercise 7.26</h3>
<div class="outline-text-3" id="text-exercise-7.26">
<p>
Verify the properties of \(\ket{j,m_j}_J\) by explicitly writing the 4×4 matrices \(J^2\) and
\(j_z\) in the basis deﬁned by \(\ket{j,m_j}_J\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>As posed the exercise contains a tiny error. We discuss this in the solution.</dd>
</dl>
</div>

<div id="outline-container-org99e0693" class="outline-4">
<h4 id="org99e0693">Solution</h4>
<div class="outline-text-4" id="text-org99e0693">
<div class="org-src-container">
<pre class="src src-sage" id="org4138b53"><span class="org-keyword">def</span> <span class="org-function-name">make_ji</span>(A, n<span class="org-operator">=</span>2):
    <span class="org-doc">"""Return one component of the Angular momentum operator for n spin-1/2 particles.</span>

<span class="org-doc">    Args:</span>
<span class="org-doc">        A: A 2x2 matrix, typically X, Y, Z (Pauli).</span>
<span class="org-doc">        n: The number of spin-1/2 particles.</span>

<span class="org-doc">    Example:</span>
<span class="org-doc">        make_ji(A,3) returns the same as</span>
<span class="org-doc">        (kron(A, Id, Id) + kron(Id, A, Id) + kron(Id, Id, A)) / 2</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">result</span> <span class="org-operator">=</span> matrix.zero(2<span class="org-operator">^</span>n)

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-variable-name">result</span> <span class="org-operator">+=</span> kron(<span class="org-operator">*</span>[Id <span class="org-keyword">if</span> j<span class="org-operator">!=</span>i <span class="org-keyword">else</span> A <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n)])

    <span class="org-keyword">return</span> result <span class="org-operator">/</span> 2
</pre>
</div>

<p>
Having this we can define the total angular momentum operator \(J^2\) and the basis
transformation \(U\) corresponding to equations (7.93) to (7.96).
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">jz</span> <span class="org-operator">=</span> make_ji(Z, 2)
<span class="org-variable-name">jx</span> <span class="org-operator">=</span> make_ji(X, 2)
<span class="org-variable-name">jy</span> <span class="org-operator">=</span> make_ji(Y, 2)

<span class="org-variable-name">J2</span> <span class="org-operator">=</span> jx<span class="org-operator">^</span>2 <span class="org-operator">+</span> jy<span class="org-operator">^</span>2 <span class="org-operator">+</span> jz<span class="org-operator">^</span>2

<span class="org-variable-name">U</span> <span class="org-operator">=</span> matrix([
    (ket(<span class="org-string">'10'</span>) <span class="org-operator">-</span> ket(<span class="org-string">'01'</span>)) <span class="org-operator">/</span> sqrt(2), ket(<span class="org-string">'11'</span>), <span class="org-comment-delimiter"># </span><span class="org-comment">|0,0&gt;_J, |1,-1&gt;_J</span>
    (ket(<span class="org-string">'01'</span>) <span class="org-operator">+</span> ket(<span class="org-string">'10'</span>)) <span class="org-operator">/</span> sqrt(2), ket(<span class="org-string">'00'</span>), <span class="org-comment-delimiter"># </span><span class="org-comment">|1,0&gt;_J, |1,+1&gt;_J</span>
]).H
</pre>
</div>

<p>
You might note that I swapped zeros and ones if you compare \(U\) with the formulas from the
book. I did this because the claim of the exercise does not hold otherwise (for example
\(j_z\ket{00}=\ket{00}\) as opposed to \(j_z\ket{00}=-\ket{00}\)). I think the reason for this
confusion is that the authors wanted \(\ket{1}\) to be of a higher level than \(\ket{0}\) in
the \(Z\) matrix (but the opposite is true, since \(\ket{0}\) as eigenvalue \(1\) which is
larger than the eigenvalue \(-1\) of \(\ket{1}\)). Another way to resolve this might have been
to replace \(Z\) by \(-Z\) and \(Y\) by \(-Y\) (One cannot just negate \(Z\) since otherwise the
commutator relations do not hold) but I do not do this here. This is related to the
<a href="#discussion-annoying-error">discussion of an annoying error</a>.
</p>

<p>
Having said that, the following shows that \(U\) simultaneously diagonalizes \(J^2\) and \(j_z\)
and it shows that \(\ket{j,m}\) corresponds to eigenvalues \(j(j+1)\) for \(J^2\) and \(m\) for
\(j_z\).
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-builtin">print</span>(<span class="org-string">"J^2 diagonalized:"</span>)
U.H <span class="org-operator">*</span> J2 <span class="org-operator">*</span> U
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">j_z diagonalized:"</span>)
U.H <span class="org-operator">*</span> jz <span class="org-operator">*</span> U
</pre>
</div>

<pre class="example" id="org8c7b23e">
J^2 diagonalized:
[0 0 0 0]
[0 2 0 0]
[0 0 2 0]
[0 0 0 2]

j_z diagonalized:
[ 0  0  0  0]
[ 0 -1  0  0]
[ 0  0  0  0]
[ 0  0  0  1]
</pre>
</div>
</div>
</div>

<div id="outline-container-org13db63e" class="outline-3">
<h3 id="org13db63e">Exercise 7.27 (Three spin angular momenta states)</h3>
<div class="outline-text-3" id="text-org13db63e">
<p>
Three spin-1/2 spins can combine together to give states of total angular momenta with
\(j=1/2\) and \(j=3/2\). Show that the states
</p>

\begin{align*}
  \ket{3/2, 3/2} &= \ket{000} \\
  \ket{3/2, 1/2} &= \frac{1}{\sqrt{3}} (\ket{100} + \ket{010} + \ket{001}) \\
  \ket{3/2, -1/2} &= \frac{1}{\sqrt{3}} (\ket{011} + \ket{101} + \ket{110}) \\
  \ket{3/2, -3/2} &= \ket{111} \\
  \ket{1/2, 1/2}_1 &= \frac{1}{\sqrt{2}} (\ket{100} - \ket{001}) \\
  \ket{1/2, -1/2}_1 &= \frac{1}{\sqrt{2}} (\ket{011} + \ket{110})  \\
  \ket{1/2, 1/2}_2 &= \frac{1}{\sqrt{6}} (\ket{001} - 2\ket{010} + \ket{100})  \\
  \ket{1/2, -1/2}_2 &= \frac{1}{\sqrt{6}} (-\ket{011} + 2\ket{101} - \ket{110})
\end{align*}

<p>
form a basis for the space, satisfying \(J^2\ket{j,m}=j(j+1)\ket{j,m}\) and
\(j_z\ket{j,m}=m\ket{j,m}\), for \(j_z=(Z_1+Z_2+Z_3)/2\) (similarly for \(j_x\) and \(j_y\)) and
\(J^2=j_x^2+j_y^2+j_z^2\). There are sophisticated ways to obtain these states, but a
straightforward brute-force method is simply to simultaneously diagonalize the 8×8
matrices \(J^2\) and \(j_z\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>I adjusted the formulas for the eigenvectors because the claim did not hold
for the old formulas. The issue is essentially the same as in <a href="#exercise-7.26">exercise 7.26</a>.</dd>
</dl>
</div>

<div id="outline-container-orgf784828" class="outline-4">
<h4 id="orgf784828">Solution</h4>
<div class="outline-text-4" id="text-orgf784828">
<p>
We proceed in the same way as in <a href="#exercise-7.26">exercise 7.26</a> by first defining the operators and then
the unitary matrix \(U\) made of the mentioned basis vectors:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">jz</span> <span class="org-operator">=</span> make_ji(Z, 3)
<span class="org-variable-name">jx</span> <span class="org-operator">=</span> make_ji(X, 3)
<span class="org-variable-name">jy</span> <span class="org-operator">=</span> make_ji(Y, 3)

<span class="org-variable-name">J2</span> <span class="org-operator">=</span> jx<span class="org-operator">^</span>2 <span class="org-operator">+</span> jy<span class="org-operator">^</span>2 <span class="org-operator">+</span> jz<span class="org-operator">^</span>2

<span class="org-variable-name">U</span> <span class="org-operator">=</span> matrix([
  <span class="org-comment-delimiter"># </span><span class="org-comment">1: The spin-3/2 subspace</span>
  ket(<span class="org-string">'000'</span>),                                          <span class="org-comment-delimiter"># </span><span class="org-comment">|3/2, +3/2&gt;</span>
  (ket(<span class="org-string">'100'</span>) <span class="org-operator">+</span> ket(<span class="org-string">'010'</span>) <span class="org-operator">+</span> ket(<span class="org-string">'001'</span>)) <span class="org-operator">/</span> sqrt(3),    <span class="org-comment-delimiter"># </span><span class="org-comment">|3/2, +1/2&gt;</span>
  (ket(<span class="org-string">'011'</span>) <span class="org-operator">+</span> ket(<span class="org-string">'101'</span>) <span class="org-operator">+</span> ket(<span class="org-string">'110'</span>)) <span class="org-operator">/</span> sqrt(3),    <span class="org-comment-delimiter"># </span><span class="org-comment">|3/2, -1/2&gt;</span>
  ket(<span class="org-string">'111'</span>),                                          <span class="org-comment-delimiter"># </span><span class="org-comment">|3/2, -3/2&gt;</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">2: the spin-1/2 subspace</span>
  (ket(<span class="org-string">'100'</span>) <span class="org-operator">-</span> ket(<span class="org-string">'001'</span>)) <span class="org-operator">/</span> sqrt(2),                 <span class="org-comment-delimiter"># </span><span class="org-comment">|1/2, +1/2&gt;_1</span>
  (ket(<span class="org-string">'011'</span>) <span class="org-operator">-</span> ket(<span class="org-string">'110'</span>)) <span class="org-operator">/</span> sqrt(2),                 <span class="org-comment-delimiter"># </span><span class="org-comment">|1/2, -1/2&gt;_1</span>
  (ket(<span class="org-string">'001'</span>) <span class="org-operator">-</span> 2<span class="org-operator">*</span>ket(<span class="org-string">'010'</span>) <span class="org-operator">+</span> ket(<span class="org-string">'100'</span>)) <span class="org-operator">/</span> sqrt(6),  <span class="org-comment-delimiter"># </span><span class="org-comment">|1/2, +1/2&gt;_2</span>
  (<span class="org-operator">-</span>ket(<span class="org-string">'011'</span>) <span class="org-operator">+</span> 2<span class="org-operator">*</span>ket(<span class="org-string">'101'</span>) <span class="org-operator">-</span> ket(<span class="org-string">'110'</span>)) <span class="org-operator">/</span> sqrt(6), <span class="org-comment-delimiter"># </span><span class="org-comment">|1/2, -1/2&gt;_2</span>
]).H
</pre>
</div>

<p>
A test that \(U\) is actually unitary:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> U.H <span class="org-operator">*</span> U <span class="org-operator">==</span> matrix.identity(8)
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
The following code shows that \(U\) simultaneously diagonalizes \(J^2\) and \(j_z\). The
eigenvalues are as claimed (\(j(j+1)\) and \(m\)). That the eight vectors are actually an
orthonormal basis of \(\CC^8\) follows mostly from the fact that most of the eigenvalue
pairs \((j(j+1),m)\) are different, one only has to check that \(\ket{1/2,\pm1/2}_1\) and
\(\ket{1/2,\pm1/2}_2\) are really orthogonal.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-builtin">print</span>(<span class="org-string">"J^2 diagonalized:"</span>)
U.H <span class="org-operator">*</span> J2 <span class="org-operator">*</span> U
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">j_z diagonalized:"</span>)
U.H <span class="org-operator">*</span> jz <span class="org-operator">*</span> U
</pre>
</div>

<pre class="example" id="org49cc8cc">
J^2 diagonalized:
[15/4    0    0    0    0    0    0    0]
[   0 15/4    0    0    0    0    0    0]
[   0    0 15/4    0    0    0    0    0]
[   0    0    0 15/4    0    0    0    0]
[   0    0    0    0  3/4    0    0    0]
[   0    0    0    0    0  3/4    0    0]
[   0    0    0    0    0    0  3/4    0]
[   0    0    0    0    0    0    0  3/4]

j_z diagonalized:
[ 3/2    0    0    0    0    0    0    0]
[   0  1/2    0    0    0    0    0    0]
[   0    0 -1/2    0    0    0    0    0]
[   0    0    0 -3/2    0    0    0    0]
[   0    0    0    0  1/2    0    0    0]
[   0    0    0    0    0 -1/2    0    0]
[   0    0    0    0    0    0  1/2    0]
[   0    0    0    0    0    0    0 -1/2]
</pre>
</div>
</div>
</div>

<div id="outline-container-org81ef22a" class="outline-3">
<h3 id="org81ef22a">Exercise 7.28 (Hyperfine states)</h3>
<div class="outline-text-3" id="text-org81ef22a">
<p>
We shall be taking a look at beryllium in Section 7.6.4 – the total angular momenta states
relevant there involve a nuclear spin \(I=3/2\) combining with an electron spin \(S=1/2\) to
give \(F=2\) or \(F=1\).  For a spin-3/2 particle, the angular momenta operators are
</p>

\begin{align*}
  i_x &= \frac{1}{2} \begin{bmatrix}
    0 & \sqrt{3} & 0 & 0 \\
    \sqrt{3} & 0 & 2 & 0 \\
    0 & 2 & 0 & \sqrt{3} \\
    0 & 0 & \sqrt{3} & 0 \end{bmatrix} , \\
  i_y &= \frac{1}{2} \begin{bmatrix}
    0 & \ii\sqrt{3} & 0 & 0 \\
    -\ii\sqrt{3} & 0 & 2\ii & 0 \\
    0 & -2\ii & 0 & \ii\sqrt{3} \\
    0 & 0 & -\ii\sqrt{3} & 0 \end{bmatrix} , \\
  i_z &= \frac{1}{2} \begin{bmatrix}
    -3 & 0 & 0 & 0 \\
    0 & -1 & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 3 \end{bmatrix}
\end{align*}

<ol class="org-ol">
<li>Show that \(i_x\), \(i_y\), and \(i_z\) satisfy \(\mathrm{SU}(2)\) commutation rules.</li>
<li>Give 8×8 matrix representations of \(f_z=i_z\otimes\,I+I\otimes\,Z/2\) (where \(I\) here
represents the identity operator on the appropriate subspace) and similarly \(f_x\) and
\(f_y\), and, \(F^2=f_x^2+f_y^2+f_z^2\). Simultaneously diagonalize \(f_z\) and \(F^2\) to
obtain basis states \(\ket{f,m}\) for which \(F\ket{f,m}=f(f+1)\ket{f,m}\) and
\(f_z\ket{f,m}=m\ket{f,m}\).</li>
</ol>
</div>

<div id="outline-container-orge40f511" class="outline-4">
<h4 id="orge40f511">Solution for claim 1</h4>
<div class="outline-text-4" id="text-orge40f511">
<p>
Let us first define \(i_x\), \(i_y\), and \(i_z\) within sage:
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgdd3852a"><span class="org-variable-name">iz</span> <span class="org-operator">=</span> matrix([
    [<span class="org-operator">-</span>3, 0, 0, 0],
    [0, <span class="org-operator">-</span>1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 3],
]) <span class="org-operator">/</span> 2

<span class="org-variable-name">ix</span> <span class="org-operator">=</span> matrix([
    [0, sqrt(3), 0, 0],
    [sqrt(3), 0, 2, 0],
    [0, 2, 0, sqrt(3)],
    [0, 0, sqrt(3), 0],
]) <span class="org-operator">/</span> 2

<span class="org-variable-name">iy</span> <span class="org-operator">=</span> matrix([
    [0, i<span class="org-operator">*</span>sqrt(3), 0, 0],
    [<span class="org-operator">-</span>i<span class="org-operator">*</span>sqrt(3), 0, 2<span class="org-operator">*</span>i, 0],
    [0, <span class="org-operator">-</span>2<span class="org-operator">*</span>i, 0, i<span class="org-operator">*</span>sqrt(3)],
    [0, 0, <span class="org-operator">-</span>i<span class="org-operator">*</span>sqrt(3), 0],
]) <span class="org-operator">/</span> 2
</pre>
</div>

<p>
The commutator relations are now easily verified:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> com(ix, iy) <span class="org-operator">==</span> i<span class="org-operator">*</span>iz
<span class="org-keyword">assert</span> com(iy, iz) <span class="org-operator">==</span> i<span class="org-operator">*</span>ix
<span class="org-keyword">assert</span> com(iz, ix) <span class="org-operator">==</span> i<span class="org-operator">*</span>iy
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Hence \([i_i,i_j]=\ii\epsilon_{ijk}i_k\) since \([A,B]=-[B,A]\) and \([A,A]=0\).
</p>
</div>
</div>

<div id="outline-container-org2785e6c" class="outline-4">
<h4 id="org2785e6c">Solution for claim 2</h4>
<div class="outline-text-4" id="text-org2785e6c">
<p>
Let us first define the relevant operators
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org7404763"><span class="org-variable-name">Id2</span> <span class="org-operator">=</span> matrix.identity(2)
<span class="org-variable-name">Id4</span> <span class="org-operator">=</span> matrix.identity(4)

<span class="org-variable-name">fz</span> <span class="org-operator">=</span> kron(iz, Id2) <span class="org-operator">+</span> kron(Id4, Z<span class="org-operator">/</span>2)
<span class="org-variable-name">fx</span> <span class="org-operator">=</span> kron(ix, Id2) <span class="org-operator">+</span> kron(Id4, X<span class="org-operator">/</span>2)
<span class="org-variable-name">fy</span> <span class="org-operator">=</span> kron(iy, Id2) <span class="org-operator">+</span> kron(Id4, Y<span class="org-operator">/</span>2)

<span class="org-variable-name">F2</span> <span class="org-operator">=</span> fx<span class="org-operator">^</span>2 <span class="org-operator">+</span> fy<span class="org-operator">^</span>2 <span class="org-operator">+</span> fz<span class="org-operator">^</span>2
</pre>
</div>

<p>
Unfortunately I did not find a builtin method (in sage) to simultaneously diagonalize two
matrices. Hence we do it manually. Recall that to simultaneously diagonalize two matrices
\(A\) and \(B\) you first diagonalize \(A\) and then diagonalize the restrictions of \(B\) to the
sub-spaces of \(A\).
</p>

<p>
Before we go on let us define two auxiliary functions.
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org5170b39"><span class="org-keyword">def</span> <span class="org-function-name">restrict</span>(A: matrix, M: matrix) <span class="org-operator">-&gt;</span> matrix:
    <span class="org-doc">"""A is a d&#215;d matrix and M a l&#215;d matrix whose rows are linearly independent. This</span>
<span class="org-doc">    method returns the matrix A restricted to the subspace spanned by these l vectors and</span>
<span class="org-doc">    with respect to those vectors as basis.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">d1</span>, <span class="org-variable-name">d2</span> <span class="org-operator">=</span> A.dimensions()
    <span class="org-variable-name">l</span>, <span class="org-variable-name">d</span> <span class="org-operator">=</span> M.dimensions()

    <span class="org-keyword">assert</span> d <span class="org-operator">==</span> d1 <span class="org-operator">==</span> d2, <span class="org-string">"Dimensions of A and M are not consistent."</span>
    <span class="org-keyword">assert</span> rank(M) <span class="org-operator">==</span> l, <span class="org-string">"Rows of M have to linearly independent."</span>

    <span class="org-keyword">return</span> M <span class="org-operator">*</span> A <span class="org-operator">*</span> M.H


<span class="org-keyword">def</span> <span class="org-function-name">column_normalized</span>(M: matrix) <span class="org-operator">-&gt;</span> matrix:
    <span class="org-doc">"""Return a matrix which has the same columms as M but normalized. We expect M to be a</span>
<span class="org-doc">    symbolic (SR) or rational matrix. It returns a symbolic matrix (SR)."""</span>
    <span class="org-variable-name">Q</span> <span class="org-operator">=</span> M.change_ring(SR).H
    <span class="org-variable-name">_</span>, <span class="org-variable-name">d</span> <span class="org-operator">=</span> M.dimensions()

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(d):
        <span class="org-variable-name">n</span> <span class="org-operator">=</span> Q[i].norm()
        <span class="org-variable-name">Q</span>[i] <span class="org-operator">=</span> Q[i] <span class="org-operator">/</span> n

    <span class="org-keyword">return</span> Q.H
</pre>
</div>

<p>
We first calculate the eigenvalues and the corresponding diagonalization matrix for
\(F^2\). By default sage does not normalize \(P\), that is why we have to use
<code class="src src-python">column_normalized</code> to make \(P\) into a unitary matrix.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">D</span>, <span class="org-variable-name">P</span> <span class="org-operator">=</span> F2.eigenmatrix_right()
<span class="org-variable-name">P</span> <span class="org-operator">=</span> column_normalized(P)
<span class="org-keyword">assert</span> P.H <span class="org-operator">*</span> P <span class="org-operator">==</span> matrix.identity(8)

<span class="org-comment-delimiter"># </span><span class="org-comment">D = P.H * F2 * P:</span>
D
</pre>
</div>

<pre class="example">
[6 0 0 0 0 0 0 0]
[0 6 0 0 0 0 0 0]
[0 0 6 0 0 0 0 0]
[0 0 0 6 0 0 0 0]
[0 0 0 0 6 0 0 0]
[0 0 0 0 0 2 0 0]
[0 0 0 0 0 0 2 0]
[0 0 0 0 0 0 0 2]
</pre>


<p>
We see that \(F^2\) has five eigenvalues \(f(f+1)\) for \(f=2\) (i.e. \(6\)) and three for \(f=1\)
(i.e. \(2\)). The goal of the following code is to transform \(P\) into another unitary \(U\)
which diagonalizes \(F^2\) too, but also \(f_z\). Actually already the original \(P\) does this
(at least at time of writing this), but this could be a lucky coincidence. However the
code still reorders the matrix so that the eigenvalues of \(f_z\) are not randomly ordered
(the order of the eigenvalues returned by <code>eigenmatrix_right</code> seems to be unspecified in
general but at least at the time of writing this some sensible ordering is visible - which
might change in the future of course).
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-comment-delimiter"># </span><span class="org-comment">Splitting according to the two eigenspaces of F^2:</span>
<span class="org-variable-name">P1</span> <span class="org-operator">=</span> P.H[:5]
<span class="org-variable-name">P2</span> <span class="org-operator">=</span> P.H[5:]

<span class="org-comment-delimiter"># </span><span class="org-comment">Restrict f_z to the two eigenspaces in the basis given by P:</span>
<span class="org-variable-name">fz1</span> <span class="org-operator">=</span> restrict(fz, P1)
<span class="org-variable-name">fz2</span> <span class="org-operator">=</span> restrict(fz, P2)

<span class="org-comment-delimiter"># </span><span class="org-comment">Get the unitaries which make the restrictions diagonal relative to the P-basis</span>
<span class="org-variable-name">_</span>, <span class="org-variable-name">Pz1</span> <span class="org-operator">=</span> fz1.eigenmatrix_right()
<span class="org-variable-name">_</span>, <span class="org-variable-name">Pz2</span> <span class="org-operator">=</span> fz2.eigenmatrix_right()

<span class="org-comment-delimiter"># </span><span class="org-comment">Assemble U:</span>
<span class="org-variable-name">U1</span> <span class="org-operator">=</span> Pz1.H <span class="org-operator">*</span> P1
<span class="org-variable-name">U2</span> <span class="org-operator">=</span> Pz2.H <span class="org-operator">*</span> P2
<span class="org-variable-name">U</span> <span class="org-operator">=</span> U1.stack(U2).H.simplify_full()
<span class="org-keyword">assert</span> U.H <span class="org-operator">*</span> U <span class="org-operator">==</span> matrix.identity(8)

<span class="org-builtin">print</span>(<span class="org-string">"U^&#8224; * F^2 * U:"</span>)
U.H <span class="org-operator">*</span> F2 <span class="org-operator">*</span> U <span class="org-comment-delimiter"># </span><span class="org-comment">diag 6,6,6,6,6;  2,2,2</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">U^&#8224; * f_z * U:"</span>)
U.H <span class="org-operator">*</span> fz <span class="org-operator">*</span> U <span class="org-comment-delimiter"># </span><span class="org-comment">diag 2,1,0-1,-2; 1,0,-1</span>
<span class="org-builtin">print</span>(<span class="org-string">"</span><span class="org-constant">\n</span><span class="org-string">U:"</span>)
U
</pre>
</div>

<pre class="example" id="org4c67783">
U^† * F^2 * U:
[6 0 0 0 0 0 0 0]
[0 6 0 0 0 0 0 0]
[0 0 6 0 0 0 0 0]
[0 0 0 6 0 0 0 0]
[0 0 0 0 6 0 0 0]
[0 0 0 0 0 2 0 0]
[0 0 0 0 0 0 2 0]
[0 0 0 0 0 0 0 2]

U^† * f_z * U:
[-2  0  0  0  0  0  0  0]
[ 0 -1  0  0  0  0  0  0]
[ 0  0  0  0  0  0  0  0]
[ 0  0  0  1  0  0  0  0]
[ 0  0  0  0  2  0  0  0]
[ 0  0  0  0  0 -1  0  0]
[ 0  0  0  0  0  0  0  0]
[ 0  0  0  0  0  0  0  1]

U:
[           0          1/2            0            0            0  1/2*sqrt(3)            0            0]
[           1            0            0            0            0            0            0            0]
[           0            0  1/2*sqrt(2)            0            0            0  1/2*sqrt(2)            0]
[           0  1/2*sqrt(3)            0            0            0         -1/2            0            0]
[           0            0            0  1/2*sqrt(3)            0            0            0          1/2]
[           0            0  1/2*sqrt(2)            0            0            0 -1/2*sqrt(2)            0]
[           0            0            0            0            1            0            0            0]
[           0            0            0          1/2            0            0            0 -1/2*sqrt(3)]
</pre>

<p>
From this we can easily read out the eigenbasis:
</p>

\begin{align*}
  \ket{2, +2} &= \ket{110} \\
  \ket{2, +1} &= \frac{1}{2}(\sqrt{3}\ket{100} + \ket{111}) \\
  \ket{2,  0} &= \frac{1}{\sqrt{2}}(\ket{010} + \ket{101}) \\
  \ket{2, -1} &= \frac{1}{2}(\ket{000} + \sqrt{3}\ket{011}) \\
  \ket{2, -2} &= \ket{001} \\
  \ket{1, +1} &= \frac{1}{2}(\ket{100} - \sqrt{3}\ket{111}) \\
  \ket{1,  0} &= \frac{1}{\sqrt{2}}(\ket{010} - \ket{101}) \\
  \ket{1, -1} &= \frac{1}{2}(\sqrt{3}\ket{000} - \ket{011})
\end{align*}
</div>
</div>
</div>

<div id="outline-container-org8e91e5b" class="outline-3">
<h3 id="org8e91e5b"><span class="todo SKIP">SKIP</span> Exercise 7.29 (Spontaneous emission)</h3>
<div class="outline-text-3" id="text-org8e91e5b">
<p>
The spontaneous emission rate (7.112) can be derived from (7.110)–(7.111) by the following
steps.
</p>

<ol class="org-ol">
<li><p>
Integrate
</p>

<p>
\[
   \frac{1}{(2\pi c)^3} \, \frac{8\pi}{3} \int_0^\infty \omega^2 p_{\mathrm{decay}} \dd \omega ,
   \]
</p>

<p>
where the \(8\pi/3\) comes from summing over polarizations and integrating over the solid
angle \(\dd\Omega\), and \(\omega^2/(2\pi c)^3\) comes from the mode density in
three-dimensional space. (Hint: you may want to extend the lower limit of the integral
to \(-\infty\).)
</p></li>
<li>Differentiate the result with respect to \(t\), to obtain \(\gamma_{\mathrm{rad}}\).</li>
</ol>

<p>
The form of \(g^2\) is a result of quantum electrodynamics; taking this for granted, the
remainder of the calculation as presented here really stems from just the Jaynes–Cummings
interaction. Again, we see how considering its properties in the single atom, single
photon regime gives us a fundamental property of atoms, without resorting to perturbation
theory!
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
According to the <a href="https://www.michaelnielsen.org/qcqi/errata/errata/errata.html">errata</a>, the corrected formula for \(p_{\mathrm{decay}}\) is
</p>

<p>
\[
  p_{\mathrm{decay}} = g^2 \, \frac{4\sin(2\inv(\omega-\omega_0)t)}{(\omega - \omega_0)^2} .
  \]
</p></dd>
</dl>
</div>

<div id="outline-container-org13e5ba6" class="outline-4">
<h4 id="org13e5ba6">Discussion</h4>
<div class="outline-text-4" id="text-org13e5ba6">
<p>
No matter how I look at this exercise the integral is just infinite for me. Ignoring the
sine for a moment the integrand looks essentially like this:
</p>

<p>
\[
  \frac{\omega}{(\omega-\omega_0)^2}
\]
</p>

<p>
which behaves like \(\omega\inv\) at infinity. But this integrates to infinity (for all ways
to define the integral I know). The sine does not really change anything here because it
goes into the integral in its squared form. This only slows down the convergence of
\(\lim_{a\to\infty}\int_0^a\ldots\dd\omega\) since it is \(1/2\) on average. But the integral
is still infinite.
</p>

<p>
Therefore I think that something is wrong with the formulas. At the moment I do not know
what and I didn't have time to investigate.
</p>
</div>
</div>
</div>

<div id="outline-container-org29262f2" class="outline-3">
<h3 id="org29262f2">Exercise 7.30 (Electronic state lifetimes)</h3>
<div class="outline-text-3" id="text-org29262f2">
<p>
A calculation similar to that for γred can be done to estimate the lifetimes expected for
electronic transitions, that is, those which involve energy level changes
\(\Delta\,n\neq0\). For such transitions, the relevant interaction couples the atom’s
electric dipole moment to the electromagnetic field, giving
</p>

<p>
\[
  g^2_{\mathrm{ed}}
  = \frac{\omega_0^2}{2\hbar\omega\epsilon_0} \, \abs{\bra{0}\vec{\mu}_{\mathrm{ed}}\ket{1}}^2 .
\]
</p>

<p>
This gives a spontaneous emission rate
</p>

<p>
\[
  \gamma_{\mathrm{red}}^{\mathrm{ed}}
  = \frac{\omega_0^3\abs{\bra{0}\vec{\mu}_{\mathrm{ed}}\ket{1}}^2}{3\pi\hbar\epsilon_0c^3} .
\]
</p>

<p>
Give a value for \(\gamma_{\mathrm{red}}^{\mathrm{ed}}\), taking
\(\abs{\bra{0}\vec{\mu}_{\mathrm{ed}}\ket{1}}^2\approx\,qa_0\), where \(q\) is the electric
charge, and \(a_0\) the Bohr radius, and assuming
\(\omega_0/2\pi\approx10^{15}\mathrm{Hz}\). The result show how much faster electronic
states can decay compared with hyperﬁne states.
</p>
</div>

<div id="outline-container-orgcb450a5" class="outline-4">
<h4 id="orgcb450a5">Solution</h4>
<div class="outline-text-4" id="text-orgcb450a5">
<p>
That is just plugging in numbers so let us write a convenience function
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org78992b1"><span class="org-keyword">def</span> <span class="org-function-name">make_gamma</span>(which: <span class="org-builtin">str</span>):
    <span class="org-doc">"""For exercise 7.30."""</span>
    <span class="org-variable-name">eps0</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"vacuum electric permittivity"</span>]
    <span class="org-variable-name">c</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"speed of light in vacuum"</span>]
    <span class="org-variable-name">hbar</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"reduced Planck constant"</span>]
    <span class="org-variable-name">mu_B</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"Bohr magneton"</span>]

    <span class="org-variable-name">a0</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"Bohr radius"</span>]
    <span class="org-variable-name">q</span>, <span class="org-variable-name">_</span>, <span class="org-variable-name">_</span> <span class="org-operator">=</span> physical_constants[<span class="org-string">"elementary charge"</span>]

    <span class="org-variable-name">pi</span> <span class="org-operator">=</span> pi_numeric

    <span class="org-keyword">def</span> <span class="org-function-name">hyperfine</span>(omega_0):
        <span class="org-keyword">return</span> (omega_0<span class="org-operator">^</span>3 <span class="org-operator">*</span> mu_B<span class="org-operator">^</span>2) <span class="org-operator">/</span> (3<span class="org-operator">*</span>pi<span class="org-operator">*</span>hbar<span class="org-operator">*</span>eps0<span class="org-operator">*</span>c<span class="org-operator">^</span>5)

    <span class="org-keyword">def</span> <span class="org-function-name">electronic</span>(omega_0):
        <span class="org-keyword">return</span> (omega_0<span class="org-operator">^</span>3 <span class="org-operator">*</span> (q<span class="org-operator">*</span>a0)<span class="org-operator">^</span>2) <span class="org-operator">/</span> (3<span class="org-operator">*</span>pi<span class="org-operator">*</span>hbar<span class="org-operator">*</span>eps0<span class="org-operator">*</span>c<span class="org-operator">^</span>3)

    <span class="org-keyword">if</span> which <span class="org-operator">==</span> <span class="org-string">'hyperfine'</span>:
        <span class="org-keyword">return</span> hyperfine
    <span class="org-keyword">elif</span> which <span class="org-operator">==</span> <span class="org-string">'electronic'</span>:
        <span class="org-keyword">return</span> electronic
    <span class="org-keyword">else</span>:
        <span class="org-keyword">raise</span> exception(<span class="org-string">"Wrong key."</span>)


<span class="org-variable-name">gamma_hyperfine</span> <span class="org-operator">=</span> make_gamma(<span class="org-string">'hyperfine'</span>)
<span class="org-variable-name">gamma_electronic</span> <span class="org-operator">=</span> make_gamma(<span class="org-string">'electronic'</span>)
</pre>
</div>

<p>
Let us plug in the values:
</p>

<p>
Plugging in the relevant values for \(\omega_0\) for each case we get:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">hyperfine</span> <span class="org-operator">=</span> gamma_hyperfine(2<span class="org-operator">*</span>pi.n()<span class="org-operator">*</span>1e10)
<span class="org-variable-name">electronic</span> <span class="org-operator">=</span> gamma_electronic(2<span class="org-operator">*</span>pi.n()<span class="org-operator">*</span>1e15)

<span class="org-builtin">print</span>(f<span class="org-string">"hyperfine  = </span>{hyperfine:0.5}<span class="org-string"> (1/sec)"</span>)
<span class="org-builtin">print</span>(f<span class="org-string">"electronic = </span>{electronic:0.5}<span class="org-string"> (1/sec)"</span>)
<span class="org-builtin">print</span>(f<span class="org-string">"ratio      = </span>{hyperfine <span class="org-operator">/</span> electronic:0.5}<span class="org-string">"</span>)
</pre>
</div>

<pre class="example">
hyperfine  = 1.0011E-12 (1/sec)
electronic = 7.5198E+7 (1/sec)
ratio      = 1.3313E-20
</pre>


<p>
Hence life time of the electronic state is 20 orders of magnitude shorter than that of the
hyperfine state.
</p>

<p>
In case you wonder why the hyperfine value is not around \(10^{-15}\mathrm{Hz}\) as in the
book on page 316: you would get this value if you remove the factor \(2\pi\).
</p>
</div>
</div>
</div>

<div id="outline-container-org4fc76bc" class="outline-3">
<h3 id="org4fc76bc">Exercise 7.31</h3>
<div class="outline-text-3" id="text-org4fc76bc">
<p>
Construct a Hadamard gate from \(R_x\) and \(R_y\) rotations.
</p>
</div>

<div id="outline-container-org1abfec7" class="outline-4">
<h4 id="org1abfec7">Solution</h4>
<div class="outline-text-4" id="text-org1abfec7">
<p>
This is not hard to accomplish in the rotation formalism for the Pauli matrices and
rotations. First of all note that
</p>

<p>
\[
  H = \frac{1}{\sqrt{2}} (X + Z) .
\]
</p>

<p>
That is \(H\) corresponds to the vector \(\vec{h}=(\hat{x}+\hat{z})/\sqrt{2}\), where
\(\hat{x}=(1,0,0)\) and \(\hat{z}=(0,0,1)\). Note that a rotation around \(\hat{y}\) by an angle
\(-\pi/4\) rotates \(\hat{x}\) into \(\vec{h}\). This suggests that
</p>

<p>
\[
  H = R_y(-\pi/4) \cdot X \cdot R_y(\pi/4) .
\]
</p>

<p>
We can check this by sage:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">angle</span> <span class="org-operator">=</span> <span class="org-operator">-</span>pi<span class="org-operator">/</span>4
<span class="org-variable-name">HH</span> <span class="org-operator">=</span> (Ry.subs(theta<span class="org-operator">=</span>angle) <span class="org-operator">*</span> X <span class="org-operator">*</span> Ry.subs(theta<span class="org-operator">=-</span>angle));
HH.simplify_full()
</pre>
</div>

<pre class="example">
[ 1/2*sqrt(sqrt(2) + 2)*sqrt(-sqrt(2) + 2)                               1/2*sqrt(2)]
[                              1/2*sqrt(2) -1/2*sqrt(sqrt(2) + 2)*sqrt(-sqrt(2) + 2)]
</pre>


<p>
At the time of writing this I couldn't (easily) convince sage that
</p>

<pre class="example">
1/2*sqrt(sqrt(2) + 2)*sqrt(-sqrt(2) + 2)
</pre>


<p>
is just <code>1/2*sqrt(2)</code>. But it is easy enough to see it ourselfs. Now combining this with
\(X=\ii\,R_x(\pi)\) we see that
</p>

<p>
\[
  \ii H = R_y(\pi/4) \cdot R_x(\pi) \cdot R_y(-\pi/4) .
\]
</p>

<p>
The global phase is not observable so we accomplished what we wanted.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc9bfcf7" class="outline-3">
<h3 id="orgc9bfcf7">Exercise 7.32</h3>
<div class="outline-text-3" id="text-orgc9bfcf7">
<p>
Show that the circuit in Figure 7.14 is equivalent (up to relative phases) to a <code>CNOT</code>
gate, with the phonon state as the control qubit.
</p>
</div>

<div id="outline-container-orged2580d" class="outline-4">
<h4 id="orged2580d">Proof</h4>
<div class="outline-text-4" id="text-orged2580d">
<p>
First of all recall that the <code>CZ</code> gate is symmetric in the sense that the <code>CZ</code> with
control and target somewhere is the same as the <code>CZ</code> gate where control and target are
swapped. We take advantage of this and consider the phonon state as the control so that
the y-rotations conjugate the <code>Z</code> gate. The claim follows if we can show that
</p>

<p>
\[
  R_y(-\pi/2) \cdot Z \cdot R_y(\pi/2)
\]
</p>

<p>
is the \(X\) gate up to a global phase. In fact this is easy to see by the rotation
formalism for the pauli matrices. A rotation around the y-axis of angle \(-\pi/2\) moves the
z-axis to the negative x-axis. This suggests that
</p>

<p>
\[
  R_y(-\pi/2) \cdot Z \cdot R_y(\pi/2) = -X
\]
</p>

<p>
This can easily be verified by sage:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> Ry.subs(theta<span class="org-operator">=-</span>pi<span class="org-operator">/</span>2) <span class="org-operator">*</span> Z <span class="org-operator">*</span> Ry.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>2) <span class="org-operator">==</span> <span class="org-operator">-</span>X
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
As already said this implies that the depicted circuit indeed implements <code>CNOT</code> with the
control at the phonon state and a global phase factor of \(-1\). Moreover, if the angle
rotation was \(\pi/2\) instead of \(-\pi/2\) the phase factor would be \(1\).
</p>
</div>
</div>
</div>

<div id="outline-container-org69b74a9" class="outline-3">
<h3 id="org69b74a9">Exercise 7.33 (Magnetic resonance)</h3>
<div class="outline-text-3" id="text-org69b74a9">
<p>
Show that (7.128) simplifies to become (7.129). What laboratory frame Hamiltonian gives
rise to the rotating frame Hamiltonian (7.135)?
</p>

<dl class="org-dl">
<dt>Remark</dt><dd><p>
I was a bit puzzled by the purpose of the second part of the exercise. But
reading on in the chapter I think found the purpose. I think that the RF electronics of
the apparatus can be used to not only generate magnetic fields like
</p>

<p>
\[ B_1(\cos(\omega t) \hat{x} + \sin(\omega t) \hat{y}) , \]
</p>

<p>
but more general fields of the form
</p>

<p>
\[ B_1(f_1(t) \hat{x} + f_2(t) \hat{y}) , \]
</p>

<p>
at least for <i>certain</i> functions \(f_1\) and \(f_2\). A Hamiltonian of the form
\(H^{\RF}=g_1(t)X+g_2(t)Y\) can then be used to implement X- and Y-rotations. For example
to do a X-rotation during time interval \([t_1,t_2]\) you set \(g_2(t)=0\) and
\(g_1(t)=\mathrm{const}\neq0\) during that time.
</p></dd>
</dl>
</div>

<div id="outline-container-org2bf45aa" class="outline-4">
<h4 id="org2bf45aa">Proof</h4>
<div class="outline-text-4" id="text-org2bf45aa">
<p>
To see that (7.128) simplifies to (7.129) it suffices to recall the product rule of
differentiation:
</p>

<p>
\[
  \ii\partial_t \left(e^{\ii\omega Zt/2} \ket{\chi(t)} \right)
  = \ii\left(\partial_t e^{\ii\omega Zt/2} \right) \ket{\chi(t)} + \ii e^{\ii\omega Zt/2} \ket{\dot{\chi}(t)}
  = -\frac{1}{2}\omega Z e^{\ii\omega Zt/2} \ket{\chi(t)} + e^{\ii\omega Zt/2} H\ket{\chi(t)} .
\]
</p>

<p>
Plugging in \(\ket{\varphi(t)}=\exp(\ii\omega\,Zt/2)\ket{\chi(t)}\) yields the claim. We
also note at this point that (7.130):
</p>

<p>
\[
  R_z(-\omega t) \, X \, R_z(\omega t) = \cos(\omega t) X - \sin(\omega t) Y
\]
</p>

<p>
directly follows from the <a href="chapter_4.html#org0edbd26">fundamental theorem</a> on Pauli rotations. In the following let
\(c\), \(s\) and let \(H^{\RF}=g_1(t)X+g_2(t)Y\). Again by the fundamental theorem:
</p>

<p>
\[
  R_z(\omega t) H^{\RF} R_z(-\omega t) = (cg_1 - sg_2) X + (sg_1 + cg_2) Y .
\]
</p>

<p>
That is, for the laboratory frame Hamiltonian on the RHS the rotating frame Hamiltonian is
as desired. The special case \(g_1=1\), \(g_0\) was considered in the book. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb176066" class="outline-3">
<h3 id="orgb176066"><span class="todo TODO">TODO</span> Exercises 7.34 (NMR frequencies)</h3>
<div class="outline-text-3" id="text-orgb176066">
<p>
Starting with the nuclear Bohr magneton, compute the precession frequency of a proton in a
magnetic ﬁeld of 11.8 tesla. How many gauss should \(B_1\) be to accomplish a 90° rotation
in 10 microseconds?
</p>
</div>
</div>

<div id="outline-container-orgda0f63a" class="outline-3">
<h3 id="orgda0f63a"><span class="todo SKIP">SKIP</span> Exercises 7.35 (Motional narrowing)</h3>
<div class="outline-text-3" id="text-orgda0f63a">
<p>
Show that the spherical average of \(H_{1,2}^{\mathrm{D}}\) over \(\hat{n}\) is zero.
</p>
</div>

<div id="outline-container-orgbee94d0" class="outline-4">
<h4 id="orgbee94d0">Discussion</h4>
<div class="outline-text-4" id="text-orgbee94d0">
<p>
Actually I do <i>not</i> get that the average is zero! I am not sure if I misunderstand the
exercise, did a mistake in my calculations, or if there is actually an error in the book.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfe0b287" class="outline-3">
<h3 id="orgfe0b287">Exercises 7.36 (Thermal equilibrium NMR state)</h3>
<div class="outline-text-3" id="text-orgfe0b287">
<p>
For \(n=1\) show that the thermal equilibrium state is
</p>

<p>
\[
  \rho \approx \frac{1}{2} - \frac{\hbar\omega}{4k_BT} \, Z ,
\]
</p>

<p>
and for \(n=2\) (and \(\omega_A\approx4\omega_B\)),
</p>

<p>
\[
  \rho \approx \frac{1}{4} - \frac{\hbar\omega_B}{8k_BT} \, \diag(5,3,-3,-5) .
\]
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The originally provided formulas from the book are not correct. They already
violate the trace condition \(\trace{\rho}=1\). Above I replaced them by formulas I
obtained in the solution below.</dd>
</dl>
</div>

<div id="outline-container-org009123e" class="outline-4">
<h4 id="org009123e">Solution</h4>
<div class="outline-text-4" id="text-org009123e">
<p>
Recall that the thermal equilibrium state is approximately
\(\rho\approx2^{-n}(1-\beta\,H)\). For \(n=1\) we have \(H_1=2^{-1}\hbar\omega\,Z\). Hence
</p>

<p>
\[
  \rho_1 = 2\inv \left(1 - \frac{\hbar\omega}{2k_BT} Z \right) .
\]
</p>

<p>
For \(n=2\) with \(\omega_A=4\omega_B\) we have
</p>

<p>
\[
  H_2 = \frac{4\hbar\omega_B}{2} Z_1 + \frac{\hbar\omega_B}{2} Z_2 .
\]
</p>

<p>
Let us briefly note that
</p>

<p>
\[
  4Z_1 + Z_2 = 4 \, \diag(1,1,-1,-1) + \diag(1,-1,1,-1) = \diag(5,3,-3,-5) .
\]
</p>

<p>
Hence
</p>

<p>
\[
  \rho_2 = \frac{1}{4} \left( 1 - \frac{\hbar \omega_B}{2k_BT} \, \diag(5,3,-3,-5) \right) .
\]
</p>
</div>
</div>
</div>

<div id="outline-container-org430d473" class="outline-3">
<h3 id="org430d473">Exercises 7.37 (NMR spectrum of coupled spins)</h3>
<div class="outline-text-3" id="text-org430d473">
<p>
Calculate \(V(t)\) for \(H=JZ_1Z_2\) and
</p>

<p>
\[
  \rho = R_{y1}^\dagger \frac{1}{4} [1 - \beta\hbar\omega_0(Z_1 + Z_2)] R_{y1} .
\]
</p>

<p>
How many lines would there be in the spectrum of the ﬁrst spin if the Hamiltonian were
\(H=JZ_1(Z_2+Z_3+Z_4)\) (with a similar initial density matrix) and what would their
relative magnitudes be?
</p>
</div>

<div id="outline-container-orge9f2428" class="outline-4">
<h4 id="orge9f2428">Solution</h4>
<div class="outline-text-4" id="text-orge9f2428">
<p>
First of all we have
</p>

<p>
\[
  \rho = \frac{1}{4} [1 - \beta\hbar\omega_0(-X_1 + Z_2)] .
\]
</p>

<p>
Replacing \(J\) by \(J/2\) we can reuse the results obtained in <a href="#exercise-7.45">exercise 7.45</a> (I solved it
earlier than this exercise). With the notation from there we have
</p>

<p>
\[
  F := U^\dagger (\sigma_1^- + \sigma_2^-) U = \sigma_1^- \cos(Jt) + \sigma_2^- \cos(Jt) +
    \sigma_1^- Z_2 \ii\sin(Jt) + Z_1 \sigma_2^- \ii\sin(Jt).
\]
</p>

<p>
Only the first term in \(F=\sigma_1^-\cos(Jt)+\ldots\) actually observes the \(X_1\) (the
first spin in \(\rho\)). Therefore we have two peaks, corresponding to \(\pm\,J\) in the
spectrum (Note: \(\cos(Jt)=(e^{\ii\,Jt}+e^{-\ii\,Jt})/2\)).
</p>

<p>
If I am not mistaken this shouldn't change much with more the general Hamiltonian from the
second part of the exercise. It only changes \(F\) to
</p>

<p>
\[
  F' = \sigma_1^- \cos(Jt)^3 + \ldots = \sigma_1^- 2^{-3}(
  e^{3\ii tJ} + 3e^{\ii tJ} + 3e^{-\ii tJ} + e^{-3\ii tJ} )  + \ldots
\]
</p>

<p>
where the rest contained in the dots does not observe \(X_1\). Hence we see peaks at
\(\pm\,J\) and \(\pm\,3J\) and the former are three times as pronounced.
</p>
</div>
</div>
</div>

<div id="outline-container-org62adbb9" class="outline-3">
<h3 id="org62adbb9">Exercise 7.38 (Refocusing)</h3>
<div class="outline-text-3" id="text-org62adbb9">
<p>
Explicitly show that (7.150)
</p>

<p>
\[
  R_{x1}^2 \, e^{-\ii Z_1 at} \, R_{x1}^2 = - e^{-\ii Z_1 at}
\]
</p>

<p>
is true (use the anti-commutativity of the Pauli matrices).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>I corrected a tiny error in the exercise. The original formulation had the
minus sign missing in front of the term \(e^{-\ii Z_1 at}\) on the RHS. Alternatively one
could just add the standard phrase about equality <i>up to a global phase</i>.</dd>
</dl>
</div>

<div id="outline-container-org2a7841d" class="outline-4">
<h4 id="org2a7841d">Proof</h4>
<div class="outline-text-4" id="text-org2a7841d">
<p>
First of all, recall that
</p>

<p>
\[
  R_x^2 = R_x(\pi/2)^2 = R_x(\pi) = -\ii X .
\]
</p>

<p>
The commutator relations imply \(XZX=-Z\). The claim now follows from \(Xe^{A}X=e^{XAX}\),
which holds for any matrix \(A\). QED.
</p>
</div>
</div>
</div>

<div id="outline-container-orgeef32cd" class="outline-3">
<h3 id="orgeef32cd">Exercise 7.39 (Three-dimensional refocusing)</h3>
<div class="outline-text-3" id="text-orgeef32cd">
<p>
What set of pulses can be used to refocus evolution under <i>any</i> single spin Hamiltonian
\(H^{\sys}=\sum_kc_k\sigma_k\) where \(\sigma_k\in\{X,Y,Z\}\) (acting on qubit \(k\))?
</p>
</div>

<div id="outline-container-org4de34c4" class="outline-4">
<h4 id="org4de34c4">Proof</h4>
<div class="outline-text-4" id="text-org4de34c4">
<p>
Let \(K\) be the set of all qubits and let \(S\subseteq\,K\). Assume that we want to refocus
the evolution to
</p>

<p>
\[
  H_S = \sum_{k\in S} c_k \sigma_k ,
\]
</p>

<p>
Note that \(S\) could be the empty set, which implies \(H_S=0\). The commutator relations of
the Pauli matrices imply \(XZX=-X\) and \(YZY=-Z\) as well as the variations where \(X\), \(Y\),
and \(Z\) are cyclicitly permutated. Define
</p>

<p>
\[
  R_k = \begin{cases}
    R_{xk} & \text{if } \sigma_k = Y, \\
    R_{yk} & \text{if } \sigma_k = X, \\
    R_{xk} \text{ or } R_{yk} & \text{if } \sigma_k = Z. \end{cases}
\]
</p>

<p>
Use this to define
</p>

<p>
\[
  U = \prod_{k\in K\backslash S} R_k^2 .
\]
</p>

<p>
Note that \(U^\dagger=(-1)^{\abs{K\backslash S}}U\) (because \(R_x^2=-\ii\,X\), etc.). From
the mentioned properties \(XZX=-X\), etc., we deduce
</p>

<p>
\[
  e^{-\ii H_S t} = e^{-\ii H^{\sys} t/2} \, U \, e^{-\ii H^{\sys} t/2} \, U ,
\]
</p>

<p>
which is the desired refocusing. QED.
</p>
</div>
</div>
</div>

<div id="outline-container-org8891d06" class="outline-3">
<h3 id="org8891d06">Exercise 7.40 (Refocusing dipolar interactions)</h3>
<div class="outline-text-3" id="text-org8891d06">
<p>
Give a sequence of pulses which can be used to turn two spin dipolar coupling \(H_{1,2}^{\mathrm{D}}\)
into the much simpler form of (7.138), \(cZ_1Z_2\) (for some constant \(c\)).
</p>
</div>

<div id="outline-container-org0035ded" class="outline-4">
<h4 id="org0035ded">Solution</h4>
<div class="outline-text-4" id="text-org0035ded">
<p>
The Hamiltonian \(H^{\mathrm{D}}_{1,2}\) is a special case of a Hamiltonian of the Form
</p>

<p>
\[
  H_0 = \sum_{ij} \alpha_{ij} \sigma_i^{(1)} \sigma_j^{(2)} ,
\]
</p>

<p>
where \(\sigma_i,\sigma_j\in\{X,Y,Z\}\). Let \(R_z=R_z(\pi/2)\). Note that
\(R_z^2=R_yR_x^2R_y^\dagger\), which means that \(R_z\) can indeed be realized by RF-pulses
(see e.g. <a href="chapter_4.html#org0edbd26">here</a>). We have <i>up to a global phase</i>
</p>

<p>
\[
  e^{-\ii H_1 t} = e^{-\ii H_0 t/2} R_{z1}^2 e^{-\ii H_0 t/2} R_{z1}^2
\]
</p>

<p>
for \(H_1=Z_1(\alpha_{31}X_2+\alpha_{32}Y_2+\alpha_{33}Z_2)\). Similarly
</p>

<p>
\[
  e^{-\ii H_2 t} = e^{-\ii H_1 t/2} R_{z2}^2 e^{-\ii H_1 t/2} R_{z2}^2
\]
</p>

<p>
for \(H_2=\alpha_33Z_1Z_2\). Putting everything together:
</p>

\begin{align*}
  e^{-\ii \alpha_{33}Z_1Z_2 t} &=
    \left(e^{-\ii H_0 t/4} R_{z1}^2 e^{-\ii H_0 t/4} R_{z1}^2 \right) R_{z2}^2
    \left(e^{-\ii H_0 t/4} R_{z1}^2 e^{-\ii H_0 t/4} R_{z1}^2\right) R_{z2}^2 \\
  &= e^{-\ii H_0 t/4} R_{y1}R_{x1}^2R_{y1}^\dagger e^{-\ii H_0 t/4} R_{y1}R_{x1}^2R_{y1}^\dagger
    R_{y2}R_{x2}^2R_{y2}^\dagger
    e^{-\ii H_0 t/4} R_{y1}R_{x1}^2R_{y1}^\dagger e^{-\ii H_0 t/4} R_{y1}R_{x1}^2R_{y1}^\dagger
    R_{y2}R_{x2}^2R_{y2}^\dagger .
\end{align*}

<p>
This is a relatively straightforward solution. Might be interesting to check whether there
is a simpler solution in the sense that less terms are involved.
</p>
</div>
</div>
</div>

<div id="outline-container-org7189e34" class="outline-3">
<h3 id="org7189e34">Exercise 7.41 (NMR <code>CNOT</code>)</h3>
<div class="outline-text-3" id="text-org7189e34">
<p>
Give an explicit sequence of single qubit rotations which realize a <code>CNOT</code> between two
spins evolving under the Hamiltonian of (7.147):
</p>

<p>
\[
  H^{\sys} = aZ_1 + bZ_2 + cZ_1Z_2 .
\]
</p>

<p>
You may start with (7.46),
</p>

<p>
\[
  C(X) = H_2 C(Z) H_2
\]
</p>

<p>
but the result can be simplified to reduce the number of single qubit rotations.
</p>
</div>

<div id="outline-container-org63e0bb9" class="outline-4">
<h4 id="org63e0bb9">Solution</h4>
<div class="outline-text-4" id="text-org63e0bb9">
<p>
Recall that
</p>

\begin{align*}
  Z \otimes Z &= \diag(+1, -1, -1, +1), \\
  Z \otimes 1 &= \diag(+1, +1, -1, -1), \\
  1 \otimes Z &= \diag(+1, -1, +1, -1).
\end{align*}

<p>
Hence
</p>

<p>
<a id="orged8a424"></a>
\[
  C(Z) = -\sqrt{i} \cdot e^{-\ii Z_1Z_2 \pi/4} \cdot e^{\ii Z_1 \pi/4} \cdot e^{\ii Z_2 \pi/4} .
\]
</p>

<p>
We ignore the global phase \(-\sqrt{i}\) in the following. Therefore we have
</p>

<p>
\[
  C(X) = H_2 C(Z) H_2 = H_2 e^{-\ii H^{\sys} t_c} R_{z1}(\theta_a) R_{z2}(\theta_b) H_2 ,
\]
</p>

<p>
where
</p>

<p>
\[
  t_c = \frac{\pi}{4c}, \quad \theta_a = 2t_c(c-a), \quad \theta_b = 2t_c(c-a).
\]
</p>

<p>
Note that \(R_z\) commutes with <code>CZ</code>. Because of this, and of \(R_z^4=I\) we have
</p>

<p>
<a id="orge30394b"></a>
\[
  C(X) = (H_2 R_{z2}^2) \cdot e^{-\ii H^{\sys} t_c} R_{z1}(\theta_a) R_{z2}(\theta_b) \cdot (R_{z2}^2 H_2) .
\]
</p>

<p>
Because of the <a href="chapter_4.html#org0edbd26">fundamental theorem</a> on Pauli rotations we have (up to a global phase)
</p>

<p>
\[
  H = R_y^{-1/2} R_x^2 R_y^{1/2}, \quad R_z(\theta) = R_y\inv R_x(\theta) R_y .
\]
</p>

<p>
Hence, using \(XR_yX=R_y\inv\),
</p>

<p>
\[
  H R_{z}^2 = R_y^{-1/2} R_x^2 R_y^{1/2} R_y\inv R_x^2 R_y
  = R_y^{-1/2} R_x^2 R_y^{-1/2} R_x^2 R_y
  = R_y^{-1/2} R_y^{1/2} R_y
  = R_y .
\]
</p>

<p>
Plugging this into <a href="#orge30394b">what we already have</a>:
</p>

<p>
\[
  C(X) = R_{y2} \cdot e^{-\ii H^{\sys} t_c} R_{z1}(\theta_a) R_{z2}(\theta_b) \cdot R_{y2}\inv .
\]
</p>

<p>
Recall \(R_z(\theta)=R_y\inv R_x(\theta) R_y\) from above. Hence
</p>

<p>
\[
  C(X) = R_{y2} \cdot e^{-\ii H^{\sys} t_c} R_{y1}\inv R_{x1}(\theta_a)R_{y1} R_{y2}\inv R_{x2}(\theta_b) .
\]
</p>

<p>
We arrived at a reasonable implementation of the controlled not-gate using only RF-pulses
and the evolution of the system Hamiltonian.
</p>
</div>
</div>
</div>

<div id="outline-container-org69a4d97" class="outline-3">
<h3 id="org69a4d97">Exercise 7.42 (Permutations for temporal labeling)</h3>
<div class="outline-text-3" id="text-org69a4d97">
<p>
Give a quantum circuit to accomplish the permutations \(P\) and \(P^\dagger\) necessary to
transform
</p>

<p>
\[ \rho_1 = \diag(a, b, c, d) \]
</p>

<p>
of (7.153) to
</p>

<p>
\[ \rho_2 = \diag(a, c, d, b) \]
</p>

<p>
of (7.154).
</p>
</div>

<div id="outline-container-org7d6859c" class="outline-4">
<h4 id="org7d6859c">Solution</h4>
<div class="outline-text-4" id="text-org7d6859c">
<p>
The permutation has to map
</p>

<p>
\[
  \rho_1 = a\proj{0} + b\proj{1} + c\proj{2} + d\proj{3}
\]
</p>

<p>
to
</p>

<p>
\[
  \rho_2 = a\proj{0} + b\proj{3} + c\proj{1} + d\proj{2} .
\]
</p>

<p>
Hence, in cycle notation we must have
</p>

<p>
\[
  P = (0)(1, 3, 2) .
\]
</p>

<p>
We can implement permutations via <code>SWAP</code> gates. Swap gates correspond to permutations
which act on exaclty two elements, like \((1,2)\) (swapping \(1\) and \(2\)). One way to
decompose cycles into swaps is best demonstrated on an example:
</p>

<p>
\[
  (0, 1, 2, 3, 4) = (3, 4) \cdot (2, 3) \cdot (1, 2) \cdot (0, 1) .
\]
</p>

<p>
Here <i>composition</i> (the \(\cdot\)) acts from left to right (that is, \((3,4)\) is applied
first, and \((0,1)\) is applied last). This ordering is a typical convention in the theory
of permutation groups and it nicely corresponds to the order in which we write down the
action of circuits.
</p>

<p>
We have
</p>

<p>
\[
  P = (0)(1,3,2) = (2,3) \cdot (1,3) .
\]
</p>

<p>
This is the corresponding circuit for \(P\):
</p>

<pre class="example">

q_0: ──────

q_1: ────X─
         │
q_2: ─X──┼─
      │  │
q_3: ─X──X─

</pre>
</div>
</div>
</div>

<div id="outline-container-orge4ff41d" class="outline-3">
<h3 id="orge4ff41d">Exercise 7.43 (Permutations for logical labeling)</h3>
<div class="outline-text-3" id="text-orge4ff41d">
<p>
Give a quantum circuit to accomplish the permutations \(P\) necessary to transform
</p>

<p>
\[
  \rho = \delta I + \alpha \, \diag(6, 2, 2, -2, 2, -2, -2, -6)
    \approx \left( \delta_1 + 2 \alpha_1 Z \right)^{\otimes 3}
\]
</p>

<p>
of (7.163) to
</p>

<p>
\[
  \rho' = P \rho P^\dagger = \delta I + \alpha \, \diag(6, -2, -2, -2, -6, 2, 2, 6)
\]
</p>

<p>
of (7.165).
</p>
</div>

<div id="outline-container-org132eded" class="outline-4">
<h4 id="org132eded">Solution</h4>
<div class="outline-text-4" id="text-org132eded">
<p>
Before we begin, let us quickly verify that the appoximation for \(\rho\) is valid. Let us
start at the RHS. Under the assumption that \(\alpha_1\ll\delta_1\) (let us justify this
later) we have
</p>

<p>
\[
  \left( \delta_1 + 2 \alpha_1 Z \right)^{\otimes 3} \approx
  \delta_1^3 + 2\alpha_1\delta_1^2\left(Z_1 + Z_2 + Z_3\right) .
\]
</p>

<p>
Setting \(\delta=\delta_1^3=2^{-3}\) (it must be this value due to the trace condition),
\(\alpha=2\alpha_1\delta_1^2=\alpha_1/2\) we obtain the LHS. Note that our assumption
\(\alpha_1\ll\delta_1\) is consistent with the assumption from the book
(\(\alpha\ll\delta\)).
</p>

<div class="org-src-container">
<pre class="src src-sage" id="orgcdf82e1"><span class="org-variable-name">Z1</span> <span class="org-operator">=</span> kron(Z, Id, Id)
<span class="org-variable-name">Z2</span> <span class="org-operator">=</span> kron(Id, Z, Id)
<span class="org-variable-name">Z3</span> <span class="org-operator">=</span> kron(Id, Id, Z)

<span class="org-keyword">assert</span> 2<span class="org-operator">*</span>(Z1 <span class="org-operator">+</span> Z2 <span class="org-operator">+</span> Z3) <span class="org-operator">==</span> matrix.diagonal([6, 2, 2, <span class="org-operator">-</span>2, 2, <span class="org-operator">-</span>2, <span class="org-operator">-</span>2, <span class="org-operator">-</span>6])
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Let's get back to the exercise. <i>One</i> permutation which does what we want is (in cycle
notation)
</p>

<p>
\[
  P = (1, 6)(2, 5)(4, 7) .
\]
</p>

<p>
This can immidiately be implemented by three swap operations:
</p>

<pre class="example" id="org6f8315e">

q_0: ─────────

q_1: ─X───────
      │
q_2: ─┼──X────
      │  │
q_3: ─┼──┼────
      │  │
q_4: ─┼──┼──X─
      │  │  │
q_5: ─┼──X──┼─
      │     │
q_6: ─X─────┼─
            │
q_7: ───────X─

</pre>
</div>
</div>
</div>

<div id="outline-container-org48bfe41" class="outline-3">
<h3 id="org48bfe41"><span class="todo SKIP">SKIP</span> Exrcise 7.44 (Logical labeling for \(n\) spins)</h3>
<div class="outline-text-3" id="text-org48bfe41">
<p>
Suppose we have a system of \(n\) nearly identical spins of Zeeman frequency \(\omega\) in
thermal equilibrium at temperature \(T\) with state \(\rho\). What is the largest effective
pure state that you can construct from \(\rho\) using logical labeling? (Hint: take
advantage of states whose labels have Hamming weight of \(n/2\).)
</p>
</div>

<div id="outline-container-orgb1dc76b" class="outline-4">
<h4 id="orgb1dc76b">Discussion</h4>
<div class="outline-text-4" id="text-orgb1dc76b">
<p>
I do not know how this exercise is meant. Not sure what state \(\rho\) they mean and how
\(\omega\) is relevant here.
</p>
</div>
</div>
</div>

<div id="outline-container-exercise-7.45" class="outline-3">
<h3 id="exercise-7.45">Exercise 7.45 (State tomography with NMR)</h3>
<div class="outline-text-3" id="text-exercise-7.45">
<p>
Let the voltage measurement
</p>

<p>
\[
  V_k^M(t) = V_0 \trace{e^{-\ii Ht}M_k \rho M_k^\dagger e^{\ii Ht}(\sigma_1^-+\sigma_2^-)}
\]
</p>

<p>
be the result of experiment \(k\).  Show that for two spins, nine experiments, with \(M_0=I\),
\(M_1=R_{x1}\), \(M_2=R_{y2}\), \(M_3=R_{x2}\), \(M_4=R_{x2}R_{x1}\), \(M_5=R_{x2}R_{y1}\)
etc. provide sufﬁcient data from which \(\rho\) can be reconstructed.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>I adjusted the formula for \(V_k(t)\) according to my own section <a href="#chapter-7-state-tomography">on state
tomography</a>.</dd>
</dl>
</div>

<div id="outline-container-org42d39ca" class="outline-4">
<h4 id="org42d39ca">Solution</h4>
<div class="outline-text-4" id="text-org42d39ca">
<p>
The system Hamiltonian looks as follows
</p>

<p>
\[
  H = \frac{\omega_1}{2} Z_1 + \frac{\omega_2}{2} Z_2 + \frac{J_{12}}{2} Z_1 Z_2 .
\]
</p>

<p>
Let \(U_1\), \(U_2\), and \(U_{12}\) be the evolution operators of the three summands
(e.g. \(U_1(t)=\exp(-\ii\omega_1\,Z_1t/2)\)). Note that these three operators commute and
their product is \(\exp(-\ii\,Ht)\). From the section <a href="#chapter-7-state-tomography">on state tomography</a> we directly deduce
</p>

<p>
\[
  V_k(t) = V_0 \trace{M_k\rho M_k^\dagger \cdot U_{12}^\dagger
    ( \sigma_1^- e^{\ii\omega t} + \sigma_2^- e^{\ii\omega t} )U_{12}} .
\]
</p>

<p>
The next simplifications are done via sage.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">J12</span> <span class="org-operator">=</span> SR.var(<span class="org-string">'J12'</span>, domain<span class="org-operator">=</span><span class="org-string">'real'</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">The factor e^(1/2*i*J12*t) is just there to simplify the expressions</span>
<span class="org-variable-name">U12</span> <span class="org-operator">=</span> matrix.diagonal([exp(<span class="org-operator">-</span>i<span class="org-operator">*</span>J12<span class="org-operator">*</span>t<span class="org-operator">/</span>2), exp(<span class="org-operator">+</span>i<span class="org-operator">*</span>J12<span class="org-operator">*</span>t<span class="org-operator">/</span>2)])
<span class="org-variable-name">U12</span> <span class="org-operator">=</span> e<span class="org-operator">^</span>(1<span class="org-operator">/</span>2<span class="org-operator">*</span>i<span class="org-operator">*</span>J12<span class="org-operator">*</span>t) <span class="org-operator">*</span> CX <span class="org-operator">*</span> kron(Id, U12) <span class="org-operator">*</span> CX

<span class="org-variable-name">sm1</span> <span class="org-operator">=</span> kron(sm, Id)
<span class="org-variable-name">sp1</span> <span class="org-operator">=</span> kron(sp, Id)

<span class="org-variable-name">sm2</span> <span class="org-operator">=</span> kron(Id, sm)
<span class="org-variable-name">sp2</span> <span class="org-operator">=</span> kron(Id, sp)
</pre>
</div>

<p>
Then we get
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> U12.H <span class="org-operator">*</span> sm1 <span class="org-operator">*</span> U12 <span class="org-operator">==</span> kron(sm, Rz.subs(theta<span class="org-operator">=-</span>2<span class="org-operator">*</span>J12<span class="org-operator">*</span>t))
<span class="org-keyword">assert</span> U12.H <span class="org-operator">*</span> sm2 <span class="org-operator">*</span> U12 <span class="org-operator">==</span> kron(Rz.subs(theta<span class="org-operator">=-</span>2<span class="org-operator">*</span>J12<span class="org-operator">*</span>t), sm)
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Expressing \(R_z(-2\theta)\) as \(\cos(\theta)+\ii\sin(\theta)Z\) we obtain
</p>

<p>
<a id="orgd69be98"></a>
\[
  V_k(t) = V_0 \trace{M_k\rho M_k^\dagger \cdot (
    \sigma_1^- \cdot \cos(J_{12}t)e^{\ii\omega_1 t} + \sigma_2^- \cdot \cos(J_{12}t)e^{\ii\omega_2 t} +
    \sigma_1^- Z_2 \cdot \ii\sin(J_{12}t)e^{\ii\omega_1 t} + Z_1 \sigma_2^- \cdot \ii\sin(J_{12}t)e^{\ii\omega_2 t} )} .
\]
</p>

<p>
Recall that any mixed state on two qubits can be represented as \(\frac{1}{4}I\) plus a sum
of \(A_{i}\) and \(A_1B_2\) where \(A,B\) are Pauli matrices and \(i\in{1,2}\) denotes on which
qubit it acts. By orthogonality of the Pauli matrices (and \(\sigma^-=X+\ii\,Y\))
\(\trace{\rho\sigma_1}\) "sees" the \(X_1\) and \(Y_1\) terms. Similary \(\trace{\rho\sigma_2}\)
sees \(X_2\), \(Y_2\), \(\trace{\rho\sigma_1Z_2}\) sees \(X_1Z_2\), \(Y_1Z_2\) and
\(\trace{\rho\sigma_2Z_1}\) sees \(Z_1X_2\), \(Z_1Y_2\). Therefore only one experiment can
already see eight of the 15 relevant terms. Moreover the four experiments
</p>

<p>
\[
  M_k \in \{I, R_{x1}, R_{x2}, R_{y1}\}
\]
</p>

<p>
are already sufficient to see all 15 terms. There are certainly other (small) sets of
experiments which also see all 15 terms. I didn't check if fewer than four experiments are
sufficient.
</p>
</div>
</div>
</div>

<div id="outline-container-org35fa11e" class="outline-3">
<h3 id="org35fa11e"><span class="todo WIP">WIP</span> Exercise 7.46</h3>
<div class="outline-text-3" id="text-org35fa11e">
<p>
How many experiments are sufficient for three spins? Necessary?
</p>
</div>

<div id="outline-container-org0299f06" class="outline-4">
<h4 id="org0299f06">Sketch of a solution</h4>
<div class="outline-text-4" id="text-org0299f06">
<p>
In this case the Hamiltonian looks as follows
</p>

<p>
\[
  H = \frac{\omega_1}{2} Z_1 + \frac{\omega_2}{2} Z_2 + \frac{\omega_3}{2} Z_3 +
    \frac{J_{12}}{2} Z_1 Z_2 +
    \frac{J_{13}}{2} Z_1 Z_3 +
    \frac{J_{23}}{2} Z_2 Z_3 .
\]
</p>

<p>
The precedure and the results of <a href="#exercise-7.45">exercise 7.45</a> can be adapted (or reused) to get a formula
for \(V(t)\) analogous to <a href="#orgd69be98">the one</a> obtained there. This formula determines which of the terms
\(A_1B_2C_3\), with \(A,B,C\in\{I,X,Y,Z\}\), of \(\rho\) are observed by \(V(t)\). Moreover, it is
also clear how RF-pulses like \(R_{x3}\), \(R_{y2}\), etc. change which terms are observed.
</p>

<p>
It is now straightforward to write a short script which just tries out all possible
combinations of 90° pulses and looks which sets of experiments are sufficient to determine
all coefficients of \(\rho\) (in the Pauli basis).
</p>

<p>
So far I was not inclined to write such a script since the end result does not interest me
strong enough so far. On the other hand I also do not know if there is a nice analytical
way to determine a minimial set of experiments.
</p>
</div>
</div>
</div>

<div id="outline-container-org5433fc5" class="outline-3">
<h3 id="org5433fc5">Exercise 7.47 (NMR <code>CNOT</code> gate)</h3>
<div class="outline-text-3" id="text-org5433fc5">
<p>
Verify that the circuit shown in the top left of Figure 7.19
</p>

<pre class="example">
           ┌───────────┐
q_0: ──────┤0          ├──────
     ┌────┐│  sqrt(ZZ) │┌────┐
q_1: ┤ Rx ├┤1          ├┤ Ry ├
     └────┘└───────────┘└────┘
</pre>


<p>
performs a <code>CNOT</code> gate, up to
single qubit phases; that is, it acts properly on classical input states, and furthermore
can be turned into a proper <code>CNOT</code> gate by applying additional single qubit \(R_z\)
rotations. Give another circuit using the same building blocks to realize a proper <code>CNOT</code>
gate.
</p>

<p>
<a id="orgfb993dd"></a>
</p>
<dl class="org-dl">
<dt>Remark</dt><dd><p>
There is an error in the original exercise. With \(H=2\pi\hbar JZ_1Z_2\) we
would have
</p>

<p>
\[
  e^{-\ii H / (2\hbar J)} = -I .
  \]
</p>

<p>
This does not really do anything. Instead a more useful operation is
</p>

<p>
\[
  e^{-\ii H / (8\hbar J)} = \diag(e^{-\ii\pi/4}, e^{\ii\pi/4}, e^{\ii\pi/4}, e^{-\ii\pi/4}) .
  \]
</p>

<p>
Note that this equals \(\sqrt{Z_1Z_2}=\diag(1,\ii,\ii,1)\) up to a global phase. Since
\(\sqrt{Z_1Z_2}\) is easier to handle via symbolic computation we use it in calculations.
</p>

<p>
Probably this error is just a typo since defining \(H=2\inv\pi\hbar\,JZ_1Z_2\) would also
resolve the issue.
</p></dd>
</dl>
</div>

<div id="outline-container-org2ec15bd" class="outline-4">
<h4 id="org2ec15bd">Solution</h4>
<div class="outline-text-4" id="text-org2ec15bd">
<p>
An easy way to check the first assertion is to plug it into sage.
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org91e5c67"><span class="org-variable-name">sqrtZZ</span> <span class="org-operator">=</span> matrix([
  [1, 0, 0, 0],
  [0, i, 0, 0],
  [0, 0, i, 0],
  [0, 0, 0, 1],
])

<span class="org-variable-name">rx</span> <span class="org-operator">=</span> Rx.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>2)
<span class="org-variable-name">ry</span> <span class="org-operator">=</span> Ry.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>2)
<span class="org-variable-name">rz</span> <span class="org-operator">=</span> Rz.subs(theta<span class="org-operator">=</span>pi<span class="org-operator">/</span>2)

<span class="org-variable-name">cx_ex747</span> <span class="org-operator">=</span> kron(Id, ry) <span class="org-operator">*</span> sqrtZZ <span class="org-operator">*</span> kron(Id, rx.H)
</pre>
</div>

<p>
Checking that the circuit implements <code>CX</code> up to <i>single</i> qubit phase flips:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> cx_ex747 <span class="org-operator">==</span> matrix([
    [ 1, 0, 0, 0],
    [ 0, I, 0, 0],
    [ 0, 0, 0,<span class="org-operator">-</span>1],
    [ 0, 0, I, 0],
])
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Observe that the phase of the the image of \(\ket{ij}\) is off by \(\ii^{i+j}\). This is the
same as the action of \(S\otimes S\) (using the phase gate \(S=\sqrt{Z}\)) and can be
neutralised by its adjoint. Note that \(R_z=S\) up to a <i>global</i> phase.
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> <span class="org-operator">-</span>i <span class="org-operator">*</span> cx_ex747 <span class="org-operator">*</span> kron(rz.H, rz.H) <span class="org-operator">==</span> CX
<span class="org-doc">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Note that
</p>

<p>
\[
  R_z = R_y\inv R_x R_y .
\]
</p>

<p>
Hence the following circuit actually implements the <code>CNOT</code> gate:
</p>

<p>
<a id="orgcf0df25"></a>
</p>
<pre class="example">
     ┌──────┐┌──────┐┌────┐      ┌───────────┐
q_0: ┤ Ry^† ├┤ Rx^† ├┤ Ry ├──────┤0          ├──────
     ├──────┤├──────┤├────┤┌────┐│  sqrt(ZZ) │┌────┐
q_1: ┤ Ry^† ├┤ Rx^† ├┤ Ry ├┤ Rx ├┤1          ├┤ Ry ├
     └──────┘└──────┘└────┘└────┘└───────────┘└────┘
</pre>
</div>
</div>
</div>

<div id="outline-container-orge11e9f9" class="outline-3">
<h3 id="orge11e9f9">Exercise 7.48</h3>
<div class="outline-text-3" id="text-orge11e9f9">
<p>
Verify that the circuit
</p>

<pre class="example">
     ┌────┐┌───────────┐
q_0: ┤ Rx ├┤0          ├──────
     ├────┤│  sqrt(ZZ) │┌────┐
q_1: ┤ Rx ├┤1          ├┤ Ry ├
     └────┘└───────────┘└────┘
</pre>


<p>
shown in the bottom left of Figure 7.19 creates the Bell state
\((\ket{00}-\ket{11})/\sqrt{2}\) as advertised.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The same remark as in <a href="#orgfb993dd">exercise 7.47</a> applies here too.</dd>
</dl>
</div>

<div id="outline-container-org426b84e" class="outline-4">
<h4 id="org426b84e">Solution</h4>
<div class="outline-text-4" id="text-org426b84e">
<p>
That is easily verified by sage:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">U</span> <span class="org-operator">=</span> kron(Id, ry.H) <span class="org-operator">*</span> sqrtZZ <span class="org-operator">*</span> kron(rx, rx)
<span class="org-keyword">assert</span> U <span class="org-operator">*</span> ket(<span class="org-string">'00'</span>) <span class="org-operator">==</span> (ket(<span class="org-string">'00'</span>) <span class="org-operator">-</span> ket(<span class="org-string">'11'</span>)) <span class="org-operator">/</span> sqrt(2)
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>
</div>

<div id="outline-container-org722d0a3" class="outline-3">
<h3 id="org722d0a3">Exercise 7.49 (NMR swap gate)</h3>
<div class="outline-text-3" id="text-org722d0a3">
<p>
An important chemical application of NMR is measurement of connectivity of spins,
i.e. what protons, carbons, and phosphorus atoms are nearest neighbors in a molecule. One
pulse sequence to do this is known as INADEQUATE (incredible natural abundance double
quantum transfer experiment – the art of NMR is full of wonderfully creative acronyms).
In the language of quantum computation, it can be understood as simply trying to apply a
<code>CNOT</code> between any two resonances; if the <code>CNOT</code> works, the two nuclei must be
neighbors. Another building block which is used in sequences such as TOCSY (total
correlation spectroscopy) is a swap operation, but not quite in the perfect form we can
describe simply with quantum gates! Construct a quantum circuit using only
\(e^{-\ii\,H/(4\hbar\,J)}\), \(R_x\) , and \(R_y\) operations to implement a swap gate (you may
start from the circuit in Figure 1.7).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The same remark as in <a href="#orgfb993dd">exercise 7.47</a> applies here too.</dd>
</dl>
</div>

<div id="outline-container-orgf0ef55f" class="outline-4">
<h4 id="orgf0ef55f">Solution</h4>
<div class="outline-text-4" id="text-orgf0ef55f">
<p>
A <code>SWAP</code> gate can be implemented in terms of three <code>CNOT</code> gates:
</p>

<pre class="example">
          ┌───┐
q_0: ──■──┤ X ├──■──
     ┌─┴─┐└─┬─┘┌─┴─┐
q_1: ┤ X ├──■──┤ X ├
     └───┘     └───┘
</pre>


<p>
In exercise 7.47 <a href="#orgcf0df25">we have seen</a> how to implement a single <code>CNOT</code>. So let us glue together
three of those:
</p>

<pre class="example" id="orgb65f795">
     ┌──────┐┌──────┐┌────┐      ┌───────────┐┌──────┐┌──────┐ ┌────┐ ┌────┐»
q_0: ┤ Ry^† ├┤ Rx^† ├┤ Ry ├──────┤0          ├┤ Ry^† ├┤ Rx^† ├─┤ Ry ├─┤ Rx ├»
     ├──────┤├──────┤├────┤┌────┐│  sqrt(ZZ) │└┬────┬┘├──────┤┌┴────┴┐├────┤»
q_1: ┤ Ry^† ├┤ Rx^† ├┤ Ry ├┤ Rx ├┤1          ├─┤ Ry ├─┤ Ry^† ├┤ Rx^† ├┤ Ry ├»
     └──────┘└──────┘└────┘└────┘└───────────┘ └────┘ └──────┘└──────┘└────┘»
«     ┌───────────┐ ┌────┐ ┌──────┐┌──────┐┌────┐┌───────────┐
«q_0: ┤0          ├─┤ Ry ├─┤ Ry^† ├┤ Rx^† ├┤ Ry ├┤0          ├──────
«     │  sqrt(ZZ) │┌┴────┴┐├──────┤└┬────┬┘├────┤│  sqrt(ZZ) │┌────┐
«q_1: ┤1          ├┤ Ry^† ├┤ Rx^† ├─┤ Ry ├─┤ Rx ├┤1          ├┤ Ry ├
«     └───────────┘└──────┘└──────┘ └────┘ └────┘└───────────┘└────┘
</pre>

<p>
There are two places with \(R_yR_y^\dagger\) which can be ommitted. But otherwise I see no
<i>obvious</i> way to make the circuit simpler.
</p>
</div>
</div>
</div>

<div id="outline-container-org0a94668" class="outline-3">
<h3 id="org0a94668">Exercise 7.50</h3>
<div class="outline-text-3" id="text-org0a94668">
<p>
Find quantum circuits using just single qubit rotations and \(e^{-\ii\,H/(4\hbar\,J)}\) to
implement the oracle \(O\) for \(x_0\in\{0,1,2\}\).
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The same remark as in <a href="#orgfb993dd">exercise 7.47</a> applies here too.</dd>
</dl>
</div>

<div id="outline-container-org86253b4" class="outline-4">
<h4 id="org86253b4">Solutions</h4>
<div class="outline-text-4" id="text-org86253b4">
<p>
Let us first define all relevant gates
</p>

<div class="org-src-container">
<pre class="src src-sage" id="org6a456c1"><span class="org-variable-name">rx1</span> <span class="org-operator">=</span> kron(rx, Id)
<span class="org-variable-name">rx2</span> <span class="org-operator">=</span> kron(Id, rx)

<span class="org-variable-name">ry1</span> <span class="org-operator">=</span> kron(ry, Id)
<span class="org-variable-name">ry2</span> <span class="org-operator">=</span> kron(Id, ry)

<span class="org-variable-name">rz1</span> <span class="org-operator">=</span> kron(rz, Id)
<span class="org-variable-name">rz2</span> <span class="org-operator">=</span> kron(Id, rz)

<span class="org-variable-name">O1</span> <span class="org-operator">=</span> matrix.diagonal([<span class="org-operator">-</span>1,<span class="org-operator">+</span>1,<span class="org-operator">+</span>1,<span class="org-operator">+</span>1])
<span class="org-variable-name">O2</span> <span class="org-operator">=</span> matrix.diagonal([<span class="org-operator">+</span>1,<span class="org-operator">-</span>1,<span class="org-operator">+</span>1,<span class="org-operator">+</span>1])
<span class="org-variable-name">O3</span> <span class="org-operator">=</span> matrix.diagonal([<span class="org-operator">+</span>1,<span class="org-operator">+</span>1,<span class="org-operator">-</span>1,<span class="org-operator">+</span>1])
<span class="org-variable-name">O4</span> <span class="org-operator">=</span> matrix.diagonal([<span class="org-operator">+</span>1,<span class="org-operator">+</span>1,<span class="org-operator">+</span>1,<span class="org-operator">-</span>1])

<span class="org-comment-delimiter"># </span><span class="org-comment">This is what is called 'P' in the book:</span>
<span class="org-variable-name">PGrov</span>  <span class="org-operator">=</span> matrix.diagonal([<span class="org-operator">+</span>1,<span class="org-operator">-</span>1,<span class="org-operator">-</span>1,<span class="org-operator">-</span>1])
</pre>
</div>

<p>
<a id="org93203dc"></a>
First of all we note that the book made a mistake by swapping the formulas for the oracle
and the other projector. Correct would for example these ones:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> O4 <span class="org-operator">==</span> <span class="org-operator">-</span>i <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx1 <span class="org-operator">*</span> ry1.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> rx2 <span class="org-operator">*</span> ry2.H <span class="org-operator">*</span> sqrtZZ
<span class="org-keyword">assert</span> PGrov <span class="org-operator">==</span> i <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx1.H <span class="org-operator">*</span> ry1.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> rx2.H <span class="org-operator">*</span> ry2.H <span class="org-operator">*</span> sqrtZZ
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
It is not hard to see that one can implement all oracles using
\(\sqrt{Z_1Z_2}=e^{-\ii\,H/(4\hbar\,J)}\) and the single qubit Z-rotations (by 90 degrees):
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-keyword">assert</span> O1 <span class="org-operator">==</span> <span class="org-operator">-</span>i <span class="org-operator">*</span> rz1 <span class="org-operator">*</span> rz2 <span class="org-operator">*</span> sqrtZZ
<span class="org-keyword">assert</span> O2 <span class="org-operator">==</span> rz1.H <span class="org-operator">*</span> rz2 <span class="org-operator">*</span> sqrtZZ
<span class="org-keyword">assert</span> O3 <span class="org-operator">==</span> rz1 <span class="org-operator">*</span> rz2.H <span class="org-operator">*</span> sqrtZZ
<span class="org-keyword">assert</span> O4 <span class="org-operator">==</span> <span class="org-operator">-</span>i <span class="org-operator">*</span> rz1.H <span class="org-operator">*</span> rz2.H <span class="org-operator">*</span> sqrtZZ
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>


<p>
Hence, using \(R_z=R_y^\dagger\,R_x\,R_y\) we can replace the two Z-rotations by six RF
pulses, making them implementable in the framework of NMR quantum computation:
</p>

<p>
<a id="org964800d"></a>
</p>
\begin{align*}
  O_1 &= R_{y1}^\dagger R_{x1} R_{y1} R_{y2}^\dagger R_{x2} R_{y2} \cdot \sqrt{Z_1Z_2} , \\
  O_2 &= R_{y1}^\dagger R_{x1}^\dagger R_{y1} R_{y2}^\dagger R_{x2} R_{y2} \cdot \sqrt{Z_1Z_2} , \\
  O_3 &= R_{y1}^\dagger R_{x1} R_{y1} R_{y2}^\dagger R_{x2}^\dagger R_{y2} \cdot \sqrt{Z_1Z_2} , \\
  O_4 &= R_{y1}^\dagger R_{x1}^\dagger R_{y1} R_{y2}^\dagger R_{x2}^\dagger R_{y2} \cdot \sqrt{Z_1Z_2} .
\end{align*}

<p>
Note that the main text (but take into account the <a href="#org93203dc">typo-fix</a> from above) got a slightly
different formula for \(O_4\). The difference could be explained by usage of a different
formula for expressing Z-rotations as RF-pulses: \(R_z=R_yR_x^{\dagger}R_y^\dagger\).
</p>
</div>
</div>
</div>

<div id="outline-container-org2e8be21" class="outline-3">
<h3 id="org2e8be21">Exercise 7.51</h3>
<div class="outline-text-3" id="text-org2e8be21">
<p>
Show that the Grover iteration can be simplified, by canceling adjacent single qubit
rotations appropriately, to obtain an implemenation for \(G\) (for all possible cases of
\(x_0\)) which uses only 8 RF pulses.
</p>

<dl class="org-dl">
<dt>Remark</dt><dd>The original exercise contained explicit formulas for \(G\), but they were
incorrectly assigned to the values of \(x_0\). I did not write down the corrected versions
since there are different possibilities anyway.</dd>
</dl>
</div>

<div id="outline-container-orgea060c2" class="outline-4">
<h4 id="orgea060c2">Solution</h4>
<div class="outline-text-4" id="text-orgea060c2">
<p>
Recall that the Grover operator is given by (for \(i\in\{0,1,2,3\}\))
</p>

<p>
\[
  G_i = H_1H_2 \cdot P \cdot H_1H_2 \cdot O_i ,
\]
</p>

<p>
where \(O_i\) can be implemented by <a href="#org964800d">the formulas</a> from exercise 7.50, the Hadamard gates by
\(H=R_x^2R_y\), and \(P\) by (e.g.)
</p>

<p>
\[
  P = R_{y1} R_{x1}^\dagger R_{y1}^\dagger R_{y2} R_{x2}^\dagger R_{y2}^\dagger \cdot \sqrt{Z_1Z_2} .
\]
</p>

<p>
\(P\) and \(O_i\) need 6 RF pulses each, the Hadamard gates need 3 each, so in total we need
<i>a priori</i> 24 RF pulses. Let us demonstrate for the example of \(H_1H_2\,P\) and
\(H_1H_2\,O_1\) how to reduce this to 8 pulses. Let us first look at at \(H_1H_2\,O_1\):
</p>

<p>
\[
  H_1 H_2 O_1 = (R_{x1}^2 R_{y1} R_{y1}^\dagger R_{x1} R_{y1})_1 \cdot (\ldots)_2 \cdot \sqrt{Z_1Z_2} .
\]
</p>

<p>
Here \((\ldots)_2\) contains the same content as \((\ldots)_1\) just everything adapted for
the second qubit. Clearly \(R_{y1}R_{y1}^\dagger=1\) and then we can use
\(R_{x1}^3=R_{x1}^\dagger\) to obtain
</p>

<p>
\[
  H_1 H_2 O_1 = (R_{x1}^\dagger R_{y1})_1 \cdot (\ldots)_2 \cdot \sqrt{Z_1Z_2} .
\]
</p>

<p>
Now look at \(H_1H_2\,P\):
</p>

\begin{align*}
  H_1 H_2 P &= (R_{x1}^2 R_{y1} R_{y1} R_{x1}^\dagger R_{y1}^\dagger)_1 \cdot (\ldots)_2 \cdot \sqrt{Z_1Z_2} \\
  &= (R_{x1}^2 R_{y1}^2 R_{x1}^\dagger R_{y1}^\dagger)_1 \cdot (\ldots)_2 \cdot \sqrt{Z_1Z_2} .
\end{align*}

<p>
Here we did the obvious simplification \(R_yR_y=R_y^2\). But there is another trick we can
use (recall that \(X=R_x^2\), \(Y=R_y^2\)):
</p>

<p>
\[
  X R_y(\theta) = R_y(-\theta) X, \quad Y R_x(\theta) = R_x(-\theta) Y .
\]
</p>

<p>
Hence (using \((R_y^2)^\dagger=R_y^2\) in addition):
</p>

\begin{align*}
  H_1 H_2 P &= (R_{y1}^2 R_{x1} R_{y1}^\dagger)_1 \cdot (\ldots)_2 \cdot \sqrt{Z_1Z_2} \\
  &= (R_{x1}^\dagger R_{y1})_1 \cdot (\ldots)_2 \cdot \sqrt{Z_1Z_2} .
\end{align*}

<p>
Let us write down and verify also the other three variants. To be sufficiently certain
that we made no errors in our calcations let's set up sage for the task:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">HH</span> <span class="org-operator">=</span> kron(H, H)

<span class="org-comment-delimiter"># </span><span class="org-comment">The grover iterator for all four cases. PGrov is the P from the latex formulas</span>
<span class="org-variable-name">G1</span> <span class="org-operator">=</span> HH <span class="org-operator">*</span> PGrov <span class="org-operator">*</span> HH <span class="org-operator">*</span> O1
<span class="org-variable-name">G2</span> <span class="org-operator">=</span> HH <span class="org-operator">*</span> PGrov <span class="org-operator">*</span> HH <span class="org-operator">*</span> O2
<span class="org-variable-name">G3</span> <span class="org-operator">=</span> HH <span class="org-operator">*</span> PGrov <span class="org-operator">*</span> HH <span class="org-operator">*</span> O3
<span class="org-variable-name">G4</span> <span class="org-operator">=</span> HH <span class="org-operator">*</span> PGrov <span class="org-operator">*</span> HH <span class="org-operator">*</span> O4
</pre>
</div>

<p>
The following code contains all four implementations and verifies them:
</p>

<div class="org-src-container">
<pre class="src src-sage"><span class="org-variable-name">g1</span> <span class="org-operator">=</span>  1 <span class="org-operator">*</span> rx1.H <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ <span class="org-operator">*</span> rx1.H <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ
<span class="org-variable-name">g2</span> <span class="org-operator">=</span> <span class="org-operator">-</span>i <span class="org-operator">*</span> rx1.H <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ <span class="org-operator">*</span> rx1   <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ
<span class="org-variable-name">g3</span> <span class="org-operator">=</span> <span class="org-operator">-</span>i <span class="org-operator">*</span> rx1.H <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ <span class="org-operator">*</span> rx1.H <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2   <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ
<span class="org-variable-name">g4</span> <span class="org-operator">=</span>  1 <span class="org-operator">*</span> rx1.H <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2.H <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ <span class="org-operator">*</span> rx1   <span class="org-operator">*</span> ry1 <span class="org-operator">*</span> rx2   <span class="org-operator">*</span> ry2 <span class="org-operator">*</span> sqrtZZ

<span class="org-keyword">assert</span> g1 <span class="org-operator">==</span> G1
<span class="org-keyword">assert</span> g2 <span class="org-operator">==</span> G2
<span class="org-keyword">assert</span> g3 <span class="org-operator">==</span> G3
<span class="org-keyword">assert</span> g4 <span class="org-operator">==</span> G4
<span class="org-string">"PASSED"</span>
</pre>
</div>

<pre class="example">
'PASSED'
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc4398b3" class="outline-2">
<h2 id="orgc4398b3">References</h2>
<div class="outline-text-2" id="text-orgc4398b3">
<p>
Jae-Seung Lee (2002). <i>The quantum state tomography on an NMR system</i>, Physics Letters A.</p>
</div>
</div>
<footer class="footer"><p>Made by <a href="https://github.com/rainij">Reinhard Stahn</a> with <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1.50 (<a href="https://orgmode.org">Org</a> mode 9.6.8)</p><p>Find the source code on <a href="https://github.com/rainij/solutions-qcqi-nielsen-chuang">Github</a></p></footer></body></html>